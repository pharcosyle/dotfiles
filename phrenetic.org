#+TITLE: Phrenetic
#+PROPERTY: header-args :mkdirp yes

* Table of Contents :TOC:
- [[#install][Install]]
  - [[#package][Package]]
  - [[#program][Program]]
- [[#system][System]]
  - [[#create][Create]]
  - [[#components][Components]]
  - [[#composite-components][Composite components]]
- [[#home][Home]]
  - [[#create-1][Create]]
  - [[#components-1][Components]]
  - [[#composite-components-1][Composite components]]
- [[#common][Common]]
  - [[#packages][Packages]]
  - [[#stateless][Stateless]]
- [[#utils][Utils]]
  - [[#host][Host]]
  - [[#common-and-build][Common and build]]
- [[#configurations][Configurations]]
  - [[#frostfire][Frostfire]]
- [[#guix-channel][Guix channel]]
- [[#github][Github]]
  - [[#readme][Readme]]
  - [[#license][License]]
- [[#dev][Dev]]
  - [[#git-ignore][Git ignore]]

* Install
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "phrenetic/install.scm")
:END:
Run with ~sudo~.
#+begin_src scheme
(define-module (phrenetic install)
  #:use-module (guix gexp)
  #:use-module (guix packages)
  #:use-module ((gnu packages cryptsetup) #:select (cryptsetup))
  #:use-module ((gnu packages disk) #:select (dosfstools parted))
  #:use-module ((gnu packages linux) #:select (btrfs-progs util-linux))
  #:use-module ((gnu packages package-management) #:select (guix))
  #:use-module (phrenetic utils)
  #:export (installer-package))
#+end_src
** Package
#+begin_src scheme
(define* (installer-package #:rest opts)
  (package
    (inherit simple-package)
    (name "installer")
    (source (apply installer-program opts))
    (arguments
     `(#:builder
       ,#~(begin
            (let ((bin (string-append #$output "/bin")))
              (mkdir #$output)
              (mkdir bin)
              (symlink #$source (string-append bin "/install"))))))))
#+end_src
** Program
#+begin_src scheme
(define* (installer-program #:key
                            os-name
                            efi?
                            boot-label
                            boot-target
                            root-label
                            disk-encryption?
                            luks-label
                            filesystem
                            mountables
                            btrfs-mount-flags
                            btrfs-mount-options)
  (program-file
   "installer"
   (with-imported-modules '((guix build utils))
     #~(begin
         (use-modules ((guix build utils) #:select (invoke mkdir-p))
                      ((ice-9 match) #:select (match-lambda))
                      ((ice-9 readline) #:select (readline))
                      ((ice-9 string-fun) #:select (string-replace-substring)))

         (define* (cmd command #:rest args)
           (display (string-join (cons (basename command) args)))
           (newline)
           (apply invoke (cons command args)))

         (define* (read-user-input prompt #:key default)
           (let ((input (readline (string-append prompt
                                                 (if default
                                                     (string-append " (default " default ")") "")
                                                 ": "))))
             (if (string-null? input)
                 (or default (exit))
                 input)))

         (define (user-pause text)
           (readline (string-append text " Press enter to continue.")))

         (define (display-block-devices)
           (display "Block devices:")
           (newline)
           (invoke #$(file-append util-linux "/bin/lsblk"))
           (newline))

         (display-block-devices)
         (define device
           (read-user-input "Enter device (for exmple, /dev/sda)"))

         (let ((parted-bin #$(file-append parted "/sbin/parted"))
               (align "optimal")
               (boot-size "1GB"))
           (cmd parted-bin device "mklabel" "gpt")
           (for-each (match-lambda
                       ((label start end)
                        (cmd parted-bin "--align" align device "mkpart" label start end)))
                     `(("sky" "0%" ,boot-size)
                       ("earth" ,boot-size "100%")))
           (cmd parted-bin device "set" "1" (if #$efi? "esp" "bios_grub") "on")
           (for-each (lambda (n)
                       (cmd parted-bin device "align-check" align n))
                     '("1" "2")))
         (user-pause "Check that disks are aligned.")

         (display-block-devices)
         (define boot-partition
           (read-user-input (string-append "Boot partition")
                            #:default (string-append device "1")))
         (define root-partition
           (read-user-input (string-append "Root partition")
                            #:default (string-append device "2")))

         (cmd #$(file-append dosfstools "/sbin/mkfs.fat") "-F" "32" "-n" #$boot-label boot-partition)

         (define system-root
           (if #$disk-encryption?
               (let* ((crypt-name "deciphered-new")
                      (crypt-mapping (string-append "/dev/mapper/" crypt-name))
                      (cryptsetup-bin #$(file-append cryptsetup "/bin/cryptsetup")))
                 (cmd cryptsetup-bin "luksFormat" "--type" "luks2" "--pbkdf" "pbkdf2" "--label" #$luks-label root-partition)
                 (cmd cryptsetup-bin "open" root-partition crypt-name)
                 crypt-mapping)
               root-partition))

         (case #$filesystem
           ;; ((#:filesystem/ext4)
           ;;  (cmd #$(file-append e2fsprogs "/sbin/mkfs.ext4") "-L" #$root-label system-root))
           ((#:filesystem/btrfs)
            (cmd #$(file-append btrfs-progs "/bin/mkfs.btrfs") "--label" #$root-label system-root)))

         (define mount-dir
           (read-user-input (string-append "Mount directory")
                            #:default "/mnt"))

         (define mount-bin "/run/setuid-programs/mount")
         (define umount-bin "/run/setuid-programs/umount")

         (when (equal? #$filesystem #:filesystem/btrfs)
           (let ((btrfs-bin #$(file-append btrfs-progs "/bin/btrfs")))
             (cmd mount-bin system-root mount-dir)
             (for-each (match-lambda
                         ((subvol . _)
                          (cmd btrfs-bin "subvolume" "create" (string-append mount-dir "/" subvol))))
                       '#$mountables)
             (cmd umount-bin mount-dir)))

         (case #$filesystem
           ;; ((#:filesystem/ext4)
           ;;  (cmd mount-bin system-root mount-dir))
           ((#:filesystem/btrfs)
            (for-each
             (match-lambda
               ((subvol . mount-point)
                (let ((path-on-mount (string-append mount-dir mount-point)))
                  (mkdir-p path-on-mount)
                  (cmd mount-bin "-o"
                       (string-append
                        "subvol=" subvol
                        (let ((opts (append
                                     (or '#$btrfs-mount-options '())
                                     (map (lambda (flag)
                                            (string-replace-substring (symbol->string flag) "-" ""))
                                          (or '#$btrfs-mount-flags '())))))
                          (if (null? opts)
                              ""
                              (string-append "," (string-join opts ",")))))
                       system-root path-on-mount))))
             '#$mountables)))
         (let ((boot-target-on-mount (string-append mount-dir #$boot-target)))
           (mkdir-p boot-target-on-mount)
           (cmd mount-bin boot-partition boot-target-on-mount))

         (let ((source-dir "/etc/config-source")
               (configs-dir "phrenetic/configs"))
           (cmd #$(file-append guix "/bin/guix") "time-machine"
                (string-append "--channels=" source-dir "/" configs-dir "/" os-name "-channels-lock")
                "--"
                "system"
                (string-append "--load-path=" source-dir)
                "init"
                (string-append source-dir "/" configs-dir "/" #$os-name)
                mount-dir))

         (cmd umount-bin (string-append mount-dir #$boot-target))
         (case #$filesystem
           ;; ((#:filesystem/ext4)
           ;;  (cmd umount-bin mount-dir))
           ((#:filesystem/btrfs)
            (for-each (match-lambda
                        ((_ . mount-point)
                         (cmd umount-bin (string-append mount-dir mount-point))-point))
                      '#$mountables)))))))
#+end_src
* System
:PROPERTIES:
:meta-dir+: /phrenetic
:header-args+: :tangle (meta-in-dir "system.scm")
:END:
#+begin_src scheme
(define-module (phrenetic system)
  #:use-module ((guix hash) #:select (vcs-file?))
  #:use-module ((guix modules) #:select (source-module-closure))
  #:use-module (guix gexp)
  #:use-module (guix packages)
  #:use-module ((guix store) #:select (%default-substitute-urls))
  #:use-module (gnu bootloader)
  #:use-module (gnu bootloader grub)
  #:use-module ((gnu build accounts) #:select (%password-lock-file))
  #:use-module ((gnu packages base) #:select (coreutils))
  #:use-module ((gnu packages certs) #:select (nss-certs))
  #:use-module ((gnu packages fonts) #:select (font-terminus))
  #:use-module ((gnu packages gnome) #:select (network-manager-applet))
  #:use-module ((gnu packages linux) #:select (brightnessctl customize-linux e2fsprogs kbd linux-libre pipewire util-linux))
  #:use-module ((gnu packages wm) #:select (swaylock-effects))
  #:use-module (gnu services)
  #:use-module (gnu services base)
  #:use-module (gnu services desktop)
  #:use-module ((gnu services linux) #:select (kernel-module-loader-service-type))
  #:use-module (gnu services networking)
  #:use-module ((gnu services nix) #:select (nix-service-type))
  #:use-module (gnu services shepherd)
  #:use-module ((gnu services sound) #:select (alsa-service-type pulseaudio-service-type))
  #:use-module ((gnu services xorg) #:select (gdm-service-type gdm-configuration screen-locker-service screen-locker-service-type))
  #:use-module (gnu services virtualization)
  #:use-module (gnu system)
  #:use-module (gnu system accounts)
  #:use-module (gnu system file-systems)
  #:use-module (gnu system keyboard)
  #:use-module (gnu system mapped-devices)
  #:use-module ((nongnu packages linux) #:select (linux linux-firmware broadcom-bt-firmware))
  #:use-module ((nongnu system linux-initrd) #:select (microcode-initrd))
  #:use-module ((rde gexp) #:select (slurp-file-like))
  #:use-module (rde system services networking)
  #:use-module ((phrenetic packages facetimehd) #:select (facetimehd))
  #:use-module ((phrenetic packages facetimehd-firmware) #:select (facetimehd-firmware))
  #:use-module ((phrenetic packages haskell-apps) #:select (kmonad))
  #:use-module ((phrenetic packages linux) #:select (broadcom-sta))
  #:use-module ((phrenetic stateless) #:prefix stateless:)
  #:use-module (phrenetic utils)
  #:use-module ((ice-9 match) #:select (match match-lambda))
  #:use-module ((srfi srfi-1) #:select (any delete-duplicates first remove iota))
  #:export (blank-os
            source
            base-services
            classic-login
            greetd-login
            certs
            accounts
            guix-pm
            nix-pm
            console-fonts
            kmonad-tool
            desktop-base-services
            classic-sound
            pipewire-multimedia
            network-manager
            bluetooth
            gdm
            desktop-tty
            gnome-desktop
            sway-wm
            host-info
            %root-label
            ;; ext4
            btrfs
            %btrfs-mount-flags
            %btrfs-mount-options
            disk-encryption
            %luks-uuid
            swap
            stateless
            %stateless-storage-paths
            %stateless-mountables
            linux-kernel
            grub-efi
            %efi-label
            %efi-boot-target
            console-keyboard-layouts
            virtualization
            macbook
            %macbook-kb-layout
            os-base
            with-macbook-hardware))

(define %random-seed-file (@@ (gnu services base) %random-seed-file))

;; Not exported. Probably an oversight that'll get fixed at some point.
(define greetd-terminals (@@ (gnu services base) greetd-terminals))
(define greetd-terminal-vt (@@ (gnu services base) greetd-terminal-vt))
#+end_src
** Create
#+begin_src scheme
(define blank-os
  (operating-system
    (host-name #f)
    (timezone #f)
    (bootloader #f)
    (services '())
    (file-systems %base-file-systems)))
#+end_src
** Components
#+begin_src scheme
(define-syntax-rule (system-comp os field ...)
  (operating-system
    (inherit os)
    field ...))

(define-syntax define-system-comp
  (lambda (x)
    (syntax-case x ()
      ((_ (name arg ...) field ...)
       (with-syntax ((os (datum->syntax x 'os)))
         #'(define* (name os arg ...)
             (system-comp os field ...)))))))
#+end_src
*** Source
#+begin_src scheme
(define-system-comp (source #:key path)
  (services
   (append
    (operating-system-user-services os)
    (list
     (simple-service
      'config-source
      etc-service-type
      `(("config-source" ,(local-file
                           path
                           #:recursive? #t
                           #:select? (negate vcs-file?)))))))))
#+end_src
*** Base services
#+begin_src scheme
(define-system-comp (base-services #:key stateless?)
  (services
   (append
    (operating-system-user-services os)
    (remove-services
     %base-services
     (list login-service-type
           agetty-service-type
           mingetty-service-type
           console-font-service-type
           guix-service-type))
    (if stateless?
        (list
         (stateless-service
          'base-services
          #:state `(((#:path . ,%random-seed-file)
                     (#:storage . #:machine))
                    ((#:path . "/var/db/nscd/")
                     (#:storage . #:machine))
                    ((#:path . "/.lastweek")
                     (#:storage . #:machine)))
          #:ignore '(((#:path . "/etc/resolv.conf"))
                     ((#:path . "/etc/resolv.conf.bak"))
                     ((#:path . "/bin/sh")
                      (#:preds . ((#:symlink-to-store))))
                     ((#:path . "/usr/bin/env")
                      (#:preds . ((#:symlink-to-store)))))))))))
#+end_src
*** Login
**** Classic
#+begin_src scheme
(define-system-comp (classic-login #:key number-of-ttys)
  (services
   (append
    (operating-system-user-services os)
    (list (service login-service-type)
          (service agetty-service-type (agetty-configuration
                                        (extra-options '("-L"))
                                        (term "vt100")
                                        (tty #f)
                                        (shepherd-requirement '(syslogd)))))
    (map (lambda (n)
           (service mingetty-service-type (mingetty-configuration
                                           (tty (string-append "tty" (number->string n))))))
         (iota number-of-ttys 1)))))
#+end_src
**** Greetd
#+begin_src scheme
(define-system-comp (greetd-login #:key number-of-ttys)
  (services
   (cons* (service greetd-service-type
                   (greetd-configuration
                    (terminals
                     (map (lambda (n)
                            (greetd-terminal-configuration
                             (terminal-vt (number->string n))))
                          (iota number-of-ttys 1)))))
          (operating-system-user-services os))))
#+end_src
*** Certificates
#+begin_src scheme
(define-system-comp (certs)
  (packages
   (cons* nss-certs
          (operating-system-packages os))))
#+end_src
*** Accounts
#+begin_src scheme
(define-system-comp (accounts #:key users-info)
  (users
   (append
    (operating-system-users os)
    (map (lambda (user-info)
           (apply account (alist->list user-info)))
         users-info))))

(define* (account #:key
                  name
                  comment
                  ;; shell
                  admin?)
  (user-account
   (name name)
   (comment (or comment ""))
   (group "users")
   (supplementary-groups (append '("netdev" "audio" "video")
                                 (if admin? '("wheel") '())))
   ;; (shell (case shell
   ;;          ((#:shell/bash) ...)
   ;;          ((#:shell/zsh) ...)))
   ))
#+end_src
*** Package management
**** Guix
#+begin_src scheme
(define-system-comp (guix-pm #:key
                             (nonguix-substitutes? #t)
                             stateless?)
  (services
   (append
    (operating-system-user-services os)
    (list
     (service guix-service-type))
    (if nonguix-substitutes?
        (list (nonguix-substitutes-service)) '())
    ;; TODO Should these (at least e.g. "/var/guix") be in Stateless > Guix System?
    (if stateless?
        (list
         (stateless-service
          'guix-pm
          #:state '(((#:path . "/etc/guix/signing-key.pub")
                     (#:storage . #:machine)
                     (#:parent-dir-perms . ((#:mode . #o111))))
                    ((#:path . "/etc/guix/signing-key.sec")
                     (#:storage . #:machine)
                     (#:parent-dir-perms . ((#:mode . #o111)))))
          #:ignore `(;((#:path . "/gnu/store/")) ; TODO inscrutable error on system build: "guix system: error: path `/gnu/store/' is not in the store"
                     ((#:path . "/var/guix/"))
                     ((#:path . "/etc/guix/acl")
                      (#:preds . ((#:symlink-to-store))))
                     ((#:path . ,(string-append (user-account-home-directory %root-account) "/.cache/guix/"))))))
        '()))))
#+end_src
***** Nonguix substitutes
#+begin_src scheme
(define (nonguix-substitutes-service)
  (simple-service
   'nonguix-substitutes
   guix-service-type
   (guix-extension
    (authorized-keys
     (list (local-file "substitutes.nonguix.org.pub")))
    (substitute-urls
     (list "https://substitutes.nonguix.org")))))
#+end_src
****** Signing key
#+begin_src scheme :tangle (meta-in-dir "substitutes.nonguix.org.pub")
(public-key
 (ecc
  (curve Ed25519)
  (q #C1FD53E5D4CE971933EC50C9F307AE2171A2D3B52C804642A7A35F84F3A4EA98#)))
#+end_src
**** Nix
#+begin_src scheme
(define* (nix-pm os
                 #:key
                 stateless?
                 stateless-machine-dir)
  (as-> os $
    (system-comp
     $
     (services
      (append
       (operating-system-user-services os)
       (list
        (service nix-service-type)))))
    (if stateless?
        (stateless-nix $ #:machine-dir stateless-machine-dir) $)))

(define* (stateless-nix os #:key machine-dir)
  (let ((nix-machine-dir (string-append machine-dir "/nix"))) ; TODO Maybe rename this folder ".nix" to be consistent with ".swap". Update: or maybe not, the path on machine-dir does correspond to the path in the live file system (at "/").
    (system-comp
     os
     (file-systems
      (cons* (file-system
               (device nix-machine-dir)
               (mount-point "/nix")
               (type "none")
               (flags '(bind-mount))
               (check? #f))
             (operating-system-file-systems os)))
     (services
      (append
       (operating-system-user-services os)
       (list
        (simple-service 'create-nix-dir
                        activation-service-type
                        #~(when (not (file-exists? #$nix-machine-dir))
                            (mkdir #$nix-machine-dir)))
        (stateless-service
         'nix-pm
         #:ignore '(((#:path . "/nix/store/"))
                    ((#:path . "/nix/var/nix/"))
                    ((#:path . "/nix/var/log/nix/"))
                    ((#:path . ,(string-append (user-account-home-directory %root-account) "/.cache/nix/")))
                    ;; TODO maybe do each sub-path ("/nix/store", "/nix/var/nix", and "/nix/var/log/nix") here like I do above.
                    ((#:path . "nix/")
                     (#:storage . #:machine))))))))))
#+end_src
*** Console
**** Fonts
#+begin_src scheme
(define-system-comp (console-fonts #:key
                                   number-of-ttys
                                   (hidpi? #t))
  (services
   (cons* (service console-font-service-type
                   (map (lambda (n)
                          (cons (string-append "tty" (number->string n))
                                (if hidpi?
                                    (file-append font-terminus "/share/consolefonts/ter-132n")
                                    %default-console-font)))
                        (iota number-of-ttys 1)))
          (operating-system-user-services os))))
#+end_src
**** KMonad
Must succeed [[*Accounts][Accounts]] component.
#+begin_src scheme
(define-system-comp (kmonad-tool #:key who)
  (packages
   (cons* kmonad
          (operating-system-packages os)))
  (users
   (accounts-with-groups (operating-system-users os) who '("input")))
  (services
   (cons* (udev-rules-service 'kmonad-add-udev-rules kmonad)
          (operating-system-user-services os))))
#+end_src
*** Desktop
**** Base services
#+begin_src scheme
(define-system-comp (desktop-base-services #:key stateless?)
  (services
   (append
    (operating-system-user-services os)
    (remove-services
     %desktop-services
     (append
      (map service-kind %base-services)
      (list screen-locker-service-type
            network-manager-service-type
            wpa-supplicant-service-type
            (service-kind
             (simple-service 'network-manager-applet
                             profile-service-type
                             (list network-manager-applet)))
            gdm-service-type
            (service-kind gdm-file-system-service)
            pulseaudio-service-type
            alsa-service-type)))
    (if stateless?
        (list
         (stateless-service
          'desktop-base-services
          #:state '(((#:path . "/etc/machine-id")
                     (#:storage . #:machine))
                    ((#:path . "/var/lib/upower/")
                     (#:storage . #:machine))
                    ;; ((#:path . "/var/lib/AccountsService/")
                    ;;  (#:storage . #:machine))
                    ;; ((#:path . "/var/lib/colord/")
                    ;;  (#:storage . #:machine))
                    ;; ((#:path . "/var/lib/udisks2/")
                    ;;  (#:storage . #:machine))
                    )
          #:ignore `(((#:path . ,(string-append (file-system-mount-point %fontconfig-file-system) "/"))
                      (#:preds . ((#:empty-dir)))))))
        '()))))
#+end_src
**** Multimedia
***** Classic sound
#+begin_src scheme
(define-system-comp (classic-sound)
  (services
   (append
    (operating-system-user-services os)
    (list (service pulseaudio-service-type)
          (service alsa-service-type)))))
#+end_src
***** Pipewire
#+begin_src scheme
(define-system-comp (pipewire-multimedia)
  (services
   (cons* (udev-rules-service 'pipewire-add-udev-rules
                              pipewire)
          (operating-system-user-services os))))
#+end_src
**** Network
***** Network manager
#+begin_src scheme
(define-system-comp (network-manager #:key
                                     (iwd? #t)
                                     stateless?)
  (services
   (append
    (operating-system-user-services os)
    (list
     (service network-manager-service-type
              (network-manager-configuration
               (iwd? iwd?)))
     (if iwd?
         (service iwd-service-type
                  (iwd-configuration
                   (main-conf
                    '((Settings ((AutoConnect . #t)))))))
         (service wpa-supplicant-service-type)))
    (if stateless?
        (list
         (stateless-service
          'network-manager
          #:state '(((#:path . "/etc/NetworkManager/system-connections/")
                     (#:storage . #:machine))
                    ((#:path . "/var/lib/NetworkManager/")
                     (#:storage . #:machine)
                     (#:mode . #o700)))))
        '()))))
#+end_src
**** Bluetooth
Must succeed [[*Accounts][Accounts]] component.
#+begin_src scheme
(define-system-comp (bluetooth #:key
                               who
                               stateless?)
  (users
   (accounts-with-groups (operating-system-users os) who '("lp")))
  (services
   (append
    (operating-system-user-services os)
    (list
     (bluetooth-service #:auto-enable? #t))
    (if stateless?
        (list
         (stateless-service
          'bluetooth
          #:state '(((#:path . "/var/lib/bluetooth/")
                     (#:storage . #:machine)
                     (#:mode . #o700)))))
        '()))))
#+end_src
**** Login management
***** Login managers
****** GDM
#+begin_src scheme
(define-system-comp (gdm #:key
                         (wayland? #t)
                         auto-login?
                         auto-login-user
                         stateless?)
  (services
   (append
    (operating-system-user-services os)
    (list
     (service gdm-service-type
              (gdm-configuration
               (auto-login? auto-login?)
               (default-user auto-login-user)
               (wayland? wayland?)))
     gdm-file-system-service)
    (if stateless?
        (list
         (stateless-service
          'gdm
          #:ignore `(((#:path . ,(string-append (file-system-mount-point %gdm-file-system) "/"))))))
        '()))))
#+end_src
***** Desktop TTY
#+begin_src scheme
(define-system-comp (desktop-tty #:key
                                 greetd?
                                 (tty-number 2)
                                 auto-login?
                                 auto-login-user)
  (services
   (cons* (switch-to-tty-service #:tty-number tty-number)
          (if auto-login?
              (with-auto-login-to-tty (operating-system-user-services os)
                                      #:greetd? greetd?
                                      #:tty-number tty-number
                                      #:user auto-login-user)
              (operating-system-user-services os)))))

(define* (switch-to-tty-service #:key tty-number)
  (simple-service
   'switch-to-tty
   shepherd-root-service-type
   (list
    (shepherd-service
     (provision '(switch-to-tty))
     (requirement '(virtual-terminal))
     (one-shot? #t)
     (start #~(lambda ()
                (invoke #$(file-append kbd "/bin/chvt")
                        (number->string #$tty-number))))))))

(define* (with-auto-login-to-tty services #:key greetd? tty-number user)
  (if greetd?
      (modify-services services
        (greetd-service-type
         config =>
         (greetd-configuration
          (inherit config)
          (terminals
           (map (lambda (terminal-config)
                  (if (equal? (greetd-terminal-vt terminal-config)
                              (number->string tty-number))
                      ;; It'd be better to set user/command for initial-session rather than default-session (auto-login would only occur on the first start) but the Guix configuration doesn't have that option (yet?).
                      (greetd-terminal-configuration
                       (inherit terminal-config)
                       (default-session-user user)
                       (default-session-command "default-session-start"))
                      terminal-config))
                (greetd-terminals config))))))
      (modify-services services
        (mingetty-service-type
         config =>
         (if (equal? (mingetty-configuration-tty config)
                     (string-append "tty" (number->string tty-number)))
             (mingetty-configuration
              (inherit config)
              (auto-login user))
             config)))))
#+end_src
**** Sessions
***** Desktop environments
****** GNOME
#+begin_src scheme
(define-system-comp (gnome-desktop)
  (services
   (cons* (service gnome-desktop-without-package-service-type)
          (operating-system-user-services os))))

(define gnome-desktop-without-package-service-type
  (let ((base gnome-desktop-service-type))
    (service-type
     (inherit base)
     (extensions
      (remove (lambda (ext)
                (equal? (service-extension-target ext) profile-service-type))
              (service-type-extensions base))))))
#+end_src
***** Window managers
****** Sway
#+begin_src scheme
(define-system-comp (sway-wm)
  (services
   (append (operating-system-user-services os)
           (list swaylock-service
                 brightnessctl-udev-rules))))
#+end_src
****** Pieces
******* Screen lockers
******** Swaylock
#+begin_src scheme
(define swaylock-service
  (screen-locker-service swaylock-effects "swaylock"))
#+end_src
******* Backlight
******** Brightnessctl
#+begin_src scheme
(define brightnessctl-udev-rules
  (udev-rules-service 'brightnessctl-add-udev-rules brightnessctl))
#+end_src
*** Device-specific
**** Host
#+begin_src scheme
(define-system-comp (host-info #:key
                               host-name
                               timezone
                               locale)
  (host-name host-name)
  (timezone (or timezone "Etc/UTC"))
  (locale (or locale "en_US.utf8")))
#+end_src
**** File systems
#+begin_src scheme
(define %root-label "firmament")
#+end_src
***** Ext4
#+begin_src scheme
;; (define-system-comp (ext4 #:key label)
;;   (file-systems
;;    (cons* (file-system
;;             (device (file-system-label label))
;;             (mount-point "/")
;;             (type "ext4"))
;;           (operating-system-file-systems os))))
#+end_src
***** Btrfs
#+begin_src scheme
(define-system-comp (btrfs #:key
                           label
                           subvols
                           flags
                           options)
  (file-systems
   (append
    (map (match-lambda
           ((subvol . mount-point)
            (file-system
              (device (file-system-label label))
              (mount-point mount-point)
              (type "btrfs")
              (flags (or flags '()))
              (options (string-append
                        "subvol=" subvol
                        (if options
                            (string-append "," (string-join options ","))
                            ""))))))
         subvols)
    (operating-system-file-systems os))))

(define %btrfs-mount-flags '(no-atime))
(define %btrfs-mount-options '("compress=zstd" "autodefrag"))
#+end_src
**** Disk encryption
Must succeed [[*File systems][File systems]] component.
#+begin_src scheme
(define* (disk-encryption os
                          #:key
                          device-uuid
                          (target "deciphered")
                          mount-points)
  (let ((encrypted-device (mapped-device
                           (source (uuid device-uuid))
                           (targets (list target))
                           (type luks-device-mapping))))
    (system-comp
     os
     (mapped-devices
      (cons* encrypted-device
             (operating-system-mapped-devices os)))
     (file-systems
      (map (lambda (fs)
             (if (member (file-system-mount-point fs) mount-points)
                 (file-system
                   (inherit fs)
                   (dependencies (cons* encrypted-device
                                        (file-system-dependencies fs))))
                 fs))
           (operating-system-file-systems os))))))

(define %luks-uuid "bdda56af-6ca0-4953-bc13-d5af8715e0e5")
#+end_src
**** Swap
No ~swap-space-dependencies~ are required as long as the file system on which the swap file resides is ~needed-for-boot?~ (indeed, adding them triggers a build error since no Shepherd service is created for such file systems).
#+begin_src scheme
(define* (swap os
               #:key
               (target "/.swap")
               file-size
               file-no-cow?
               stateless?
               stateless-machine-dir)
  (let* ((file-target? (string? target))
         (target* (if (and file-target? stateless?)
                     (string-append stateless-machine-dir target)
                     target)))
    (system-comp
     os
     (swap-devices
      (list
       (swap-space
        (target target*))))
     (services
      (append
       (operating-system-user-services os)
       (if file-target?
           (append
            (list
             (simple-service 'create-swapfile
                             activation-service-type
                             (create-swapfile-gexp target* file-size file-no-cow?)))
            (if stateless?
                (list
                 (stateless-service
                  'swapfile
                  #:ignore `(((#:path . ,target)
                              (#:storage . #:machine)))))
                '()))
           '()))))))

(define (create-swapfile-gexp swapfile size no-cow?)
  (with-imported-modules '((guix build utils))
    #~(begin
        (use-modules ((guix build utils) #:select (invoke mkdir-p)))

        (when (not (file-exists? #$swapfile))
          (mkdir-p (dirname #$swapfile))
          (invoke #$(file-append coreutils "/bin/truncate") "--size" "0" #$swapfile)
          (when #$no-cow?
            (invoke #$(file-append e2fsprogs "/bin/chattr") "+C" #$swapfile))
          (invoke #$(file-append util-linux "/bin/fallocate") "--length" (number->string #$size) #$swapfile)
          (chmod #$swapfile #o600)
          (invoke #$(file-append util-linux "/sbin/mkswap") #$swapfile)))))
#+end_src
**** Stateless
Must succeed [[*File systems][File systems]] component. To be useful, the stateless service's activation must happen before that of other services that create state so including this comonent after all others is safest.
#+begin_src scheme
(define* (stateless os
                    #:key
                    storage-paths
                    hes
                    state-users
                    password-users
                    root-size)
  (as-> os $
    (system-comp
     $
     (file-systems
      (->> (operating-system-file-systems os)
           (cons* (file-system
                    (device ":/root") ; HACK Guix boot will hang forever waiting for a device to appear even though this is a tmpfs. Fake it out by using a name that looks like an NFS device (see `canonicalize-device-spec'). Thus the ":/" is necessary but the name is otherwise arbitrary.
                    (mount-point "/")
                    (options (if root-size
                                 (string-append "size=" (number->string root-size))
                                 #f))
                    (type "tmpfs")
                    (check? #f)))
           (map (lambda (fs)
                  (if (member (file-system-mount-point fs)
                              (cons "/var/guix"
                                    (map (match-lambda ((_ . dir) dir))
                                         storage-paths)))
                      (file-system
                        (inherit fs)
                        (needed-for-boot? #t))
                      fs)))))
     (services
      ;; Important: put the stateless-service *after* the rest of the operating system services.
      (append
       (operating-system-user-services os)
       (list
        (service stateless-service-type
                 (let ((machine-dir (assoc-ref storage-paths #:machine)))
                   `(#:storage-paths ,storage-paths
                     #:hes ,(or hes '())
                     #:state-users ,(or state-users '())
                     #:password-files ,(->> (or password-users '())
                                            (cons (user-account-name %root-account))
                                            (map (lambda (user)
                                                   `(,user . ,(string-append machine-dir
                                                                             "/.passwords/"
                                                                             user)))))
                     #:symlink-log-dir? #t
                     #:log-storage-dir ,machine-dir)))))))

    (stateless-guix-system $)))

(define %stateless-storage-paths
  `((#:machine . "/.machine")
    (#:persist . "/.persist")))

(define %stateless-mountables
  (append
   `(("boot" . "/boot")
     ("guix-store" . "/gnu/store")
     ("guix-var" . "/var/guix"))
   (map (match-lambda
          ((storage . dir)
           (cons (case storage
                   ((#:machine) "machine")
                   ((#:persist) "persist"))
                 dir)))
        %stateless-storage-paths)))
#+end_src
***** Service
****** Service type
#+begin_src scheme
(define stateless-service-type
  (service-type
   (name 'stateless)
   (extensions
    (list (service-extension boot-service-type
                             (lambda (config)
                               (boot-gexp
                                (assoc-ref config #:symlink-log-dir?)
                                (assoc-ref config #:log-storage-dir)
                                (assoc-ref config #:password-files))))
          (service-extension activation-service-type
                             (lambda (config)
                               (activation-gexp
                                (assoc-ref config #:state-users)
                                (assoc-ref config #:state)
                                (assoc-ref config #:storage-paths))))
          (service-extension shepherd-root-service-type
                             (lambda (config)
                               (activate-he-shepherd-services
                                (assoc-ref config #:hes))))
          (service-extension profile-service-type
                             (lambda (config)
                               (list (stateless:tool-package
                                      "stateless"
                                      (assoc-ref config #:state)
                                      (assoc-ref config #:ignore)
                                      "/"
                                      (assoc-ref config #:storage-paths)
                                      ;; #:additional-known
                                      ;; (system-additional-known (map car (assoc-ref config #:hes)))
                                      ))))))
   (compose identity)
   (extend (lambda (config exts)
             (stateless:extend-proc
              config

              exts
              ;; (append exts
              ;;         (list `((#:ignore . ,(map (lambda (store)
              ;;                                     (string-append store "/"))
              ;;                                   ;; (map (match-lambda ((_ . dir) dir)) (assoc-ref config #:storage-paths))
              ;;                                   '(list
              ;;                                     "/.persist"
              ;;                                     "/.machine")))))
              ;;         (if #t ; TODO (assoc-ref config #:symlink-log-dir?)
              ;;             (list '((#:ignore . ("/var/log"))))
              ;;             '()))
              )))
   (description "Initialize a stateless system.")))
#+end_src
******* Boot
#+begin_src scheme
(define (boot-gexp symlink-log-dir? log-storage-dir password-files)
  (gexps->gexp
   (list (populate-root-gexp symlink-log-dir? log-storage-dir)
         (populate-passwords-gexp password-files))))

(define (populate-root-gexp symlink-log-dir? log-storage-dir)
  (with-imported-modules '((guix build utils))
    #~(begin
        (use-modules ((guix build utils) #:select (mkdir-p))
                     ((ice-9 match) #:select (match-lambda)))

        (for-each
         (match-lambda
           ((dir . mode)
            (mkdir-p dir)
            (chmod dir mode))
           (dir
            (mkdir-p dir)))
         ;; Taken from `populate-root-file-system'. Some of these might not be necessary (for example, "/tmp" and "/var/run" are deleted and recreated in `cleanup-service-type') but it's safest to do them here anyway just in case some early-running code assumes their presence.
         '("/bin"
           "/etc"
           ("/gnu/store" . #o1775)
           "/home"
           "/mnt"
           "/run"
           ("/tmp" . #o1777)
           "/var/db"
           "/var/empty"
           ("/var/lock" . #o1777)
           "/var/run"
           ("/var/tmp" . #o1777)))

        (let ((log-dir "/var/log"))
          (if #$symlink-log-dir?
              (let ((log-state-dir (string-append #$log-storage-dir log-dir)))
                (mkdir-p log-state-dir)
                (symlink log-state-dir log-dir))
              (mkdir-p log-dir))))))

;; HACK Guix assumes /etc/shadow is persistent between reboots and doesn't allow specifying a password file (like Nix's `passwordFile') so imitate this functionality by writing a shadow file on every boot populated with our users and their password hashes. The file doesn't have to be complete: Guix will add the missing entries (for system accounts, etc).
(define (populate-passwords-gexp password-files)
  (with-imported-modules (source-module-closure
                          '((gnu build accounts)))
    #~(begin
        (use-modules ((gnu build accounts) #:select (shadow-entry write-shadow))
                     ((ice-9 match) #:select (match-lambda))
                     ((ice-9 textual-ports) #:select (get-line)))

        (write-shadow
         (map (match-lambda
                ((user . password-file)
                 (shadow-entry
                  (name user)
                  (password (if (file-exists? password-file)
                                (call-with-input-file password-file get-line)
                                ""))
                  (last-change #f))))
              '#$password-files)))))
#+end_src
******* Activation
#+begin_src scheme
(define (activation-gexp state-users state storage-paths)
  (gexps->gexp
   (list (create-state-homes-gexp state-users
                                  (map (match-lambda ((_ . dir) dir))
                                       storage-paths))
         (activate-gexp state storage-paths))))

(define (create-state-homes-gexp users storage-dirs)
  (with-imported-modules '((guix build utils))
    #~(begin
        (use-modules ((guix build utils) #:select (mkdir-p)))

        (for-each
         (lambda (user)
           (let* ((pw (getpwnam user))
                  (home (passwd:dir pw)))
             (for-each (lambda (storage-dir)
                         (let ((state-home (string-append storage-dir home)))
                           (mkdir-p state-home)
                           (chmod state-home #o700)
                           (chown state-home (passwd:uid pw) (passwd:gid pw))))
                       '#$storage-dirs)))
         '#$users))))

(define (activate-gexp state storage-paths)
  (with-imported-modules '((guix build utils) (phrenetic build utils) (phrenetic build stateless))
    ;; (source-module-closure
    ;;  '((phrenetic build stateless))
    ;;  #:select? (const #t)
    ;;  ;; #:select? (lambda (name)
    ;;  ;;             (or ((@ (guix modules) guix-module-name?) name)
    ;;  ;;                 (eq? (car name) 'phrenetic)))
    ;;  )
    #~(begin
        (use-modules ((phrenetic build stateless) #:select (activate)))
        (activate '#$state
                  ""
                  '#$storage-paths))))
#+end_src
******* Shepherd
#+begin_src scheme
(define (activate-he-shepherd-services hes)
  (cons (user-homes-shepherd-service (map (match-lambda ((user . _) user))
                                          hes))
        (map (match-lambda
               ((user . he)
                (activate-he-shepherd-service user he)))
             hes)))

(define (activate-he-shepherd-service user he)
  (shepherd-service
   (provision (list (symbol-append 'stateless-home- (string->symbol user))))
   (requirement '(stateless-user-homes))
   (one-shot? #t)
   (start #~(make-forkexec-constructor
             '(#$(file-append he "/activate"))
             #:user #$user
             #:group (group:name (getgrgid (passwd:gid (getpw #$user))))
             #:log-file (string-append "/var/log/stateless-home-" #$user ".log")
             #:environment-variables
             (list (string-append "HOME=" (passwd:dir (getpw #$user))))))
   (stop #~(make-kill-destructor))))

;; HACK Clear the home directories because the `user-homes' shepherd service puts skeleton files in them. Only do this when a new user is added and on startup activation, not reconfigure activation: determine which it is by checking for the presence of ".guix-home".
(define (user-homes-shepherd-service users)
  (shepherd-service
   (provision '(stateless-user-homes))
   (requirement '(user-homes))
   (one-shot? #t)
   (start (with-imported-modules '((guix build utils)) ; Donno if `with-imported-modules' is necessary. Most of the Shepherd services in Guix (that are defined this way, i.e. with a lambda gexp) don't have it but a few do and it doesn't seem to hurt anything.
            #~(lambda ()
                (define (run)
                  (for-each
                   (lambda (user)
                     (let ((home (passwd:dir (getpwnam user))))
                       (when (not (file-exists? (string-append home "/.guix-home")))
                         (delete-directory-contents home))))
                   '#$users))

                (define (delete-directory-contents dir)
                  (for-each (lambda (name)
                              (delete-file-recursively (string-append dir "/" name)))
                            (scandir dir (lambda (name)
                                           (not (member name '("." "..")))))))

                (run)
                #t)))
   (modules '(((guix build utils) #:select (delete-file-recursively))
              ((ice-9 ftw) #:select (scandir))))))
#+end_src
******* Tool
#+begin_src scheme
(define (system-additional-known users)
  #~(append
     #$etc-static-files
     ;; #$root-skeleton-files ; TODO commenting this I fix / am sure doesn't matter: "warning: importing module (guix config) from the host"
     #$(user-homes users)))

(define etc-static-files
  (with-imported-modules '((guix build utils))
    #~(begin
        (use-modules ((guix build utils) #:select (symbolic-link?))
                     ((ice-9 ftw) #:select (scandir)))

        (let ((etc-static-dir "/etc/static"))
          (map (lambda (file)
                 (let ((target (string-append "/etc/" file))
                       (source (string-append etc-static-dir "/" file))
                       ;; TODO maybe replace with `directory-exists?', for brevity.
                       (directory? (lambda (path)
                                     (eq? (stat:type (stat path)) 'directory))))
                   (cons target
                         (if (directory? source)
                             (lambda (f)
                               (and (symbolic-link? f)
                                    (string-prefix? etc-static-dir (readlink f))))
                             (const #t))))) ; TODO a file (not a directory or a symlink)
               (scandir etc-static-dir (lambda (name)
                                         (not (member name '("." ".."))))))))))

;; TODO old implementation, remove
;; (define etc-static-files
;;   (with-imported-modules '((guix build utils))
;;     #~(begin
;;         (use-modules ((guix build utils) #:select (find-files)))

;;         (let ((etc-static-dir "/etc/static"))
;;           (map (lambda (file)
;;                  (cons (string-append "/etc" (string-drop file (string-length etc-static-dir)))
;;                        (if (equal? (dirname file) etc-static-dir)
;;                            (const #t) ; TODO a file (not a directory or a symlink)
;;                            symlink-to-store?)))
;;                (find-files etc-static-dir))))))


;; (define root-skeleton-files
;;   (with-imported-modules (source-module-closure
;;                           '((guix build utils)
;;                             (guix utils)))
;;     #~(begin
;;         (use-modules ((guix build utils) #:select (find-files))
;;                      ((guix utils) #:select (readlink*)))

;;         (let ((skel-dir (readlink* "/etc/skel")))
;;           (map (lambda (file)
;;                  (cons (string-append "/root" (string-drop file (string-length skel-dir)))
;;                        (const #t))) ; TODO a file with contents equal to the corresponding skeleton file
;;                (find-files skel-dir))))))

(define (user-homes users)
  #~(map (lambda (user)
           (let ((directory? (lambda (path)
                               (eq? (stat:type (lstat path)) 'directory))))
             (cons (string-append (passwd:dir (getpwnam user)) "/")
                   directory?))) ; TODO stat or lstat probably not important
         '#$users))




;; passwd subcommand WIP

;; (use-modules ((guix build utils) #:select (invoke mkdir-p)))

;; (define (enter-pass)
;;   (let ((pass (getpass "New password: "))
;;         (retype (getpass "Retype new password: ")))
;;     (if (equal? pass retype)
;;         pass
;;         (begin
;;           (display "Passwords do not match.")
;;           #f
;;           ;; (exit)
;;           ))))


;; (let ((pass (enter-pass)))
;;   (when pass
;;     ;; (invoke "/run/setuid-programs/passwd")

;;     (crypt pass (string-append "$" "6" "$" "sosalty"))

;;     (mkdir-p "/.machine/.passwords")
;;     ))
#+end_src
******* Shared
#+begin_src scheme
(define (gexps->gexp gexps)
  #~(begin
      #$@gexps))
#+end_src
****** Extension helper
#+begin_src scheme
(define stateless-service
  (stateless:service-fn stateless-service-type))
#+end_src
***** Guix system
#+begin_src scheme
(define* (stateless-guix-system os)
  (as-> os $
    (system-comp
     $
     (services
      (cons* (stateless-service
              'guix-system
              #:ignore `(;; General Linux system.
                         ((#:path . "/dev/"))
                         ((#:path . "/proc/"))
                         ((#:path . "/run/"))
                         ((#:path . "/sys/"))
                         ((#:path . "/tmp/"))
                         ((#:path . "/var/lock/"))
                         ((#:path . "/var/run/"))
                         ;; ((#:path . "/var/tmp/")) ; FHS specifies this should be preserved between reboots. I'm leaving it commented out for now because I want to know if something shows up. I'll decide then if I should be symlinking individual state files/dirs inside this directory or the directory entirely.
                         ((#:path . "/etc/group"))
                         ((#:path . "/etc/passwd"))
                         ((#:path . "/etc/shadow"))
                         ((#:path . ,%password-lock-file))
                         ;; Specifc to Guix system.
                         ((#:path . "/etc/mtab")
                          (#:preds . ((#:symlink-to "/proc/self/mounts"))))
                         ((#:path . "/etc/ssl")
                          (#:preds . ((#:symlink-to "/run/current-system/profile/etc/ssl"))))
                         ((#:path . "/etc/static")
                          (#:preds . ((#:symlink-to-store))))))
             (operating-system-user-services os))))

    (sudo-lectures $)))
#+end_src
****** Sudo lectures
#+begin_src scheme
(define-system-comp (sudo-lectures #:key lectures?)
  (services
   (append
    (operating-system-user-services os)
    (if lectures?
        (list
         (stateless-service
          'sudo-lectures
          #:state '(((#:path . "/var/db/sudo/lectured/")
                     (#:storage . #:machine)))))
        '())))
  (sudoers-file
   (if (not lectures?)
       (mixed-text-file
        "sudoers"
        (slurp-file-like %sudoers-specification)
        "Defaults lecture=never" "\n")
       %sudoers-specification)))
#+end_src
*** Hardware-specific
**** Bootloaders
***** Grub
#+begin_src scheme
;; ...
#+end_src
***** Grub EFI
#+begin_src scheme
(define-system-comp (grub-efi #:key
                              label
                              target
                              stateless?)
  (bootloader (bootloader-configuration
               (bootloader grub-efi-bootloader)
               (targets (list target))))
  (file-systems
   (cons* (file-system
            (device (file-system-label label))
            (mount-point target)
            (type "vfat"))
          (operating-system-file-systems os)))
  (services
   (append
    (operating-system-user-services os)
    (if stateless?
        (list
         (let ((grub-dir "/boot/grub"))
           (match (grub-efi-format+file-name)
             ((format . file-name)
              ;; I could be more exhaustive here if I wanted: locales and modles are in the GRUB package so I could map over them and add ignore entries for each. Unforunately there isn't an easy way to get the built grub.cfg contents for comparison.
              (stateless-service
               'grub-efi
               #:ignore `(((#:path . ,(string-append target "/EFI/Guix/" file-name)))
                          ((#:path . ,(string-append grub-dir "/" format "/")))
                          ((#:path . ,(string-append grub-dir "/locale/")))
                          ((#:path . ,(string-append grub-dir "/fonts/unicode.pf2")))
                          ((#:path . ,(string-append grub-dir "/grub.cfg")))
                          ((#:path . ,(string-append grub-dir "/grubenv"))
                           (#:preds . ((#:file-content ,grubenv))))))))))
        '()))))

(define* (grub-efi-format+file-name #:key removable?)
  (match (assoc-ref '(("x86_64" . ("x86_64-efi" . "x64"))
                      ;; ...
                      )
                    (-> %host-type ; Not sure this is the right way to do this. Will it fail under cross-compilation? What is `%current-(target-)system' in Guix code all about?
                        (string-split #\-)
                        first))
    ((format . base-name)
     (cons format
           (string-append (if removable? "boot" "grub")
                          base-name
                          ".efi")))))

(define (repeat n x)
  (map (lambda _ x) (iota n)))

(define grubenv
  (let* ((package "grub")
         (message (string-append "# GRUB Environment Block" "\n"
                                 "# WARNING: Do not edit this file by tools other than " package "-editenv!!!" "\n"))
         (envblk-size 1024)
         (padding-size (- envblk-size (string-length message))))
    (string-append message
                   (apply string-append (repeat padding-size "#")))))

(define %efi-label "genesis")
(define %efi-boot-target "/boot/efi")
#+end_src
***** U-Boot
#+begin_src scheme
;; ...
#+end_src
**** Linux
#+begin_src scheme
(define-system-comp (linux-kernel #:key
                                  system
                                  nonfree?
                                  linux-customization-params)
  (kernel (let ((kernel (get-linux system nonfree?)))
            (if linux-customization-params
                (apply customize-linux
                       #:linux kernel
                       linux-customization-params)
                kernel)))
  (initrd (if (and nonfree?
                   (member system '("x86_64-linux" "i686-linux")))
              microcode-initrd
              base-initrd))
  (firmware
   (append
    (if nonfree?
        (list linux-firmware) '())
    (operating-system-firmware os))))

(define (get-linux system nonfree?)
  (as-> system $
        (or (assoc-ref `(;; ("aarch64-linux" . (,linux-libre-arm64-generic . ,linux-arm64-generic))
                         ;; ...
                         )
                       $)
            `(,linux-libre . ,linux))
        (match $
          ((libre . nonfree)
           (if nonfree?
               nonfree libre)))))
#+end_src
**** Console
***** Console keyboard layouts
Must succeed [[*Bootloader][Bootloader]] component.
#+begin_src scheme
(define-system-comp (console-keyboard-layouts #:key kb-layout)
  (keyboard-layout kb-layout)
  (bootloader (bootloader-configuration
               (inherit (operating-system-bootloader os))
               (keyboard-layout kb-layout))))
#+end_src
**** Virtualization
Must succeed [[*Accounts][Accounts]] component.
#+begin_src scheme
(define-system-comp (virtualization #:key
                                    kvm-support?
                                    kvm-users
                                    native-platform
                                    binfmt-platforms)
  (users
   (if (and kvm-support? kvm-users)
       (accounts-with-groups (operating-system-users os) kvm-users '("kvm"))
       (operating-system-users os)))
  (services
   (let ((platforms (remove (lambda (p)
                              (equal? p native-platform))
                            (or binfmt-platforms '()))))
     (if (not (null? platforms))
         (cons* (service qemu-binfmt-service-type
                         (qemu-binfmt-configuration
                          (platforms (apply lookup-qemu-platforms platforms))))
                (operating-system-user-services os))
         (operating-system-user-services os)))))
#+end_src
**** Apple
#+begin_src scheme
(define* (apple-macbook os #:key bluetooth?)
  (-> os
      (apple-broadcom-wireless #:bluetooth? bluetooth?)
      apple-facetime-camera
      apple-macbook-power-key))

(define %macbook-kb-layout
  (keyboard-layout "us" #:model "macbook78"))
#+end_src
***** Wireless
I'm not sure if this requires the nonfree linux kernel and/or if the blacklist refers to kernel modules not present in =linux-libre=.
#+begin_src scheme
(define-system-comp (apple-broadcom-wireless #:key bluetooth?)
  (kernel-loadable-modules (cons* broadcom-sta
                                  (operating-system-kernel-loadable-modules os)))
  (kernel-arguments (with-blacklist (operating-system-user-kernel-arguments os)
                                    "b43,b43legacy,ssb,bcm43xx,brcm80211,brcmfmac,brcmsmac,bcma"))
  (firmware (append
             (operating-system-firmware os)
             (if bluetooth?
                 (list broadcom-bt-firmware) '()))))
#+end_src
****** Broadcom STA :package:version:upstream:
#+begin_src scheme :tangle (meta-in-dir "packages/linux.scm")
(define-module (phrenetic packages linux)
  #:use-module (guix download)
  #:use-module (guix packages)
  #:use-module ((nongnu packages linux) #:select (broadcom-sta) #:prefix linux:)
  #:use-module (phrenetic utils))

(define (with-patch-updates broadcom-sta)
  (package
    (inherit broadcom-sta)
    (source
     (origin
       (inherit (package-source broadcom-sta))
       (patches
        (append
         (-> broadcom-sta package-source origin-patches)
         (list
          (patch "linux-5.17" "94cb803fab0cbab18a57488f4ec39cfe038c734a" "1qsllvykhs3nvjwv8d6bgsm2sc9a1lxf8yqf6fa99p60ggd253ps")
          (patch "linux-5.18" "94cb803fab0cbab18a57488f4ec39cfe038c734a" "1img0a0vqnkmq4c21aywq2ajyigzcfhbbpg1hw9nx7cbj9hf6d0l")
          (patch "linux-6.0" "105e8974c06bf299974d17c09c54800350cfdebe" "0rv74j5giafzl19f01yvfa5rgvsdvcimxzhks2fp44wpnxq241nb")
          (patch "linux-6.1" "355042e2ff5933b245e804c5eaff4ec3f340e71b" "1pvx1h7iimcbfqdc13n1980ngxk9q6iyip8svn293x4h7jn472kf")
          (patch "pedantic-fix" "105e8974c06bf299974d17c09c54800350cfdebe" "1kxmw1iyxnfwad75h981sak5qk16p81xy1f2qxss2d0v97vkfkl5"))))))))

(define (patch name commit hash)
  (origin
    (method url-fetch)
    (uri (string-append "https://raw.githubusercontent.com/NixOS/nixpkgs/"
                        commit
                        "/pkgs/os-specific/linux/broadcom-sta/"
                        name
                        ".patch"))
    (sha256
     (base32
      hash))))

(define-public broadcom-sta
  (with-patch-updates linux:broadcom-sta))
#+end_src
***** Camera :upstream:
Colors could probably be improved by adding sensor calibration files, as described on the wiki: [[https://github.com/patjak/facetimehd/wiki/Extracting-the-sensor-calibration-files][Extracting the sensor calibration files · patjak/facetimehd Wiki · GitHub]]
Adapt the Nix module like I did for the kernel module and firmware:
- [[https://github.com/NixOS/nixpkgs/blob/master/nixos/modules/hardware/video/webcam/facetimehd.nix][nixpkgs/facetimehd.nix at master · NixOS/nixpkgs · GitHub]]
- [[https://github.com/NixOS/nixpkgs/blob/master/pkgs/os-specific/linux/firmware/facetimehd-calibration/default.nix][nixpkgs/default.nix at master · NixOS/nixpkgs · GitHub]]
#+begin_src scheme
(define-system-comp (apple-facetime-camera)
  (kernel-loadable-modules (cons* facetimehd
                                  (operating-system-kernel-loadable-modules os)))
  (kernel-arguments (with-blacklist (operating-system-user-kernel-arguments os)
                                    "bdc_pci"))
  (firmware (cons* facetimehd-firmware
                   (operating-system-firmware os)))
  (services
   (cons* (simple-service 'facetimehd
                          kernel-module-loader-service-type
                          '("facetimehd"))
          (operating-system-user-services os))))
#+end_src
****** Linux module :package:version:
#+begin_src scheme :tangle (meta-in-dir "packages/facetimehd.scm")
(define-module (phrenetic packages facetimehd)
  #:use-module (guix build-system linux-module)
  #:use-module (guix git-download)
  #:use-module (guix packages)
  #:use-module ((guix licenses) #:prefix license:))

(define-public facetimehd
  (package
    (name "facetimehd")
    (version "0.5.18")
    (source
     (origin
       (method git-fetch)
       (uri (git-reference
             (url "https://github.com/patjak/facetimehd")
             (commit version)))
       (sha256
        (base32
         "1598pzjnbij3knvqmk2yslj26wmqiqjqgqgcw9p9jx6z7bdjvvsh"))))
    (build-system linux-module-build-system)
    (arguments
     '(#:tests? #f))
    (synopsis "Linux driver for the FacetimeHD (Broadcom 1570) PCIe webcam")
    (description synopsis)
    (home-page "https://github.com/patjak/facetimehd")
    (license license:gpl2)
    (supported-systems '("i686-linux" "x86_64-linux"))))
#+end_src
****** Firmware :package:version:
This is very messy, I naively ported the package from Nix. Ideally I'd rewrite it to not use ~curl~ (copy out the byte range with ~dd~ or guile / guix utils), not rely on ~system~ and use it for things like piping and appending command output (perhaps with guile's ~pipe~ / ~pipeline~ / ~redirect-port~), etc.
#+begin_src scheme :tangle (meta-in-dir "packages/facetimehd-firmware.scm")
(define-module (phrenetic packages facetimehd-firmware)
  #:use-module (guix build-system trivial)
  #:use-module (guix gexp)
  #:use-module (guix download)
  #:use-module (guix packages)
  #:use-module ((gnu packages base) #:select (coreutils))
  #:use-module ((gnu packages compression) #:select (gzip xz))
  #:use-module ((gnu packages cpio) #:select (cpio))
  #:use-module ((gnu packages curl) #:select (curl))
  #:use-module ((nonguix licenses) #:prefix license:))

(define-public facetimehd-firmware
  (package
    (name "facetimehd-firmware")
    (version "1.43")
    (source
     (origin
       (method url-fetch)
       (uri "https://updates.cdn-apple.com/2019/cert/041-88431-20191011-e7ee7d98-2878-4cd9-bc0a-d98b3a1e24b1/OSXUpd10.11.5.dmg")
       (sha256
        (base32
         "009kfk1nrrialgp69c5smzgbmd5xpvk35xmqr2fzb15h6pp33ka6"))))
    (build-system trivial-build-system)
    (arguments
     `(#:builder
       ,(with-imported-modules '((guix build utils))
          #~(begin
              (use-modules ((guix build utils) #:select (invoke mkdir-p search-input-file)))

              (define (exe name)
                (search-input-file %build-inputs (string-append "/bin/" name)))

              (let ((source "source")
                    (firmware-in "./System/Library/Extensions/AppleCameraInterface.kext/Contents/MacOS/AppleCameraInterface")
                    (firmware-out "firmware.bin"))
                (let ((offset 204909802)
                      (size 207733123))
                  (invoke (exe "curl")
                          "--range" (string-append
                                     (number->string offset) "-" (number->string size))
                          "--output" source
                          (string-append "file://" #$source)))
                (system
                 (string-join
                  (list (exe "xz") "--decompress" "--stdout" source
                        "|"
                        (exe "cpio") "--format=odc" "--extract" "--make-directories" firmware-in)))
                (let ((offset 81920)
                      (size 603715))
                  (invoke (exe "dd")
                          (string-append "if=" firmware-in)
                          (string-append "of=" firmware-out ".gz")
                          (string-append "skip=" (number->string offset))
                          (string-append "count=" (number->string size))
                          "bs=1"))
                (let ((firmware-dir (string-append #$output "/lib/firmware/facetimehd")))
                  (mkdir-p firmware-dir)
                  (system
                   (string-join
                    (list (exe "gunzip") "--stdout" (string-append firmware-out ".gz")
                          ">"
                          (string-append firmware-dir "/" firmware-out))))))))))
    (native-inputs
     (list coreutils
           cpio
           curl
           gzip
           xz))
    (synopsis "FacetimeHD firmware")
    (description synopsis)
    (home-page "https://github.com/patjak/facetimehd-firmware")
    (license (license:nonfree "https://www.apple.com/legal"))
    (supported-systems '("i686-linux" "x86_64-linux"))))
#+end_src
***** Macbook power key
Make the power key suspend instead of power off. It's part of the keyboard on MacBooks and too easy to press by accident. This is also the behavior on macOS.
#+begin_src scheme
(define-system-comp (apple-macbook-power-key)
  (services
   (modify-services (operating-system-user-services os)
     (elogind-service-type
      config =>
      (elogind-configuration
       (inherit config)
       (handle-power-key 'suspend))))))
#+end_src
***** Shared
#+begin_src scheme
(define (with-blacklist kernel-args new-kernel-args)
  (let* ((blacklist-param "modprobe.blacklist")
         (blacklist? (lambda (arg)
                       (string-prefix? blacklist-param arg))))
    (if (any blacklist? kernel-args)
        (map (lambda (arg)
               (if (blacklist? arg)
                   (string-append arg "," new-kernel-args)
                   arg))
             kernel-args)
        (cons* (string-append blacklist-param "=" new-kernel-args) kernel-args))))
#+end_src
*** Shared
#+begin_src scheme
(define (remove-services services kinds)
  (remove (lambda (s)
            (member (service-kind s) kinds))
          services))

(define (accounts-with-groups accounts users groups)
  (map (lambda (account)
         (if (member (user-account-name account) users)
             (user-account
              (inherit account)
              (supplementary-groups (-> (user-account-supplementary-groups account)
                                        (append groups)
                                        delete-duplicates)))
             account))
       accounts))
#+end_src
** Composite components
*** Base
#+begin_src scheme
(define* (os-base os
                  #:key
                  source?
                  source-path
                  users-info
                  guix?
                  nix?
                  console?
                  kmonad?
                  kmonad-users
                  desktop?
                  pipewire?
                  connection-manager
                  bluetooth?
                  bluetooth-users
                  login-manager
                  auto-login?
                  auto-login-user
                  sessions
                  stateless?
                  stateless-machine-dir)
  (let ((number-of-ttys 6)
        (greetd? #t))
    (as-> os $
      (if source?
          (source $ #:path source-path) $)
      (base-services $ #:stateless? stateless?)
      (if greetd?
          (greetd-login $ #:number-of-ttys number-of-ttys)
          (classic-login $ #:number-of-ttys number-of-ttys))
      (certs $)
      (accounts $ #:users-info users-info)
      (if guix?
          (guix-pm $ #:stateless? stateless?) $)
      (if nix?
          (nix-pm $ #:stateless? stateless?
                  #:stateless-machine-dir stateless-machine-dir)
          $)
      (if console?
          (as-> $ $
            (console-fonts $ #:number-of-ttys number-of-ttys)
            (if kmonad?
                (kmonad-tool $ #:who kmonad-users) $))
          $)
      (if desktop?
          (as-> $ $
            (desktop-base-services $ #:stateless? stateless?)
            (if pipewire?
                (pipewire-multimedia $)
                (classic-sound $))
            (case connection-manager
              ((#:cm/network-manager) (network-manager $ #:stateless? stateless?)))
            (if bluetooth?
                (bluetooth $ #:who bluetooth-users
                           #:stateless? stateless?)
                $)
            (if login-manager
                (case login-manager
                  ((#:lm/gdm) (gdm $ #:auto-login? auto-login?
                                   #:auto-login-user auto-login-user
                                   #:stateless? stateless?)))
                (desktop-tty $ #:greetd? greetd?
                             #:auto-login? auto-login?
                             #:auto-login-user auto-login-user))
            (if (member #:session/gnome (or sessions '()))
                (gnome-desktop $) $)
            (if (member #:session/sway (or sessions '()))
                (sway-wm $) $))
          $))))
#+end_src
*** Macbook hardware
#+begin_src scheme
(define* (with-macbook-hardware os
                                #:key
                                boot-target
                                efi-label
                                bluetooth?
                                virtualization-kvm-users
                                virtualization-binfmt-platforms
                                stateless?)
  (as-> os $
    (grub-efi $ #:label efi-label
              #:target boot-target
              #:stateless? stateless?)
    (linux-kernel $ #:system "x86_64-linux"
                  #:nonfree? #t)
    (console-keyboard-layouts $ #:kb-layout %macbook-kb-layout)
    (virtualization $ #:kvm-support? #t
                    #:kvm-users virtualization-kvm-users
                    #:native-platform "x86_64"
                    #:binfmt-platforms virtualization-binfmt-platforms)
    (apple-macbook $ #:bluetooth? bluetooth?)))
#+end_src
* Home
:PROPERTIES:
:meta-dir+: /phrenetic
:header-args+: :tangle (meta-in-dir "home.scm")
:END:
#+begin_src scheme
(define-module (phrenetic home)
  #:use-module (guix gexp)
  #:use-module ((guix modules) #:select (source-module-closure))
  #:use-module (guix packages)
  #:use-module (gnu home)
  #:use-module (gnu home services)
  #:use-module (gnu home services desktop)
  ;; #:use-module (gnu home services guix)
  #:use-module (gnu home services shells)
  #:use-module (gnu home services shepherd)
  #:use-module (gnu home services ssh)
  #:use-module (gnu home services xdg)
  #:use-module (gnu home-services terminals)
  #:use-module (gnu home-services version-control)
  #:use-module ((gnu packages browser-extensions) #:select (ublock-origin/chromium))
  #:use-module ((gnu packages chromium) #:select (ungoogled-chromium))
  #:use-module ((gnu packages compression) #:select (zip unzip zstd))
  #:use-module ((gnu packages curl) #:select (curl))
  #:use-module ((gnu packages fonts) #:select (font-google-noto font-iosevka-etoile font-liberation font-awesome))
  #:use-module ((gnu packages freedesktop) #:select (elogind udiskie xdg-utils xdg-user-dirs desktop-file-utils xdg-desktop-portal xdg-desktop-portal-gtk xdg-desktop-portal-wlr))
  #:use-module ((gnu packages gimp) #:select (gimp))
  #:use-module ((gnu packages glib) #:select (dbus))
  #:use-module ((gnu packages gnome) #:select (adwaita-icon-theme dconf gnome gnome-session gnome-themes-extra hicolor-icon-theme (network-manager-applet . gnome:network-manager-applet)))
  #:use-module ((gnu packages gnome-xyz) #:select (arc-theme papirus-icon-theme))
  #:use-module ((gnu packages image) #:select (grim slurp swappy))
  #:use-module ((gnu packages java) #:select (openjdk17))
  #:use-module ((gnu packages linux) #:select (brightnessctl psmisc pipewire wireplumber))
  #:use-module ((gnu packages music) #:select (playerctl))
  #:use-module ((gnu packages node) #:select ((node-lts . node)))
  #:use-module ((gnu packages package-management) #:select (flatpak))
  #:use-module ((gnu packages pulseaudio) #:select (pulseaudio pavucontrol))
  #:use-module ((gnu packages qt) #:select (qtwayland-5))
  #:use-module ((gnu packages rust-apps) #:select (swayhide))
  #:use-module ((gnu packages shells) #:select (zsh))
  #:use-module ((gnu packages shellutils) #:select (direnv))
  #:use-module ((gnu packages terminals) #:select (alacritty))
  #:use-module ((gnu packages version-control) #:select (git))
  #:use-module ((gnu packages video) #:select (vlc))
  #:use-module ((gnu packages virtualization) #:select (qemu))
  #:use-module ((gnu packages vpn) #:select (protonvpn-cli))
  #:use-module ((gnu packages web) #:select (jq))
  #:use-module ((gnu packages web-browsers) #:select (nyxt))
  #:use-module ((gnu packages wm) #:select (mako swayidle swaylock-effects waybar waybar-cpu-histogram))
  #:use-module ((gnu packages xdisorg) #:select (gammastep rofi rofi-wayland wl-clipboard))
  #:use-module (gnu services)
  #:use-module ((gnu services configuration) #:select (interpose))
  #:use-module (gnu services shepherd)
  #:use-module (gnu system keyboard)
  #:use-module ((gnu system shadow) #:select (default-skeletons))
  #:use-module ((nongnu packages chrome) #:select (google-chrome-stable))
  #:use-module ((nongnu packages clojure) #:select (clj-kondo))
  #:use-module ((nongnu packages messaging) #:select (zoom))
  #:use-module ((nongnu packages mozilla) #:select (firefox firefox/wayland))
  #:use-module (rde home services wm)
  #:use-module (rde home services xdisorg)
  #:use-module ((rde packages) #:select ((sway-latest . sway)))
  #:use-module ((rde packages fonts) #:select (font-noto-color-emoji))
  #:use-module ((rde serializers elisp) #:select (elisp-serialize))
  #:use-module ((rde serializers ini) #:select (ini-serialize))
  #:use-module ((chromium chromium) #:select (chromium+drm))
  #:use-module ((phrenetic packages aws) #:select (awscli-2))
  #:use-module ((phrenetic packages clojure) #:select (clojure-tools))
  #:use-module ((phrenetic packages datomic) #:select (datomic-cli-tools))
  #:use-module ((phrenetic packages doom-emacs) #:select (doom-emacs))
  #:use-module ((phrenetic packages emacs) #:select (emacs-pgtk))
  #:use-module ((phrenetic packages fonts) #:select (font-adobe-source-code-pro font-adobe-source-sans))
  #:use-module ((phrenetic packages haskell-apps) #:select (kmonad))
  #:use-module ((phrenetic stateless) #:prefix stateless:)
  #:use-module (phrenetic utils)
  #:use-module ((ice-9 match) #:select (match-lambda match-let))
  #:use-module ((srfi srfi-1) #:select (append-map concatenate delete-duplicates list-index remove))
  #:export (create-he
            stateless
            shells
            emacs
            %emacs-package
            emacs-editor
            emacs-new-frame
            doom
            doom-service
            doom-web
            guix-pm
            nix-pm
            virtualization
            kmonad-tool
            pipewire-multimedia
            %light-colors
            %dark-colors
            %wallpapers
            font-library
            %fonts
            %font-packages-misc
            %date-format
            %time-format
            xdg
            mesa
            doom-desktop
            dbus-ipc
            gdm
            desktop-tty
            gnome-desktop
            gnome-start
            sway-wm
            sway-start
            swaylock-wm-piece
            swaylock-screen-locker
            swayidle-wm-piece
            swayidle-idle-manager
            mako-wm-piece
            mako-notifier
            waybar-wm-piece
            waybar-status-bar
            waybar-modules
            kanshi-wm-piece
            network-manager-wm-applet
            network-manager-applet
            gammastep-wm-applet
            gammastep-applet
            udiskie-wm-applet
            udiskie-applet
            aws-prog
            clojure-prog
            datomic-prog
            doom-calendar-prog
            doom-org-prog
            direnv-prog
            direnv-service-type
            node-prog
            protonvpn-prog
            ssh-prog
            doom-dired-prog
            ;; nano-prog
            doom-trash-prog
            git-prog
            misc-progs
            pavucontrol-app
            doom-menu-app
            doom-menu
            rofi-app
            rofi-menu
            zoom-app
            gimp-app
            alacritty-app
            alacritty-terminal
            doom-vterm-app
            doom-vterm-terminal
            chromium-app
            firefox-app
            nyxt-app
            tor-browser-app
            vlc-app
            flatpak-apps
            work
            services-only-packages
            services-sans-packages
            os-features
            sway-environment
            programs
            applications
            he-base))

;; TODO Remove once this is the default in RDE.
(use-modules (guix transformations))
(define transform-sway
  (options->transformation
   '((with-commit . "sway=1.8"))))
(define sway (transform-sway (@ (rde packages) sway-latest)))
#+end_src
** Create
#+begin_src scheme
(define (create-he services)
  (home-environment
   (services
    (filter service? services))))
#+end_src
** Components
*** Stateless
- TODO probably move this to above "Virtualization" (to keep things in the same order in Home as in System)
#+begin_src scheme
(define* (stateless #:key storage-paths)
  (append
   (list
    (service home-stateless-service-type
             `(#:storage-paths ,storage-paths)))))
#+end_src
**** Service
***** Service type
#+begin_src scheme
(define home-stateless-service-type
  (service-type
   (name 'home-stateless)
   (extensions
    (list (service-extension home-activation-service-type
                             (lambda (config)
                               (with-imported-modules '((guix build utils) (phrenetic build utils) (phrenetic build stateless))
                                 ;; (source-module-closure
                                 ;;  '((phrenetic build stateless))
                                 ;;  #:select? (const #t)
                                 ;;  ;; #:select? (lambda (name)
                                 ;;  ;;             (or ((@ (guix modules) guix-module-name?) name)
                                 ;;  ;;                 (eq? (car name) 'phrenetic)))
                                 ;;  )
                                 #~(begin
                                     (use-modules ((phrenetic build stateless) #:select (activate)))
                                     (activate (#$state-with-home-expansions '#$(assoc-ref config #:state))
                                               #$homedir-gexp
                                               '#$(assoc-ref config #:storage-paths))))))
          ;; (service-extension home-profile-service-type
          ;;                    (lambda (config)
          ;;                      (list (stateless:tool-package
          ;;                             "home-stateless"
          ;;                             (state-with-home-expansions (assoc-ref config #:state))
          ;;                             (ignore-with-home-expansions (assoc-ref config #:ignore))
          ;;                             homedir-gexp
          ;;                             (assoc-ref config #:storage-paths)
          ;;                             #:additional-known
          ;;                             guix-home-files))))
          ))
   (compose identity)
   (extend (lambda (config exts)
             (stateless:extend-proc
              config
              (cons '((#:ignore . (((#:path . ".guix-home")
                                    (#:preds . ((#:symlink-to-store)))))))
                    exts))))
   (description "Initialize a stateless home.")))

(define homedir-gexp #~(getenv "HOME"))

(define path-with-home-expansion
  #~(lambda (path)
      (cond
       ((string? path) (string-append (getenv "HOME") "/" path))
       ((list? path)
        (apply
         (lambda* (#:optional tail #:key xdg-base)
           (string-append (getenv xdg-base) "/" (or tail "")))
         path)))))

(define state-with-home-expansions
  #~(lambda (state)
      (map (lambda (i)
             (acons #:path (#$path-with-home-expansion (assoc-ref i #:path)) i))
           state)))

(define ignore-with-home-expansions
  #~(lambda (ignore)
      (map #$path-with-home-expansion ignore)))
#+end_src
****** Tool
#+begin_src scheme
(define guix-home-files
  (with-imported-modules '((guix build utils))
    #~(begin
        (use-modules ((guix build utils) #:select (find-files)))

        (let ((home-files
               (let* ((home-dir (getenv "HOME"))
                      (guix-home-dir (string-append
                                      home-dir "/.guix-home/" #$home-files-directory "/"))) ; TODO maybe do a `readlink' here instead of appending a slash, for clarity.
                 (map (lambda (file)
                        (string-append
                         home-dir
                         (string-drop file (string-length guix-home-dir))))
                      (find-files guix-home-dir)))))
          (make-known home-files symlink-to-store?)))))

;; (define (make-known files pred)
;;   (map (lambda (file)
;;          (cons file pred))
;;        files))

;; (define (symlink-to-store? file)
;;   (and (symbolic-link? file)
;;        (store-file-name? (readlink file))))
#+end_src
***** Extension helper
#+begin_src scheme
(define home-stateless-service
  (stateless:service-fn home-stateless-service-type))
#+end_src
*** Shells
#+begin_src scheme
(define* (shells #:key
                 stateless?
                 doom?
                 doom-tree-sitter?
                 login-shell
                 interactive-shells
                 (bashrc (local-file "bashrc"))
                 (zshrc (local-file "zshrc")))
  (append
   (append-map
    (lambda (shell)
      (case shell
        ((#:shell/bash)
         (list
          (service home-bash-service-type
                   (home-bash-configuration
                    (bashrc
                     (list bashrc))))
          (when stateless?
            (home-stateless-service
             'bash
             #:state '(((#:path . ("bash/" #:xdg-base "XDG_STATE_HOME"))
                        (#:storage . #:persist)))))))
        ((#:shell/zsh)
         (list
          (service home-zsh-service-type
                   (home-zsh-configuration
                    (zshrc
                     (list zshrc))))
          (when stateless?
            (home-stateless-service
             'zsh
             #:state '(((#:path . ("zsh/" #:xdg-base "XDG_STATE_HOME"))
                        (#:storage . #:persist))
                       ((#:path . ("zsh/" #:xdg-base "XDG_CACHE_HOME"))
                        (#:storage . #:machine)))))))))
    (cons login-shell interactive-shells))

   (list
    (let ((name 'shells-setup-login-shell)
          (shepherd-stop-cmd
           (let ((shepherd (home-shepherd-configuration-shepherd (home-shepherd-configuration))))
             (mixed-text-file
              "shepherd-stop"
              (file-append shepherd "/bin/herd") " stop root"))))
      (case login-shell
        ((#:shell/bash)
         (simple-service name
                         home-bash-service-type
                         (home-bash-extension
                          (bash-logout
                           (list shepherd-stop-cmd)))))
        ;; ((#:shell/zsh)
        ;;  (simple-service name
        ;;                  home-zsh-service-type
        ;;                  (home-zsh-extension
        ;;                   (zlogout
        ;;                    (list shepherd-stop-cmd)))))
        ))

    (match-let (((default-interactive-shell _ ...) interactive-shells))
      (when-not (equal? login-shell default-interactive-shell)
                (simple-service
                 'shells-set-shell-env-var
                 home-environment-variables-service-type
                 `(("SHELL" . ,(case default-interactive-shell
                                 ;; ((#:shell/bash) (file-append bash "/bin/bash"))
                                 ((#:shell/zsh) (file-append zsh "/bin/zsh")))))))))

   (if doom?
       (doom-shells #:stateless? stateless?
                    #:tree-sitter? doom-tree-sitter?)
       '())))
#+end_src
**** Bash
***** Bashrc
#+begin_src sh :tangle (meta-in-dir "bashrc")
HISTFILE=${XDG_STATE_HOME:-$HOME/.local/var/lib}/bash/.bash_history
#+end_src
**** Zsh
***** Zshrc
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "zshrc")
:END:
****** Andrew Tropin's zshrc
- TODO trying out Andrew Tropin's zsh configuration verbatim for now. Should I also try out vanilla zshell?
#+begin_src sh
# Prevent freezing output on ^s, needed for various isearches
hash stty 2> /dev/null && stty -ixon

# Completions and other stuff
autoload -U compinit
compinit -d ${XDG_CACHE_HOME:-$HOME/.cache}/zsh/.zcompdump

# Enable bash completion, requires to source them from somewhere
# autoload -U bashcompinit && bashcompinit

zstyle ':completion:*' menu select
zstyle ':completion:*' insert-tab false

# Automatically update cache of binaries avaliable in $PATH
zstyle ':completion:*' rehash true # Can have a performance penalty

# Approximate completion
# zstyle ':completion:::::' completer _complete _approximate
# zstyle ':completion:*:approximate:*' max-errors 2

# Fuzzy completion
# https://superuser.com/questions/415650/does-a-fuzzy-matching-mode-exist-for-the-zsh-shell
zstyle ':completion:*' matcher-list '' \
  'm:{a-z\-}={A-Z\_}' \
  'r:[^[:alpha:]]||[[:alpha:]]=** r:|=* m:{a-z\-}={A-Z\_}' \
  'r:|?=** m:{a-z\-}={A-Z\_}'

# Make kill completion smart
zstyle ':completion:*:*:*:*:processes' command "ps -u $USER -o pid,user,args -w -w"

# Colored completion for files and dirs according to LS_COLORS

hash dircolors 2> /dev/null && eval $(dircolors --sh) && \
zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}

# Prompt theme setup
clear_fn() {
#  zle reset-prompt
  zle kill-buffer
}

prompt_rde_precmd() {
  # Prevent killing prompt on ^C
  trap 'clear_fn' SIGINT
}

prompt_rde_setup() {
  if [[ $UID -eq 0 ]]; then
    user_part='%F{red}>%f'
  else
    user_part='%F{green}>%f'
  fi
  if [ -n "$GUIX_ENVIRONMENT" ]; then
    genv_part='%F{blue}>%f'
  fi
  # exit_code_part='%(?..[%?])'

  PS1="$user_part$genv_part "
  # RPS1="$exit_code_part"

  # Fish-like C-c behavior
  # add-zsh-hook precmd prompt_rde_precmd
}

# Load promptinit and set rde theme
autoload -Uz promptinit && promptinit
prompt_themes+=( rde )
prompt rde

setopt printexitvalue # Instead of using RPS1 for status code

echo -en "\033[6 q" # Make a cursor to be a vertical bar

# Remove slashes and dashes from wordchars to make M-b, M-f work
# correctly
WORDCHARS=""

# Configure history
# HISTSIZE=5000
# SAVEHIST=$HISTSIZE
HISTFILE=${XDG_STATE_HOME:-$HOME/.local/var/lib}/zsh/.zhistory

#setopt incappendhistory # Save history to shared file, but not read
setopt sharehistory     # Share history across shell sessions
setopt histignorespace  # Ignore commands that start with space

# Configuring help (M-h to call it on current command/function)
autoload -Uz run-help
(( ${+aliases[run-help]} )) && unalias run-help
autoload -Uz run-help-git

# Delete, home, end buttons
bindkey  "^[[3~"  delete-char
bindkey  "^[[H"   beginning-of-line
bindkey  "^[[F"   end-of-line

# Launch $VISUAL or $EDITOR, for emacsclient if there is no server
# avaliable $ALTERNATE_EDITOR will be used.
autoload -z edit-command-line
zle -N edit-command-line
bindkey "^X^E" edit-command-line

alias help=run-help
alias try='guix shell man-db coreutils'
alias ls='ls -p --color=auto'
alias ll='ls -l'
alias grep='grep --color=auto'
#+end_src
****** History
- TODO use ~very-big-history~
#+begin_src sh
HISTSIZE=1000000
SAVEHIST=$HISTSIZE
#+end_src
**** Doom shells
#+begin_src scheme
(define* (doom-shells #:key
                      stateless?
                      tree-sitter?)
  (append
   (doom-ts-lang 'sh #:tree-sitter? tree-sitter?)
   (doom-eshell #:stateless? stateless?)))
#+end_src
***** Doom eshell
#+begin_src scheme
(define* (doom-eshell #:key stateless?)
  (let ((name 'eshell))
    (list
     (doom-service
      name
      #:modules '((#:term
                   eshell))
      #:config `((after! eshell
                         (setq eshell-history-size ,very-big-history)))) ; Setting this to `nil' to inherit envvar HISTSIZE is another option.

     (when stateless?
       (doom-stateless-service
        name
        #:state '(((#:path . ("eshell/history" #:doom-base #:data))
                   (#:storage . #:persist))
                  ((#:path . ("eshell/lastdir" #:doom-base #:data))
                   (#:storage . #:persist))
                  ((#:path . ("eshell/z" #:doom-base #:data))
                   (#:storage . #:persist))))))))
#+end_src
*** Emacs
#+begin_src scheme
(define* (emacs #:key emacs)
  (list
   (simple-service
    'emacs-add-packages
    home-profile-service-type
    (list emacs))

   (simple-service
    'emacs-set-editor-env-vars
    home-environment-variables-service-type
    `(("VISUAL" . ,(file-append emacs "/bin/emacsclient"))
      ("EDITOR" . "$VISUAL")))))

(define* (emacs-editor #:key emacs)
  `((#:emacs/program . ,(list
                         (file-append emacs "/bin/emacs")))
    (#:emacs/new-frame . ,(list
                           (file-append emacs "/bin/emacsclient")
                           "--create-frame"))
    (#:emacs/handler . ,(emacs-handler emacs))))

(define %emacs-package emacs-pgtk)
#+end_src
**** Handler
#+begin_src scheme
(define* (emacs-handler emacs)
  (lambda* (#:rest args)
    (apply emacs-handler* emacs args)))

(define* (emacs-handler* emacs
                         name
                         exprs
                         #:key
                         assistant?
                         assistant-title
                         minibuffer?
                         input?)
  (program-file
   (string-append "emacs-handler-" name)
   #~(begin
       (use-modules ((ice-9 popen) #:select (close-pipe open-pipe*))
                    ((ice-9 textual-ports) #:select (get-string-all put-string)))

       (let* ((args (cdr (command-line)))
              (input (if #$input?
                         (string-drop-right (get-string-all (current-input-port)) 1)
                         #f))
              (pipe (let ((cmd (list
                                #$(file-append emacs "/bin/emacsclient")
                                "--eval"
                                (#$serialize-eval-expr
                                 (#$(eval-expr exprs
                                               assistant?
                                               assistant-title
                                               minibuffer?)
                                    args input)))))
                      (apply open-pipe* OPEN_READ cmd))))
         (put-string (current-output-port)
                     (let* ((res* (get-string-all pipe))
                            (end (string-take-right res* 1)) ; EOF or newline or something? Donno if this matters, doing it just in case.
                            (res (string-trim-both (string-drop-right res* 1) #\"))) ; `emacsclient' output is a sexp so strings will have quotes around them. Work around just this particular case, for now it's the only one that matters (for the dmenu-like functionality).
                       (string-append res end)))
         (close-pipe pipe)))))

(define (eval-expr exprs assistant? assistant-title minibuffer?)
  #~(lambda (args input)
      `(with-selected-frame
        (make-frame '(,@(if #$assistant?
                            `((name . ,(string-append #$assistant-title " - Emacs Assistant"))
                              ;; (alpha-background . 90) ; Emacs 29 feature, add this in when it's released.
                              )
                            '())
                      ,@(if #$minibuffer?
                            '((minibuffer . only)) '())))
        (let ((args ',args)
              (input ,(or input 'nil)))
          ,@(if #$minibuffer?
                '((unwind-protect
                   (progn
                    #$@exprs)
                   (delete-frame)))
                '#$exprs)))))

(define serialize-eval-expr
  #~(lambda (expr)
      (call-with-output-string
        (lambda (port)
          (write expr port)))))

(define emacs-assistant-window-params
  '((#:width . 50)
    (#:height . 50)))
#+end_src
**** XDG service
#+begin_src scheme
(define* (emacs-xdg-service name
                            xdg-name
                            program
                            #:key
                            (exec-argument "%u")
                            default-for)
  (let ((file (symbol-append 'emacs- name)))
    (simple-service
     (symbol-append 'emacs-xdg- name)
     home-xdg-mime-applications-service-type
     (home-xdg-mime-applications-configuration
      (desktop-entries
       (list
        (xdg-desktop-entry
         (file (symbol->string file))
         (name (string-append "Emacs [" xdg-name "]"))
         (config `((exec . ,#~(string-append #$program " " #$exec-argument))
                   (icon . "emacs")))
         (type 'application))))
      (default (map (lambda (mime-type)
                      `(,mime-type . ,(symbol-append file '.desktop)))
                    (or default-for '())))))))
#+end_src
**** Emacs PGTK :package:version:
#+begin_src scheme :tangle (meta-in-dir "packages/emacs.scm")
(define-module (phrenetic packages emacs)
  #:use-module (guix packages)
  #:use-module ((gnu packages emacs) #:select (emacs emacs-next-pgtk))
  #:use-module (phrenetic utils))

(define-public emacs-pgtk
  (as-> emacs-next-pgtk $
    (with-git-url $ "https://github.com/flatwhatson/emacs")
    ;; TODO I get native-comp errors. Why?
    ;; (with-git-commit $ #:upstream-version "28.2.50"
    ;;                  #:commit "91394b03a1de09b5908a4fdfd9411feed8ec2c18"
    ;;                  #:hash "1v6xib9mpcdnnssbb06kj9pb4vbpzsppcq6lvdjd3rkcdzd221cw")
    (with-git-commit $ #:upstream-version "28.1.91"
                       #:commit "031a3a803b1658c2ea2ccda76d46a99dc810eec2"
                       #:hash "1vhycsbvmfzihk84xjkcm7psyhw0ir64p4vh0hfmhxvw1xy0sbqs")
    (package
      (inherit $)
      (source
       (origin
         (inherit (package-source $))
         (patches
          (-> emacs package-source origin-patches)))))))
#+end_src
*** Doom
#+begin_src scheme
(define* (doom #:key
               stateless?
               services)
  (append
   (list
    (service doom-service-type)

    (simple-service
     'doom-set-paths
     home-environment-variables-service-type
     (let ((doom-local "$XDG_STATE_HOME/doom"))
       `(("DOOMLOCALDIR" . ,doom-local)
         ("DOOMPROFILELOADFILE" . ,(string-append doom-local "/profile-load.el"))))))

   (or services '())

   (if stateless?
       (list
        (home-stateless-service
         'doom
         #:state '(((#:path . ("doom/straight/" #:xdg-base "XDG_STATE_HOME"))
                    (#:storage . #:machine))
                   ((#:path . ("doom/logs/" #:xdg-base "XDG_STATE_HOME"))
                    (#:storage . #:machine))
                   ((#:path . ("doom/profile-load.el" #:xdg-base "XDG_STATE_HOME"))
                    (#:storage . #:machine))
                   ((#:path . ("doom/profile-load.28.elc" #:xdg-base "XDG_STATE_HOME"))
                    (#:storage . #:machine))))
        (doom-stateless-service
         'doom
         #:state '(((#:path . ("eln/" #:doom-base #:cache))
                    (#:storage . #:machine))
                   ((#:path . ("profiles.@.el" #:doom-base #:cache))
                    (#:storage . #:machine))
                   ((#:path . ("@/" #:doom-base #:data))
                    (#:storage . #:machine)))))
       '())))
#+end_src
**** Service
***** Service type
#+begin_src scheme
(define doom-service-type
  (service-type
   (name 'home-doom)
   (extensions
    (list (service-extension home-profile-service-type
                             (const
                              (list `(,doom-emacs "bin"))))
          (service-extension home-xdg-configuration-files-service-type
                             (lambda (config)
                               `(("emacs" ,doom-emacs)
                                 ("doom" ,(doom-private config)))))))
   (compose identity)
   (extend (lambda (_ exts)
             (doom-extend exts)))
   (default-value #f)
   (description "Install and configure Doom.")))
#+end_src
****** Extend procedure
#+begin_src scheme
(define (doom-extend exts)
  (let ((field (lambda (k)
                 (map (lambda (i)
                        (or (assoc-ref i k) '()))
                      exts))))
    `((#:init-file . ,(init-file (field #:modules)))
      (#:config-file . ,(config-file (field #:config)))
      (#:packages-file . ,(packages-file (field #:packages)))
      (#:theme-files . ,(theme-files (field #:themes))))))

(define (init-file exts)
  (as-> exts $
    (map (lambda (i)
           (update-vals i (lambda (modules)
                            (map (lambda (m)
                                   (cond
                                    ((symbol? m) (list m))
                                    ((list? m) m)))
                                 modules))))
         $)
    (apply merge-with
           (lambda (ms ms*)
             (merge-with
              (lambda (flags flags*)
                (delete-duplicates (append flags flags*)))
              ms ms*))
           $)
    (sort $ (lambda (a b)
              (let ((idx (match-lambda
                           ((cat _ ...)
                            (list-index
                             (lambda (category)
                               (equal? cat category))
                             '(#:completion #:ui #:editor #:emacs #:term #:checkers #:tools #:lang #:app #:config))))))
                (< (idx a) (idx b)))))
    (update-vals $ (lambda (modules)
                     (let ((mod-name (match-lambda
                                       ((name _ ...)
                                        (symbol->string name)))))
                       (sort modules (lambda (a b)
                                       (string<? (mod-name a) (mod-name b)))))))
    (update-keys $ (lambda (category)
                     (symbol-append ': (keyword->symbol category))))
    (update-vals $ (lambda (modules)
                     (map (match-lambda
                            ((name) name)
                            (m m))
                          modules)))
    (apply append $)
    (elisp-serialize
     `(,#~";;; -*- lexical-binding: t; -*-"
          (doom! ,@$)))))

(define (config-file exts)
  (as-> exts $
    (delete-duplicates $)
    (apply append $)
    (elisp-serialize*
     (append
      `(,#~";;; -*- lexical-binding: t; -*-")
      $))))

(define (packages-file exts)
  (as-> exts $
    (delete-duplicates $)
    (apply append $)
    (elisp-serialize*
     (append
      `(,#~";; -*- no-byte-compile: t; -*-")
      $))))

(define (theme-files exts)
  (as-> exts $
    (apply append $)
    (map (match-lambda
           ((name defs extra-faces)
            (list name
                  (elisp-serialize*
                   `(,#~";;; -*- lexical-binding: t; no-byte-compile: t; -*-"
                     (require 'doom-themes)
                     (def-doom-theme ,name ,(symbol->string name) ,defs ,extra-faces))))))
         $)))

(define (elisp-serialize* exprs)
  #~(begin
      (use-modules ((ice-9 string-fun) #:select (string-replace-substring)))
      (string-replace-substring #$(elisp-serialize exprs) "(syntax " "(function ")))
#+end_src
****** Doom private
#+begin_src scheme
(define (doom-private config)
  (file-union
   "doom-private"
   (append
    (map (match-lambda
           ((name file)
            `(,(string-append name)
              ,(mixed-text-file (string-append "doom-" name) (assoc-ref config file)))))
         '(("init.el" #:init-file)
           ("config.el" #:config-file)
           ("packages.el" #:packages-file)))
    (map (match-lambda
           ((theme-name file)
            (let ((name (string-append (symbol->string theme-name) "-theme.el")))
              `(,(string-append "themes/" name)
                ,(mixed-text-file name file)))))
         (assoc-ref config #:theme-files)))))
#+end_src
***** Extension helpers
#+begin_src scheme
(define* (doom-service name
                       #:key
                       modules
                       packages
                       config
                       themes)
  (simple-service
   (symbol-append name '-doom)
   doom-service-type
   `((#:modules . ,modules)
     (#:packages . ,packages)
     (#:config . ,config)
     (#:themes . ,themes))))
#+end_src
****** Stateless
#+begin_src scheme
(define* (doom-stateless-service name #:key state ignore)
  (home-stateless-service
   (symbol-append name '-doom)
   #:state (state-with-doom-dir state)
   #:ignore ignore))

(define (state-with-doom-dir state)
  (map (lambda (i)
         (acons #:path (path-with-doom-dir (assoc-ref i #:path)) i))
       state))

(define (path-with-doom-dir path)
  (let ((doom-dir
         (lambda (base subpath)
           `(,(string-append
               "doom/"
               (case base
                 ((#:cache) "cache")
                 ((#:data) "etc"))
               "/" subpath)
             #:xdg-base "XDG_STATE_HOME"))))
    (apply (lambda* (tail #:key doom-base)
             (doom-dir doom-base tail))
           path)))
#+end_src
**** Doom Emacs :package:version:
:PROPERTIES:
:meta-dir+: /packages
:END:
#+begin_src scheme :tangle (meta-in-dir "doom-emacs.scm")
(define-module (phrenetic packages doom-emacs)
  #:use-module (guix build-system copy)
  #:use-module (guix gexp)
  #:use-module (guix git-download)
  #:use-module (guix packages)
  #:use-module ((guix licenses) #:prefix license:)
  #:use-module ((gnu packages rust-apps) #:select (fd ripgrep))
  #:use-module ((gnu packages version-control) #:select (git))
  #:use-module ((phrenetic packages all-the-icons-fonts) #:select (all-the-icons-fonts)))

(define-public doom-emacs
  (let ((commit "9d4d5b756a8598c4b5c842e9f1f33148af2af8fd")
        (revision "0"))
    (package
      (name "doom-emacs")
      (version (git-version "3.0.0-pre" revision commit))
      (source
       (origin
         (method git-fetch)
         (uri (git-reference
               (url "https://github.com/doomemacs/doomemacs")
               (commit commit)))
         (sha256
          (base32
           "1j9768sp7823z6fz4jikapgyh1x2230xacslgvj2p5svpcb40i29"))
         (file-name (git-file-name name version))
         (patches
          (list (local-file "patches/dirvish.patch")))))
      (build-system copy-build-system) ; TODO LICENSE file gets installed to a "share/" folder, not hurting anything but maybe remove. More generally perhaps check to see what other changes there might be between a simple checkout of the repo and what copy-build-system does.
      (arguments
       (list
        ;; #:install-plan
        ;; '(("." "share/doom-emacs/"))
        ;; #:tests? #t
        ;; #:test-command '("./bin/doom" "test")
        #:phases
        #~(modify-phases %standard-phases
            (add-after 'install 'symlink-bin
              (lambda _
                (mkdir #$output:bin)
                (symlink (string-append #$output "/bin")
                         (string-append #$output:bin "/bin")))))))
      (propagated-inputs
       (list git ; TODO might not be necessary after I do my Guix-straight integration.
             ripgrep
             fd
             all-the-icons-fonts

             ;; TODO For dirvish, putting them here temporarily.
             (@ (gnu packages rust-apps) fd)
             (@ (gnu packages imagemagick) imagemagick)
             (@ (gnu packages pdf) poppler) ; TODO Readme says "or pdf-tools"?
             ;; TODO epubs. See:
             ;; - https://github.com/alexluigit/dirvish/blob/main/docs/CUSTOMIZING.org
             ;; - https://github.com/alexluigit/dirvish/issues/85
             (@ (gnu packages video) ffmpegthumbnailer)
             (@ (gnu packages video) mediainfo)
             (@ (gnu packages base) tar)
             (@ (gnu packages compression) unzip)))
      (outputs '("out" "bin"))
      (synopsis "An Emacs framework for the stubborn martian hacker")
      (description "Doom is a configuration framework for GNU Emacs tailored for
Emacs bankruptcy veterans who want less framework in their frameworks, a modicum
of stability (and reproducibility) from their package manager, and the
performance of a hand rolled config (or better).")
      (home-page "https://github.com/doomemacs/doomemacs")
      (license license:expat))))
#+end_src
***** WAIT Doom tests :wait_on_doom:
Nonfunctional at the moment (hlissner has them commented out) but once they're working determine if they make sense to run during packaging (if they can find places where my patches, substitutions, etc. can mess stuff up). I'm concerned they'll take too long to run or require network access (to download Straight dependencies). Make sure there aren't any side effect files that end up getting installed.
***** Emacs packages :package:version:
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "emacs-xyz.scm")
:END:
#+begin_src scheme
(define-module (phrenetic packages emacs-xyz)
  #:use-module (guix build-system copy)
  #:use-module (guix build-system emacs)
  #:use-module (guix download)
  #:use-module (guix gexp)
  #:use-module (guix git-download)
  #:use-module (guix packages)
  #:use-module ((guix licenses) #:prefix license:)
  #:use-module ((guix utils) #:select (substitute-keyword-arguments))
  #:use-module ((gnu packages emacs-xyz) #:select (emacs-tldr) #:prefix emacs-xyz:)
  #:use-module ((gnu packages compression) #:select (unzip))
  #:use-module (phrenetic utils))
#+end_src
****** guix-contributing
- TODO maybe don't create a special "subpackage" for Guix development files and do something like this instead: [[https://github.com/abcdw/rde/commit/bcc4650768517e6264709f2164fa857b264d9190][rde: examples: abcdw: Source templates from guix package sources. · abcdw/rde...]]
#+begin_src scheme
(define-public emacs-guix-contributing
  (package
    (name "emacs-guix-contributing")
    (version "0")
    (source
     (local-file "guix-contributing.el"))
    (build-system emacs-build-system)
    (arguments
     '(#:phases
       (modify-phases %standard-phases
         (add-after 'unpack 'patch-guix-source-path
           (lambda* (#:key inputs #:allow-other-keys)
             (make-file-writable "guix-contributing.el")
             (emacs-substitute-variables "guix-contributing.el"
               ("guix-contributing-source-path" (search-input-directory inputs "share/guix-emacs-development"))))))))
    (inputs
     (list guix-emacs-development))
    (home-page #f)
    (synopsis "Some Emacs integration to assist in contributing to Guix")
    (description "See https://guix.gnu.org/manual/en/guix.html#The-Perfect-Setup")
    (license license:gpl3+)))
#+end_src
******* Source
Tempel snippets now available under =/etc/snippets/tempel= as of [2022-08-30 Tue] and this [[https://github.com/guix-mirror/guix/commit/c4acaf412064568a546034871a9e0d3888aa7937][commit]].
#+begin_src emacs-lisp :tangle (meta-in-dir "guix-contributing.el")
(defvar guix-contributing-source-path "~/src/guix")

(with-eval-after-load 'yasnippet
  (add-to-list 'yas-snippet-dirs (concat guix-contributing-source-path "/etc/snippets/yas")))

(load-file (concat guix-contributing-source-path "/etc/copyright.el"))

(when (and user-full-name
           user-mail-address)
  (setq copyright-names-regexp (format "%s <%s>" user-full-name user-mail-address)))

(provide 'guix-contributing)
#+end_src
******* Guix's Emacs development code
Use the github mirror since the canonical repo doesn't allow shallow fetches.
#+begin_src scheme
(define guix-emacs-development*
  (let ((commit "bf0389a3806509650b7a8425973ac5aac722901a")
        (revision "0"))
    (package
      (name "guix-emacs-development")
      (version (git-version "1.3.0" revision commit))
      (source
       (origin
         (method git-fetch)
         (uri (git-reference
               (url "https://git.savannah.gnu.org/git/guix.git")
               (commit commit)))
         (sha256
          (base32
           "0x4mpw017q4l14aimlyzxxa68jz2rn6zb8m8l7s791fkkdn2paja"))))
      (build-system copy-build-system)
      (arguments
       `(#:install-plan
         '(("etc/copyright.el" "share/guix-emacs-development/etc/copyright.el")
           ("etc/snippets" "share/guix-emacs-development/etc/snippets"))))
      (home-page #f)
      (synopsis #f)
      (description #f)
      (license #f))))

(define guix-emacs-development
  (with-git-url guix-emacs-development* "https://github.com/guix-mirror/guix"))
#+end_src
****** tldr
#+begin_src scheme
(define-public emacs-tldr
  (package
    (inherit emacs-xyz:emacs-tldr)
    (arguments
     (substitute-keyword-arguments (package-arguments emacs-xyz:emacs-tldr)
       ((#:phases phases '%standard-phases)
        #~(modify-phases #$phases
            (add-after 'unpack 'patch-tldr-directory-path
              (lambda* (#:key inputs #:allow-other-keys)
                (emacs-substitute-variables "tldr.el"
                  ("tldr-directory-path" (search-input-directory inputs "share/tldr-pages")))))))))
    (inputs
     (modify-inputs (package-inputs emacs-xyz:emacs-tldr)
       (prepend tldr-pages)))))
#+end_src
******* tldr pages
#+begin_src scheme
(define tldr-pages
  (let ((commit "7ee7ed0f4afc90ef05b1dde87f6fec5b462a0394")
        (revision "0"))
    (package
      (name "tldr-pages")
      (version (git-version "1.5b" revision commit))
      (source
       (origin
         (method url-fetch/zipbomb)
         (uri (string-append "https://raw.githubusercontent.com/tldr-pages/tldr-pages.github.io/" commit "/assets/tldr.zip"))
         (sha256
          (base32
           "0a09ycfrxiaxv0hzjrkwi56l0ga5d7ydrlclmk4vd6ndb242vhgr"))))
      (build-system copy-build-system)
      (arguments
       `(#:install-plan
         '(("." "share/tldr-pages/"))))
      (home-page "https://tldr.sh")
      (synopsis "A collection of community-maintained help pages for command-line tools")
      (description synopsis)
      (license license:cc-by4.0))))
#+end_src
***** all-the-icons fonts :package:version:
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "all-the-icons-fonts.scm")
:END:
#+begin_src scheme
(define-module (phrenetic packages all-the-icons-fonts)
  #:use-module (guix build-system font)
  #:use-module (guix git-download)
  #:use-module (guix packages)
  #:use-module ((gnu packages emacs-xyz) #:select (emacs-all-the-icons))
  #:use-module ((gnu packages fonts) #:select (font-google-material-design-icons font-awesome))
  #:use-module (phrenetic utils))

(define-public all-the-icons-fonts
  (let ((commit "4a4d6269b8b85b0b15954f063e6ce378630d80c0")
        (revision "0"))
    (package
      (name "all-the-icons-fonts")
      (version (git-version (package-version emacs-all-the-icons) revision commit))
      (source
       (origin
         (inherit (package-source emacs-all-the-icons))
         (uri (git-reference
               (inherit (-> emacs-all-the-icons package-source origin-uri))
               (commit commit)))
         (sha256
          (base32
           "0y1dpxv8hha8pcxssayy0gaa7jd15ad0hwpmpixg164xzjn0cnb6"))
         (file-name (git-file-name name version))))
      (build-system font-build-system)
      (arguments
       `(#:phases
         (modify-phases %standard-phases
           (add-before 'install 'remove-unbundled-fonts
             (lambda _
               (with-directory-excursion "fonts"
                 (for-each delete-file
                           (list "fontawesome.ttf"
                                 "material-design-icons.ttf"))))))))
      (propagated-inputs
       (list font-awesome
             font-google-material-design-icons))
      (home-page (package-home-page emacs-all-the-icons))
      (synopsis (package-synopsis emacs-all-the-icons))
      (description (package-description emacs-all-the-icons))
      (license (package-license emacs-all-the-icons)))))
#+end_src
***** Patches
****** Dirvish :version:
Taken from https://github.com/doomemacs/doomemacs/pull/6760.
#+begin_src diff :tangle (meta-in-dir "patches/dirvish.patch")
diff --git a/modules/emacs/dired/autoload.el b/modules/emacs/dired/autoload.el
deleted file mode 100644
index e44d3dda0dd..00000000000
--- a/modules/emacs/dired/autoload.el
+++ /dev/null
@@ -1,15 +0,0 @@
-;;; emacs/dired/autoload.el -*- lexical-binding: t; -*-
-
-;;;###autoload
-(defun +dired/quit-all ()
-  "Kill all `dired-mode' buffers."
-  (interactive)
-  (mapc #'kill-buffer (doom-buffers-in-mode 'dired-mode))
-  (message "Killed all dired buffers"))
-
-;;;###autoload
-(defun +dired-enable-git-info-h ()
-  "Enable `dired-git-info-mode' in git repos."
-  (and (not (file-remote-p default-directory))
-       (locate-dominating-file "." ".git")
-       (dired-git-info-mode 1)))
diff --git a/modules/emacs/dired/config.el b/modules/emacs/dired/config.el
index 26e5e74e20b..c7d12bb33e0 100644
--- a/modules/emacs/dired/config.el
+++ b/modules/emacs/dired/config.el
@@ -1,10 +1,9 @@
-;;; tools/dired/config.el -*- lexical-binding: t; -*-
+;;; emacs/dired/config.el -*- lexical-binding: t; -*-
 
 (use-package! dired
   :commands dired-jump
   :init
   (setq dired-dwim-target t  ; suggest a target for moving/copying intelligently
-        dired-hide-details-hide-symlink-targets nil
         ;; don't prompt to revert, just do it
         dired-auto-revert-buffer #'dired-buffer-stale-p
         ;; Always copy/delete recursively
@@ -25,31 +24,21 @@
     :slot 20 :size 0.8 :select t :quit nil :ttl 0)
   (set-evil-initial-state! 'image-dired-display-image-mode 'emacs)
 
-  (let ((args (list "-ahl" "-v" "--group-directories-first")))
-    (when IS-BSD
-      ;; Use GNU ls as `gls' from `coreutils' if available. Add `(setq
-      ;; dired-use-ls-dired nil)' to your config to suppress the Dired warning
-      ;; when not using GNU ls.
-      (if-let (gls (executable-find "gls"))
-          (setq insert-directory-program gls)
-        ;; BSD ls doesn't support -v or --group-directories-first
-        (setq args (list (car args)))))
-    (setq dired-listing-switches (string-join args " "))
-
-    (add-hook! 'dired-mode-hook
-      (defun +dired-disable-gnu-ls-flags-maybe-h ()
-        "Remove extraneous switches from `dired-actual-switches' when it's
-uncertain that they are supported (e.g. over TRAMP or on Windows).
-
-Fixes #1703: dired over TRAMP displays a blank screen.
-Fixes #3939: unsortable dired entries on Windows."
-        (when (or (file-remote-p default-directory)
-                  (and (boundp 'ls-lisp-use-insert-directory-program)
-                       (not ls-lisp-use-insert-directory-program)))
-          (setq-local dired-actual-switches (car args))))))
-
-  ;; Don't complain about this command being disabled when we use it
-  (put 'dired-find-alternate-file 'disabled nil)
+  (let ((non-gnu-args "-alh")
+        (gnu-args
+         "-l --almost-all --human-readable --group-directories-first"))
+    (cond ((and (boundp 'ls-lisp-use-insert-directory-program)
+                (not ls-lisp-use-insert-directory-program)
+                (< emacs-major-version 28))
+           ;; Fixes #3939: unsortable dired entries on Windows
+           (setq dired-listing-switches non-gnu-args))
+          (IS-BSD
+           ;; BSD ls doesn't support long options
+           (if-let (gls (executable-find "gls"))
+               (setq insert-directory-program gls
+                     dired-listing-switches gnu-args)
+             (setq dired-listing-switches non-gnu-args)))
+          (t (setq dired-listing-switches gnu-args))))
 
   (defadvice! +dired--no-revert-in-virtual-buffers-a (&rest args)
     "Don't auto-revert in dired-virtual buffers (see `dired-virtual-revert')."
@@ -57,127 +46,11 @@ Fixes #3939: unsortable dired entries on Windows."
     (not (eq revert-buffer-function #'dired-virtual-revert)))
 
   (map! :map dired-mode-map
-        ;; Kill all dired buffers on q
-        :ng "q" #'+dired/quit-all
         ;; To be consistent with ivy/helm+wgrep integration
         "C-c C-e" #'wdired-change-to-wdired-mode))
 
 
-(use-package! dired-rsync
-  :general (dired-mode-map "C-c C-r" #'dired-rsync))
-
-
-(use-package! diredfl
-  :hook (dired-mode . diredfl-mode))
-
-
-(use-package! ranger
-  :when (modulep! +ranger)
-  :after dired
-  :init (setq ranger-override-dired t)
-  :config
-  (unless (file-directory-p image-dired-dir)
-    (make-directory image-dired-dir))
-
-  (set-popup-rule! "^\\*ranger" :ignore t)
-
-  (defadvice! +dired--cleanup-header-line-a ()
-    "Ranger fails to clean up `header-line-format' when it is closed, so..."
-    :before #'ranger-revert
-    (dolist (buffer (buffer-list))
-      (when (buffer-live-p buffer)
-        (with-current-buffer buffer
-          (when (equal header-line-format '(:eval (ranger-header-line)))
-            (setq header-line-format nil))))))
-
-  (defadvice! +dired--cleanup-mouse1-bind-a ()
-    "Ranger binds an anonymous function to mouse-1 after previewing a buffer
-that prevents the user from escaping the window with the mouse. This command is
-never cleaned up if the buffer already existed before ranger was initialized, so
-we have to clean it up ourselves."
-    :after #'ranger-setup-preview
-    (when (window-live-p ranger-preview-window)
-      (with-current-buffer (window-buffer ranger-preview-window)
-        (local-unset-key [mouse-1]))))
-
-  (defadvice! +dired--ranger-travel-a ()
-    "Temporary fix for this function until ralesi/ranger.el#236 gets merged."
-    :override #'ranger-travel
-    (interactive)
-    (let ((prompt "Travel: "))
-      (cond
-       ((bound-and-true-p helm-mode)
-        (ranger-find-file (helm-read-file-name prompt)))
-       ((bound-and-true-p ivy-mode)
-        (ivy-read prompt 'read-file-name-internal
-                  :matcher #'counsel--find-file-matcher
-                  :action
-                  (lambda (x)
-                    (with-ivy-window
-                     (ranger-find-file (expand-file-name x default-directory))))))
-       ((bound-and-true-p ido-mode)
-        (ranger-find-file (ido-read-file-name prompt)))
-       (t
-        (ranger-find-file (read-file-name prompt))))))
-
-  (setq ranger-cleanup-on-disable t
-        ranger-excluded-extensions '("mkv" "iso" "mp4")
-        ranger-deer-show-details t
-        ranger-max-preview-size 10
-        ranger-show-literal nil
-        ranger-hide-cursor nil))
-
-
-(use-package! dirvish
-  :when (modulep! +dirvish)
-  :defer t
-  :init (after! dired (dirvish-override-dired-mode))
-  :hook (dired-mode . dired-omit-mode)
-  :config
-  (setq dirvish-cache-dir (concat doom-cache-dir "dirvish/")
-        dirvish-hide-details nil
-        dirvish-attributes '(git-msg)
-        dired-omit-files (concat dired-omit-files "\\|^\\..*$"))
-  (when (modulep! +icons)
-    (push 'all-the-icons dirvish-attributes))
-  (map! :map dirvish-mode-map
-        :n "b" #'dirvish-goto-bookmark
-        :n "z" #'dirvish-show-history
-        :n "f" #'dirvish-file-info-menu
-        :n "F" #'dirvish-toggle-fullscreen
-        :n "l" #'dired-find-file
-        :n "h" #'dired-up-directory
-        :localleader
-        "h" #'dired-omit-mode))
-
-
-(use-package! all-the-icons-dired
-  :when (modulep! +icons)
-  :unless (modulep! +dirvish)
-  :hook (dired-mode . all-the-icons-dired-mode)
-  :config
-  ;; HACK Fixes #1929: icons break file renaming in Emacs 27+, because the icon
-  ;;      is considered part of the filename, so we disable icons while we're in
-  ;;      wdired-mode.
-  (defvar +wdired-icons-enabled -1)
-
-  ;; display icons with colors
-  (setq all-the-icons-dired-monochrome nil)
-
-  (defadvice! +dired-disable-icons-in-wdired-mode-a (&rest _)
-    :before #'wdired-change-to-wdired-mode
-    (setq-local +wdired-icons-enabled (if all-the-icons-dired-mode 1 -1))
-    (when all-the-icons-dired-mode
-      (all-the-icons-dired-mode -1)))
-
-  (defadvice! +dired-restore-icons-after-wdired-mode-a (&rest _)
-    :after #'wdired-change-to-dired-mode
-    (all-the-icons-dired-mode +wdired-icons-enabled)))
-
-
 (use-package! dired-x
-  :unless (modulep! +dirvish)
-  :unless (modulep! +ranger)
   :hook (dired-mode . dired-omit-mode)
   :config
   (setq dired-omit-verbose nil
@@ -211,37 +84,55 @@ we have to clean it up ourselves."
         "h" #'dired-omit-mode))
 
 
-(use-package! fd-dired
-  :when doom-projectile-fd-binary
-  :defer t
-  :init
-  (global-set-key [remap find-dired] #'fd-dired)
-  (set-popup-rule! "^\\*F\\(?:d\\|ind\\)\\*$" :ignore t))
-
 (use-package! dired-aux
   :defer t
   :config
   (setq dired-create-destination-dirs 'ask
         dired-vc-rename-file t))
 
-;;;###package dired-git-info
-(map! :after dired
-      :map (dired-mode-map ranger-mode-map)
-      :ng ")" #'dired-git-info-mode)
-(setq dgi-commit-message-format "%h %cs %s"
-      dgi-auto-hide-details-p nil)
-(after! wdired
-  ;; Temporarily disable `dired-git-info-mode' when entering wdired, due to
-  ;; reported incompatibilities.
-  (defvar +dired--git-info-p nil)
-  (defadvice! +dired--disable-git-info-a (&rest _)
-    :before #'wdired-change-to-wdired-mode
-    (setq +dired--git-info-p (bound-and-true-p dired-git-info-mode))
-    (when +dired--git-info-p
-      (dired-git-info-mode -1)))
-  (defadvice! +dired--reactivate-git-info-a (&rest _)
-    :after '(wdired-exit
-             wdired-abort-changes
-             wdired-finish-edit)
-    (when +dired--git-info-p
-      (dired-git-info-mode +1))))
+
+(use-package! diredfl
+  :hook (dired-mode . diredfl-mode)
+  :hook (dirvish-directory-view-mode . diredfl-mode))
+
+
+(use-package! dirvish
+  :defer t
+  :general (dired-mode-map "C-c C-r" #'dirvish-yank) ; for backward compatibility
+  :after-call dired-noselect dired dired-jump
+  :config
+  (dirvish-override-dired-mode)
+  (setq dirvish-cache-dir (concat doom-cache-dir "dirvish/"))
+  (set-popup-rule! "^ ?\\*Dirvish.*" :ignore t)
+  (map! :map dirvish-mode-map
+        :n  "?"   #'dirvish-dispatch
+        :n  "q"   #'dirvish-quit
+        :ng "a"   #'dirvish-quick-access
+        :ng "f"   #'dirvish-file-info-menu
+        :ng "y"   #'dirvish-yank-menu
+        :ng "s"   #'dirvish-quicksort
+        :ng "TAB" #'dirvish-subtree-toggle
+        :ng "M-t" #'dirvish-layout-toggle
+        :ng "M-b" #'dirvish-history-go-backward
+        :ng "M-f" #'dirvish-history-go-forward
+        :ng "M-n" #'dirvish-narrow
+        :ng "M-m" #'dirvish-mark-menu
+        :ng "M-s" #'dirvish-setup-menu
+        :ng "M-e" #'dirvish-emerge-menu)
+  (if (modulep! +dirvish)
+      (setq dirvish-attributes '(file-size collapse)
+            dirvish-mode-line-format
+            '(:left (sort file-time symlink) :right (omit yank index)))
+    (setq dirvish-attributes nil
+          dirvish-use-header-line nil
+          dirvish-mode-line-format nil
+          dirvish-hide-details nil
+          dirvish-hide-cursor nil))
+  (when (modulep! :ui tabs)
+    (after! centaur-tabs
+      (add-hook! 'dired-mode-hook 'centaur-tabs-local-mode)
+      (add-hook! 'dirvish-directory-view-mode-hook 'centaur-tabs-local-mode)))
+  (when (modulep! :ui vc-gutter)
+    (push 'vc-state dirvish-attributes))
+  (when (modulep! +icons)
+    (appendq! dirvish-attributes '(all-the-icons subtree-state))))
diff --git a/modules/emacs/dired/doctor.el b/modules/emacs/dired/doctor.el
index 2c2e77b29ab..3c0c77a8cfd 100644
--- a/modules/emacs/dired/doctor.el
+++ b/modules/emacs/dired/doctor.el
@@ -2,3 +2,6 @@
 
 (when (and IS-BSD (not (executable-find "gls")))
   (warn! "Cannot find gls (GNU ls). This may cause issues with dired"))
+
+(when (modulep! +ranger)
+  (warn! "The +ranger flag has been removed from this module"))
diff --git a/modules/emacs/dired/packages.el b/modules/emacs/dired/packages.el
index 06e5659a592..a3dfc11359c 100644
--- a/modules/emacs/dired/packages.el
+++ b/modules/emacs/dired/packages.el
@@ -1,14 +1,5 @@
 ;; -*- no-byte-compile: t; -*-
 ;;; emacs/dired/packages.el
 
-(package! diredfl :pin "f9140b2c42151dca669003d685c9f079b2e3dc37")
-(package! dired-git-info :pin "9461476a28a5fec0784260f6e318237c662c3430")
-(package! dired-rsync :pin "7940d9154d0a908693999b0e1ea351a6d365c93d")
-(when (modulep! +ranger)
-  (package! ranger :pin "2498519cb21dcd5791d240607a72a204d1761668"))
-(when (modulep! +dirvish)
-  (package! dirvish :pin "73dcaa404da9ab84d25f2919e6e3af4b1f8e7f37"))
-(when (and (modulep! +icons)
-           (not (modulep! +dirvish)))
-  (package! all-the-icons-dired :pin "5e9b097f9950cc9f86de922b07903a4e5fefc733"))
-(package! fd-dired :pin "458464771bb220b6eb87ccfd4c985c436e57dc7e")
+(package! diredfl :pin "62b559e1d6b69834a56a57eb1832ac6ad4d2e5d0")
+(package! dirvish :pin "22af07264007bdfced9f332d04053d9d93806289")
diff --git a/modules/ui/vc-gutter/config.el b/modules/ui/vc-gutter/config.el
index c555f9d08f7..006de3e3fc6 100644
--- a/modules/ui/vc-gutter/config.el
+++ b/modules/ui/vc-gutter/config.el
@@ -148,9 +148,10 @@ is deferred until the file is saved. Respects `git-gutter:disabled-modes'."
   :when (modulep! +diff-hl)
   :hook (find-file    . diff-hl-mode)
   :hook (vc-dir-mode  . diff-hl-dir-mode)
-  :hook (dired-mode   . diff-hl-dired-mode)
   :hook (diff-hl-mode . diff-hl-flydiff-mode)
   :config
+  (unless (modulep! :emacs dired)
+    (add-hook! 'dired-mode-hook #'diff-hl-dired-mode))
   (set-popup-rule! "^\\*diff-hl" :select nil :size '+popup-shrink-to-fit)
 
   ;; PERF: reduce load on remote
#+end_src
***** packaging doom WIP
Extremely WIP, basically just a scratchpad
****** first attempts
Had =:tangle (meta-in-dir "packaging-doom-wip-1.scm")=
#+begin_src scheme :tangle no
(define-module (phrenetic packaging-doom-wip)
  #:use-module (guix build-system trivial)
  #:use-module (guix gexp)
  #:use-module (guix git-download)
  #:use-module (guix packages)
  #:use-module ((guix licenses) #:prefix license:)
  ;; #:use-module ((gnu packages emacs) #:select (emacs))
  #:use-module ((gnu packages version-control) #:select (git))
  #:use-module (phrenetic packages emacs)
  #:use-module (phrenetic packages doom-emacs)
  )

;; (define doom-inputs
;;   (computed-file
;;    "doom-inputs"
;;    (with-imported-modules '((guix build utils))
;;      #~(begin
;;          (use-modules (guix build utils))
;;          (invoke (string-append #+doom-emacs:bin "/bin/doom") "help")
;;          (copy-file #$(local-file "nixpkgs-config.nix") #$output)
;;          ;; `emacs-substitute-sexps' might be useful here if my needs get more sophisticated.
;;          ;; (substitute* #$output
;;          ;;   (("(dunstctl|dunst)" all) (case (string->symbol all)
;;          ;;                               ((dunst) (string-append #$(file-append dunst "/bin/dunst")
;;          ;;                                                       " -config " #$(local-file "dunstrc")))
;;          ;;                               ((dunstctl) #$(file-append dunst "/bin/dunstctl"))))
;;          ;;   (("nm-applet") #$(file-append network-manager-applet "/bin/nm-applet"))
;;          ;;   (("pasystray") #$(file-append pasystray "/bin/pasystray"))
;;          ;;   (("redshift-gtk") (string-append #$redshift:gtk "/bin/redshift-gtk"))
;;          ;;   (("udiskie") #$(file-append udiskie "/bin/udiskie")))
;;          ))))


(define-public temp-doom-emacs
  (package
    (name "doom-emacs")
    (version "0")
    (source
     (local-file "/home/pharcosyle/work/dotfiles/doom-emacs" #:recursive? #t))
    (build-system (@ (guix build-system copy) copy-build-system))
    (synopsis "")
    (description "")
    (home-page "")
    (license #f)))

(define-public doom-inputs
  (package
    (name "doom-inputs")
    (version "0")
    (source #f)
    (inputs
     (list emacs-29-pgtk+native-comp
           ;; doom-emacs
           temp-doom-emacs
           ;; (local-file "doom-private" #:recursive? #t)
           git
           ;; (local-file "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/straight.el" #:recursive? #t)
           ;; (local-file "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/use-package" #:recursive? #t)
           ))
    (build-system trivial-build-system)
    (arguments
     `(#:modules ((guix build utils))
       #:builder
       ,#~(begin
            (use-modules (guix build utils))
            (let ((doom-private #$(local-file "doom-private" #:recursive? #t))
                  (doom-local-dir (string-append #$output "/doom-local")))
              (mkdir-p doom-local-dir)

              ;; (mkdir-p (string-append #$output "/asdf"))
              ;; (with-output-to-file (string-append #$output "/asdf/asdf.txt")
              ;;   (lambda _
              ;;     (display "asdffffffffffff")))

              (setenv "PATH" (string-append (getenv "PATH")
                                            ":" (assoc-ref %build-inputs "emacs-29-pgtk+native-comp") "/bin"
                                            ":" (assoc-ref %build-inputs "git") "/bin"
                                            ))
              ;; (setenv "DOOMDIR" (assoc-ref %build-inputs "doom-private"))
              (setenv "DOOMDIR" doom-private)
              (setenv "DOOMLOCALDIR" doom-local-dir)

              ;; (chdir #$output)
              ;; (invoke "git" "clone" "https://github.com/dracula/gtk")

              ;; (display "hi!")
              ;; (display doom-private)
              ;; (display straight-el)

              (let ((repos-dir (string-append doom-local-dir "/straight/repos")))
                (mkdir-p repos-dir)
                (symlink #$(local-file "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/straight.el" #:recursive? #t)
                         (string-append repos-dir "/straight.el"))
                (symlink #$(local-file "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/use-package" #:recursive? #t)
                         (string-append repos-dir "/use-package"))
                (symlink #$(local-file "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/melpa" #:recursive? #t)
                         (string-append repos-dir "/melpa"))
                (symlink #$(local-file "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/gnu-elpa-mirror" #:recursive? #t)
                         (string-append repos-dir "/gnu-elpa-mirror"))
                (symlink #$(local-file "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/el-get" #:recursive? #t)
                         (string-append repos-dir "/el-get"))
                (symlink #$(local-file "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/emacsmirror-mirror" #:recursive? #t)
                         (string-append repos-dir "/emacsmirror-mirror")))

              (setenv "HOME" "/tmp/asdfasdf")
              (mkdir-p "/tmp/asdfasdf")

              ;; (symlink #$(local-file "/home/pharcosyle/work/dotfiles/doom-emacs" #:recursive? #t)
              ;;            (string-append #$output "/temp-doom-emacs"))
              (let ((doom
                     ;; #$(local-file "/home/pharcosyle/work/dotfiles/doom-emacs" #:recursive? #t)
                     (assoc-ref %build-inputs "doom-emacs")
                     ;; (string-append #$output "/temp-doom-emacs")
                     ))
                ;; (invoke (string-append #$(@ (gnu packages base) coreutils) "/bin/echo") "asdfasdfsdf")
                ;; (invoke (string-append doom "/bin/doom") "help")
                (invoke (string-append doom "/bin/doom") "install" "--no-config" "--no-env" "--no-fonts" "--no-hooks")
                )

              ;; (copy-file #$(local-file "nixpkgs-config.nix") #$output)
              )


            #t)))

    ;; (arguments
    ;;  `(;; #:install-plan
    ;;    ;; '(("." "share/doom-emacs/"))
    ;;    ;; #:tests? #t
    ;;    ;; #:test-command '("./bin/doom" "test")
    ;;    #:phases
    ;;    ,#~(modify-phases %standard-phases
    ;;         (add-after 'install 'symlink-bin
    ;;           (lambda _
    ;;             (mkdir #$output:bin)
    ;;             (symlink (string-append #$output "/bin")
    ;;                      (string-append #$output:bin "/bin")))))))

    (synopsis "")
    (description "")
    (home-page "")
    (license #f)))





(use-modules ((guix packages) #:select (content-hash content-hash-algorithm content-hash-value)))

(define doom-build
  (computed-file
   "doom-build"
   (with-imported-modules '((guix build utils))
     #~(begin
         (use-modules (guix build utils))

         ;; (mkdir-p #$output)

         (setenv "GIT_SSL_NO_VERIFY" "true") ; do ssl if it's easy. Also if I'm using `(guix build git) git-fetch' consider if it setting this variable leaks out.

         ;; (invoke (string-append #+doom-emacs:bin "/bin/doom") "help")
         ;; (copy-file #$(local-file "nixpkgs-config.nix") #$output)
         ;; (invoke (string-append #$(@ (gnu packages wget) wget) "/bin/wget") "--no-check-certificate" "https://xkcd.com/")
         ;; (copy-file "index.html" #$output)

         ;; TODO Consider making e.g. emacs, git not ungexped in a let but instead everywhere they're used (and move this let outside of the gexp). Then I could use file-append instead of string-append in places I guess. Which is better practice?
         (let ((doom-private #+(file-union "doom-private"
                                           `(("init.el" ,(file-append (local-file "/home/pharcosyle/work/dotfiles/doom-emacs" #:recursive? #t)
                                                                      "/init.example.el"))
                                             ("config.el" ,(file-append (local-file "/home/pharcosyle/work/dotfiles/doom-emacs" #:recursive? #t)
                                                                        "/core/templates/config.example.el"))
                                             ("packages.el" ,(file-append (local-file "/home/pharcosyle/work/dotfiles/doom-emacs" #:recursive? #t)
                                                                          "/core/templates/packages.example.el")))))
               ;; (doom-private #$(local-file "doom-private" #:recursive? #t))
               (doom-local-dir (string-append #$output "/doom-local"))
               (emacs #+emacs-29-pgtk+native-comp)
               (git #+git)
               ;; (emacs (assoc-ref %build-inputs "emacs-29-pgtk+native-comp"))
               ;; (git (assoc-ref %build-inputs "git"))
               (doom-emacs #+temp-doom-emacs)
               ;; (doom-emacs #+doom-emacs)
               ;; (doom-emacs (assoc-ref %build-inputs "doom-emacs"))
               ;; (doom-emacs #$(local-file "/home/pharcosyle/work/dotfiles/doom-emacs" #:recursive? #t))
               )
           (mkdir-p doom-local-dir)

           (setenv "PATH" (string-append (getenv "PATH")
                                         ":" emacs "/bin"
                                         ":" git "/bin"
                                         ":" #+(@ (gnu packages base) coreutils) "/bin" ; donno if this is necessary
                                         ":" #+(@ (gnu packages base) sed) "/bin"
                                         ))
           ;; Is this a better/cleaner way to do path-setting? Consider also the comment (from git-download.scm), should I add more stuff to the path?
           ;;
           ;; The 'git submodule' commands expects Coreutils, sed,
           ;; grep, etc. to be in $PATH.
           ;; (set-path-environment-variable "PATH" '("bin")
           ;;                                (match '#+inputs
           ;;                                  (((names dirs outputs ...) ...)
           ;;                                   dirs)))

           (setenv "DOOMDIR" doom-private)
           (setenv "DOOMLOCALDIR" doom-local-dir)

           ;; (chdir #$output)
           ;; (invoke "git" "clone" "https://github.com/dracula/gtk")

           ;; donno if this is necessary
           (setenv "HOME" "/tmp/asdfasdf")
           (mkdir-p "/tmp/asdfasdf")

           ;; temporary straight.el experimentation
           ;; (mkdir-p "/tmp/asdfasdf/123456")
           (mkdir-p (string-append doom-local-dir "/straight/repos"))
           (symlink #+(local-file "/home/pharcosyle/work/dotfiles/straight.el" #:recursive? #t)
                    (string-append doom-local-dir "/straight/repos/straight.el"))

           ;; (copy-file #$(local-file "nixpkgs-config.nix") (string-append doom-local-dir "/asdf.txt"))
           ;; (invoke (string-append doom-emacs "/bin/doom") "help")
           (invoke (string-append doom-emacs "/bin/doom") "install" "--no-config" "--no-env" "--no-fonts" "--no-hooks")
           ;; (invoke (string-append doom-emacs "/bin/doom") "upgrade")
           ;; (invoke (string-append doom-emacs "/bin/doom") "build")
           ;; (invoke (string-append doom-emacs "/bin/doom") "sync")

           ;; (invoke (string-append emacs "/bin/emacs") "--batch" "--eval=\"(progn (load user-init-file) (straight-freeze-versions))\"")
           ;; (invoke (string-append emacs "/bin/emacs") "--batch" "--eval='(progn (message \"hello!\"))'")
           ;; (invoke "emacs" "--batch" "--eval='(message \"hello!\")'")
           ;; (chdir #$output)
           ;; (invoke "emacs" "--batch" "--eval='(with-temp-file \"asdf.txt\" (insert \"asdfasdf\"))'")
           ;; (invoke "emacs" "--batch" "--eval='(message \"hello!\")'")
           ;; (invoke "emacs" "--help")
           ;; (invoke "echo" (string-append (string-append emacs "/bin/emacs") "--batch" (string-append "--load=" doom-emacs "/init.el") "--eval=(progn (message \"hi\") (message \"yo\"))"))
           ;; (invoke (string-append emacs "/bin/emacs") "--batch" (string-append "--load=" doom-emacs "/init.el") "--eval=(progn (message \"hi\") (straight-freeze-versions) (message \"yo\"))")
           ;; (invoke "echo" "asdf")

           )))
   #:options (let ((ch (content-hash "1zcpkabkizadc3j9jqnnpyqm4d71bnvxz2x6as53f6wjwn82ahd9")))
               (list #:hash (content-hash-value ch)
                     #:hash-algo (content-hash-algorithm ch)
                     #:recursive? #t
                     ;; #:substitutable? #f ; This isn't appropriate, right?
                     ))))

;; (define-public doom-build-pkg
;;   (package
;;     (name "doom-build-pkg")
;;     (version "0")
;;     (source doom-build)
;;     (build-system (@ (guix build-system copy) copy-build-system))
;;     (synopsis "")
;;     (description "")
;;     (home-page "")
;;     (license #f)))
#+end_src
****** second attempt
Had =:tangle (meta-in-dir "packaging-wip-2.scm") :comments link=
#+begin_src scheme :tangle no
(define-module (phrenetic packaging-wip)
  ;; #:use-module (guix build-system trivial)
  ;; #:use-module (guix gexp)
  ;; #:use-module (guix git-download)
  ;; #:use-module (guix packages)
  ;; #:use-module ((guix licenses) #:prefix license:)
  ;; ;; #:use-module ((gnu packages emacs) #:select (emacs))
  ;; #:use-module ((gnu packages version-control) #:select (git))
  ;; #:use-module (phrenetic packages emacs)
  ;; #:use-module (phrenetic packages doom-emacs)

  #:use-module ((guix packages) #:select (package-input-rewriting))
  #:use-module ((gnu packages emacs) #:select (emacs emacs-minimal emacs-no-x emacs-next emacs-next-pgtk emacs-xwidgets emacs-no-x-toolkit emacs-wide-int))

  )
(define emacs-variant (@ (phrenetic packages emacs) emacs-29-pgtk+native-comp))

;; TODO does this rewrite recursively?
;; package-input-rewriting/spec says it specifically does this while package-input-rewriting does not. And what about using `package-mapping'? I can check the final product for references to emacs/emacs-minimal but still read over the source code of each later. What about native-inputs, sometimes emacs(-minimal) is in there.
;; TODO do I need to specify all of the different emacs packages for rewriting?
;; Does it work without doing this already? Would package-input-rewriting/spec handle them somehow? Does `package/inherit' (in both the -spec and non-spec versions)?
(define with-emacs-variant
  (package-input-rewriting `((,emacs . ,emacs-variant)
                             (,emacs-minimal . ,emacs-variant)
                             (,emacs-no-x . ,emacs-variant)

                             ;; TODO maybe ths should be in a nested `package-input-rewriting' or having packages with themselves as input rewrites
                             ;; will cause problems, I donno. Putting this here for now.
                             (,(@ (gnu packages emacs-xyz) emacs-dash) . ,(@ (phrenetic packages emacs-xyz) emacs-dash)))))

;; (define-public test-reftex
;;   (with-emacs-variant (@ (gnu packages emacs-xyz) emacs-company-reftex)))
;; (define-public test-dash-existing
;;   (with-emacs-variant (@ (gnu packages emacs-xyz) emacs-dash)))
;; (define-public test-dash
;;   (with-emacs-variant (@ (phrenetic packages emacs-xyz) emacs-dash)))

;; (define orig-pkg (@ (gnu packages emacs-xyz) emacs-build-farm))
;; (define orig-pkg (@ (gnu packages emacs-xyz) emacs-cider))
(define orig-pkg (@ (gnu packages emacs-xyz) emacs-buttercup))

(define-public test-pkg
  (with-emacs-variant orig-pkg))





(use-modules (guix packages)
             (guix git-download))

(define (git-origin url commit hash recursive?)
  (origin
    (method git-fetch)
    (uri (git-reference
          (url url)
          (commit commit)
          (recursive? recursive?)))
    (sha256
     (base32
      hash))))



(use-modules (gnu packages)
             (guix profiles)
             ;; ((srfi srfi-1) #:select (remove))
             ;; (phrenetic utils)
             )

;; (define (doom-ps)
;;   (->> (call-with-input-file "../doom-packaging/guix-doom-emacs-packages-from-straight-build-cache.txt" read)
;;        (remove
;;         (lambda (dpns)
;;           (member dpns (list "donnager"

;;                              "straight"

;;                              ;; TODO built-in, ignoring for now but handle this when grabbing from ~doom-packages~. It marks them as ~:ignored t~
;;                              ;; - but what about built-in 'prefer, this isn't marked specially
;;                              "hideshow"
;;                              "vc"
;;                              "vc-annotate"
;;                              "smerge-mode"
;;                              "elisp-mode"
;;                              "css-mode"

;;                              "org-elpa"
;;                              "melpa"
;;                              "gnu-elpa-mirror"
;;                              "el-get"
;;                              "emacsmirror-mirror"
;;                              ))))))

(define (emacs-ps)
  (map (lambda (x)
         (string-append "emacs-" x))
       (doom-ps)))

;; (display
;;  (map (lambda (x)
;;         (find-best-packages-by-name x #f))
;;       (emacs-ps)))

;; (display
;;  (->> (emacs-ps)
;;       (map (lambda (x)
;;              (let ((found (find-best-packages-by-name x #f)))
;;                (if (null? found)
;;                  x '()))))
;;       (remove null?)))

(use-modules (gnu packages emacs-xyz)
             (phrenetic packages emacs-xyz)
             ;; (phrenetic packages emacs-xyz-batch)
             )

(define (str->pkg x)
  (primitive-eval
   (string->symbol
    (if (equal? "emacs-git-modes" x)
        "git-modes"
        x))))

;; (let ((the-manifest
;;        (packages->manifest
;;         (map str->pkg (emacs-ps)))))
;;   ;; (display the-manifest)
;;   #f)






(use-modules ((guix base32) #:select (bytevector->nix-base32-string))
             ((guix build git) #:select (git-fetch) #:prefix other:)
             (guix build utils)
             ((guix hash) #:select (file-hash*)))

(define* (git-checkout-hash url commit #:key recursive?)
  (let ((dir (string-append "/tmp" "/8888")))
    (when (file-exists? dir)
      (delete-file-recursively dir))
    (if (other:git-fetch url commit dir
                         #:recursive? recursive?
                         ;; #:git-command (string-append #+git "/bin/git")
                         )
        (let ((hash (bytevector->nix-base32-string (file-hash* dir))))
          (delete-file-recursively dir)
          hash)
        #f)))


(define (test-get-hash)
  (display
   (git-checkout-hash
    "https://github.com/emacs-evil/evil-surround"
    "282a975bda83310d20a2c536ac3cf95d2bf188a5"
    #:recursive? #t)))

;; (test-get-hash)


(define* (find-hash doom-pkg p commit #:key recursive?)
  (let ((hasher (lambda (url)
                  (git-checkout-hash url commit #:recursive? recursive?))))
    (as-> hasher $
          ($ (if (equal? (-> p package-source origin-method) git-fetch)
                 (-> p
                     package-source
                     origin-uri
                     git-reference-url)
                 (string-append "https://github.com/emacs-straight/" doom-pkg)))
          (if $ $ "NONE_FOUND"))))

;; TODO later: maybe don't look for hashes if the requested commit is already in the Guix package
;; - and maybe if the hashes turn out to be the same after doing `git-checkout-hash', presumably
;; because the Guix package had a git tag or something but it ended up being the same as the
;; Doom-requested commit, don't save the hash? Meh.
;; TODO maybe don't write out the hashes file
;; Just cache the results somehow in the guix store so hash generation can be run as-needed
(define (hashes ps)
  (let ((commits (call-with-input-file "../doom-packaging/straight-commits.txt" read)))
    (map
     (lambda (doom-pkg)
       (let* ((p (str->pkg (string-append "emacs-" doom-pkg)))
              (commit (assoc-ref commits doom-pkg))
              (hash (find-hash doom-pkg p commit #:recursive? #t)))
         (kvm #:package doom-pkg
              #:commit commit
              #:hash hash)))
     ps)))

(define (spit f content)
  (call-with-output-file f
    (lambda (port)
      (write content port))))

;; (define write-hashes (partial spit "../doom-packaging/hashes.txt"))

;; (write-hashes
;;  (hashes (list "restart-emacs" "smartparens")))
;; (write-hashes (doom-ps))
#+end_src
****** active WIP
******* clojure part
******** clj file
I had =:tangle phrenetic/src/protostar/hickeyland.clj :comments link= for the source block options here.
#+begin_src clojure :tangle no
(ns protostar.hickeyland
  (:require [clojure.alpha.spec :as s]
            [clojure.edn :as edn]
            [clojure.java.io :as io]
            [clojure.string :as str]))

;; TODO At end: just maybe try doing this, slurp, any anything else impure as some sort of "coeffects"
(defn- file-exists? [f]
  (.exists (io/file f)))


(s/defop nospec [_]
  any?)



(s/def ::str->edn (s/conformer edn/read-string)) ; TODO donno if I want to use this or just do it in clojure code (is that more idiomatic then writing a spec/conformer for everything?)


(s/def :char/blank #{\space \tab})
;; (s/def :char/newline #{\newline}) ; TODO remvoe if not needed

(s/def ::text->lines (s/conformer str/split-lines)) ; TODO donno if I want to use this or just do it in clojure code (is that more idiomatic then writing a spec/conformer for everything?)

(s/def ::str->chars (s/conformer seq))
(s/def ::chars->str (s/conformer (partial apply str)))



;; TODO would this be better / more flexible if I made it check validity (`valid?`) and then did conforming in a separate step?
;; TODO s/defop works currently but might not be the idiomatic way to do this
(s/defop s-filter [spec]
  (s/conformer
   (fn [xs]
     (keep (fn [x]
             (let [conformed (s/conform spec x)]
               (when-not (s/invalid? conformed)
                 conformed)))
           xs))))


(s/def :elisp/form any?)
(s/def :elisp/t #{t})
(s/def :elisp/list->car (s/conformer first)) ; TODO remove if not needed
(s/def :elisp/list->cdr (s/conformer next)) ; TODO remove if not needed
(s/def :elisp/plist->map (s/conformer (partial apply hash-map))) ; TODO remove if not needed
(s/def :elisp/nil-or-non-nil :elisp/form) ; TODO think this (perhaps just the name) through more?


(s/def :epkg.dep/name symbol?)
(s/def :epkg.dep/version (nospec string?))
(s/def :epkg.dep/name+ver (s/cat :name :epkg.dep/name
                                 :_version (s/? (nospec :epkg.dep/version))))
(s/def :epkg.dep/name+ver->name
  (s/conformer (fn [[form x]]
                 (case form
                   :name x
                   :name+ver (:name x)))))
(s/def :epkg/dep (s/or :name :epkg.dep/name
                       :name+ver :epkg.dep/name+ver))

(s/def :epkg/deps (s/coll-of :epkg/dep))
(s/def :epkg/deps->name-strs
  (s/coll-of (s/and
              :epkg.dep/name+ver->name
              (s/conformer str))))

;; Testing
;; (def test-deps '((emacs "24.1") another (seq) (cl-lib "0.5")))
;; (s/valid? :epkg/deps test-deps)
;; (s/explain-str :epkg/deps test-deps)
;; (s/conform :epkg/deps test-deps)
;; (s/conform
;;  (s/and
;;   :epkg/deps
;;   :epkg/deps->name-strs)
;;  test-deps)

;; TODO ideally do this better / more flexibly / maybe faster
(s/def :epkg.simple/req-header-name
  (s/&
   (s/+ char?)
   ::chars->str
   #(= "Package-Requires:" %))) ; TODO (if keeping things this way) could this just be a literal set predicate?

(s/def :epkg.simple/req-header-line
  (s/and
   ::str->chars
   (s/cat :_comment (s/&
                     (s/+ #{\;})
                     ::chars->str)
          :_ws (s/&
                (s/* :char/blank)
                ::chars->str)
          :_req-header :epkg.simple/req-header
          :_ws2 (s/&
                 (s/* :char/blank)
                 ::chars->str)
          :deps (s/&
                 (s/* char?)
                 ::chars->str
                 ::str->edn
                 :epkg/deps))))

(s/def :epkg.simple/reqs
  (s/and
   ::text->lines
   (s-filter :epkg.simple/req-header-line)
   ;; TODO spec that there should be exactly :count 1?
   (s/conformer first)
   ;; TODO what was I trying here?
   ;; (s/conformer (fn [xs]
   ;;                (or (first xs) :clojure.alpha.spec/invalid)))
   ))

;; Testing
;; (def test-pkgrequires-line ";; Package-Requires: ((emacs \"24.1\") (cl-lib \"0.5\"))")
;; (s/conform :epkg.simple/reqs (str "asdf\n" test-pkgrequires-line))
;; (s/explain-str :epkg.simple/reqs test-pkgrequires-line)

(s/def :epkg.multifile/reqs
  (s/cat :_define-package #{define-package}
         :_name (nospec string?)
         :_version (nospec :epkg.dep/version)
         :_docstring (s/? (nospec string?))
         :requirements (s/? (s/cat
                             :quote #(= (symbol (str \')) %) ; "Artifact" of `edn/read-string`.
                             :form :epkg/deps))
         :_extra (s/* (nospec nil))))

;; Testing
;; (s/conform :epkg.multifile/reqs {:pname "magit" :dir "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/magit/lisp"})
;; (s/conform :epkg.multifile/reqs (edn/read-string (slurp "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/magit/lisp/magit-pkg.el")))
;; (s/explain-str :epkg.multifile/reqs (edn/read-string (slurp "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/magit/lisp/magit-pkg.el")))
;; (s/conform :epkg.multifile/reqs "asdf")
;; (s/conform :epkg.multifile/reqs (edn/read-string (slurp "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/drag-stuff.el/drag-stuff-pkg.el")))

;; TODO Might not need to test if file-exists for simple packages, is there always a packagename.el file? Or should always be one if there's no -pkg.el so its find to have it as a fallthrough case?
;; TODO maybe do coeffects if it's easy
;; Maybe see my now-deleted cofx attempts
(s/def :epkg/reqs->deps
  (s/or :multifile
        (s/and
         (s/conformer
          (fn [{:keys [pname dir]}]
            (let [f (str dir "/" pname "-pkg.el")]
              (if (file-exists? f)
                (-> f slurp edn/read-string)
                :clojure.alpha.spec/invalid))))
         :epkg.multifile/reqs
         (s/conformer #(get-in % [:requirements :form])))
        :simple
        (s/and
         (s/conformer
          (fn [{:keys [pname dir]}]
            (let [f (str dir "/" pname ".el")]
              (if (file-exists? f)
                (-> f slurp edn/read-string)
                :clojure.alpha.spec/invalid))))
         :epkg.simple/reqs
         (s/conformer :deps))))

(defn epkg-dependencies [name dir]
  (let [deps
        (s/conform
         (s/and
          :epkg/reqs->deps
          (s/conformer (fn [[_ reqs]] reqs))
          :epkg/deps->name-strs)
         {:pname name :dir dir})]
    (when-not (s/invalid? deps)
      deps)))

;; Testing
;; (epkg-dependencies "magit" "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/magit/lisp")
;; (println (epkg-dependencies "dash" "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/dash"))
;; (println (epkg-dependencies "helpful" "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/helpful"))
;; (println (epkg-dependencies "evil" "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/evil"))
;; (println (epkg-dependencies "drag-stuff" "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/drag-stuff.el"))
;; (println (slurp "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/evil/evil-pkg.el"))




(s/def ::forge-repo
  (s/and
   ::str->chars
   (s/cat :user-name (s/&
                      (s/+ char?)
                      ::chars->str)
          :slash #{\/}
          :repo-name (s/&
                      (s/+ char?)
                      ::chars->str))))

(s/def ::glob string?)

(s/def ::recipe-subdirective
  (s/alt :subdir string?
         :exclude #{:exclude}))

(s/def ::recipe-defaults #{:defaults})




; TODO better sha and ref specs
(s/def :git/sha string?)
(s/def :git/ref string?)

(s/def :melpa.recipe.files/element
  (s/alt :glob ::glob
         :sublist (s/nest
                   (s/cat :subdirective ::recipe-subdirective
                          :elements (s/+ :melpa.recipe.files/element)))))
(s/def :melpa.recipe/files
  (s/cat
   :defaults (s/? ::recipe-defaults)
   :elements (s/* :melpa.recipe.files/element)))

(s/def :melpa.recipe/name symbol?)
(s/def :melpa.recipe/fetcher #{git hg github gitlab})
(s/def :melpa.recipe.vc/url string?)
(s/def :melpa.recipe.forge/repo ::forge-repo)
;; TODO nb: "commit" is used only once in all of the melpa recipes. Do doom/straight even consider it?
(s/def :melpa.recipe.git/commit (s/or :git/sha
                                      :git/ref))
(s/def :melpa.recipe.git/branch string?) ; TODO do better spec? It can be a git or hg branch, right?
;; -- originial position of :melpa.recipe/files before I moved it up --
;; TODO nb: ignoring :version-regexp and :old-names, I don't care about them, right (straight doesn't seem to)? And I'm excluding from even this validation spec stuff I don't care about, right? Or just maybe spec them but do a `s/select` that doesn't include them (or use `nospec`)? Remember to add them to :melpa.recipe/schema.

(s/def :melpa.recipe/props
  (s/schema {;; :melpa.recipe/name
             :fetcher :melpa.recipe/fetcher
             :files :melpa.recipe/files}))

(s/def :melpa.recipe/vc-props
  (s/schema {:url :melpa.recipe.vc/url}))

(s/def :melpa.recipe/forge-props
  (s/schema {:repo :melpa.recipe.forge/repo}))

(s/def :melpa.recipe/git-props
  (s/schema {:commit :melpa.recipe.git/commit
             :branch :melpa.recipe.git/branch}))

(defmulti melpa-recipe-fetcher :fetcher)

(defmethod melpa-recipe-fetcher 'git [_]
  (s/select
   (s/union :melpa.recipe/props
            :melpa.recipe/vc-props
            :melpa.recipe/git-props)
   [:url]))
(defmethod melpa-recipe-fetcher 'hg [_]
  (s/select
   (s/union :melpa.recipe/props
            :melpa.recipe/vc-props)
   [:url]))
(defmethod melpa-recipe-fetcher 'github [_]
  (s/select
   (s/union :melpa.recipe/props
            :melpa.recipe/forge-props
            :melpa.recipe/git-props)
   [:repo]))
(defmethod melpa-recipe-fetcher 'gitlab [_]
  (s/select
   (s/union :melpa.recipe/props
            :melpa.recipe/forge-props
            :melpa.recipe/git-props)
   [:repo]))

(s/def :melpa/recipe
  (s/cat
   :name (nospec :melpa.recipe/name)
   :props
   (s/&
    (s/* :elisp/form)
    #(even? (count %))
    :elisp/plist->map
    (s/multi-spec melpa-recipe-fetcher :fetcher))))

;; Testing
;; (def test-melpa-recipe '(yasnippet :repo "joaotavora/yasnippet"
;;                                    :fetcher github
;;                                    :files ("yasnippet.el" "snippets")))
;; (s/conform :melpa/recipe test-melpa-recipe)
;; (s/explain-str :melpa/recipe test-melpa-recipe)



(s/def :straight.recipe-repo/name symbol?)

(s/def :straight.recipe/name symbol?) ; Maybe spec this so I can accept the argument to `straight-use-package` (for other users who use straight): doom doesn't take this just the rest of the recipe plist. Update: also need it for :includes.
(s/def :straight.recipe/local-repo string?)
;; TODO maybe some of the sub-stuff in :straight.recipe/files should be `nospec` or have leading keywork underscores.
(s/def :straight.recipe/files
  (s/*
   (s/alt :glob ::glob
          :pair (s/cat :car string?
                       :dot #{.}
                       :cdr string?)
          :sublist (s/nest
                    (s/cat :subdirective ::recipe-subdirective
                           :elements (s/+ :straight.recipe/files)))
          :defaults ::recipe-defaults)))
(s/def :straight.recipe/flavor #{melpa})
(s/def :straight.recipe/build any?) ; TODO. Had #{nil t}, it would be better to use :elisp/t but set specs take literal, not spec, values
(s/def :straight.recipe/pre-build any?) ; TODO
(s/def :straight.recipe/post-build any?) ; TODO
(s/def :straight.recipe/type #{git built-in})
(s/def :straight.recipe/source (s/or :one :straight.recipe-repo/name
                                     :many (s/coll-of :straight.recipe-repo/name)))
(s/def :straight.recipe/includes (s/or :one :straight.recipe/name
                                       :many (s/coll-of :straight.recipe/name)))
(s/def :straight.recipe/inherit :elisp/nil-or-non-nil)
(s/def :straight.recipe.git/host #{nil github gitlab bitbucket})
(s/def :straight.recipe.git/branch string?)
(s/def :straight.recipe.git/remote string?)
(s/def :straight.recipe.git/nonrecursive :elisp/nil-or-non-nil)
(s/def :straight.recipe.git/fork any?) ; TODO
(s/def :straight.recipe.git/depth (s/or :full #{full}
                                        :n integer?))
(s/def :straight.recipe.git/protocol #{https ssh})
(s/def :straight.recipe.git/upstream any?) ; TODO


(s/def :straight.recipe/props
  (s/schema {;; :straight.recipe/name
             :local-repo :straight.recipe/local-repo
             :files :straight.recipe/files
             :flavor :straight.recipe/flavor
             :build :straight.recipe/build
             :pre-build :straight.recipe/pre-build
             :post-build :straight.recipe/post-build
             :type :straight.recipe/type
             :source :straight.recipe/source
             :includes :straight.recipe/includes
             :inherit :straight.recipe/inherit}))

(s/def :straight.recipe/git-props
  (s/schema {;; :repo :straight.recipe.git/repo
             :host :straight.recipe.git/host
             :branch :straight.recipe.git/branch
             :remote :straight.recipe.git/remote
             :nonrecursive :straight.recipe.git/nonrecursive
             :fork :straight.recipe.git/fork
             :depth :straight.recipe.git/depth
             :protocol :straight.recipe.git/protocol
             :upstream :straight.recipe.git/upstream}))


(s/def :straight/repository-url string?)

(defmulti straight-recipe-git-host :host)

(defmethod straight-recipe-git-host nil [_]
  (s/select {:repo :straight/repository-url} [:repo]))
(defmethod straight-recipe-git-host 'github [_]
  (s/select {:repo ::forge-repo} [:repo]))
(defmethod straight-recipe-git-host 'gitlab [_]
  (s/select {:repo ::forge-repo} [:repo]))
(defmethod straight-recipe-git-host 'bitbucket [_]
  (s/select {:repo ::forge-repo} [:repo]))


(def straight-default-vc 'git)

(defmulti straight-recipe-type #(get % :type straight-default-vc))

(defmethod straight-recipe-type 'git [_]
  (s/and
   (s/union :straight.recipe/props
            :straight.recipe/git-props)
   (s/multi-spec straight-recipe-git-host :host)))
(defmethod straight-recipe-type 'built-in [_]
  (s/schema {}))


(s/def :straight.recipe/props-asdf
  (s/&
   (s/* :elisp/form)
   #(even? (count %))
   :elisp/plist->map
   (s/multi-spec straight-recipe-type :type)))

;; TODO I don't think I need this for anything
(s/def :straight/recipe
  (s/cat
   :name (nospec :straight.recipe/name)
   :props :straight.recipe/props-asdf))


(s/def :doom.package/name symbol?)
(s/def :doom.package/type #{core local built-in virtual}) ; Depending on where I'm doing "checking for stuff I explicitly don't support" either remove local/built-in/(maybe)virtual here or check for them elsewhere
(s/def :doom.package/recipe :straight.recipe/props-asdf)
(s/def :doom.package/disable :elisp/t)
(s/def :doom.package/ignore :elisp/t)
(s/def :doom.package/pin :git/sha)
;; TODO nb: not speccing :modules (for now?)

(s/def :doom.package/props
  (s/schema {:type :doom.package/type
             :recipe :doom.package/recipe
             :disable :doom.package/disable
             :ignore :doom.package/ignore
             :pin :doom.package/pin}))

(s/def :doom/package
  (s/cat
   :name :doom.package/name
   :props
   (s/&
    (s/* :elisp/form)
    #(even? (count %))
    :elisp/plist->map
    :doom.package/props)))


#_(defn parse-doom-packages []
  (as-> (slurp "/home/pharcosyle/work/phrenetic/doom-packaging/my-doom-packages.el") $
    (edn/read-string $)
    (map parse-doom-package $)
    ;; TODO later: this is Doom-specific, move it out of the main "guix-emacs-generator"
    (remove #(= (:package/name %) "straight") $)
    (remove :package/deactivated? $)))



(s/def ::todo any?)

;; (s/def :fex.repo/user-name ::todo)
;; (s/def :fex.repo/repo-name ::todo)
;; (s/def :fex/repo
;;   (s/schema [:fex.repo/user-name
;;              :fex.repo/repo-name]))

(s/def :fex.package/url ::todo)
;; (s/def :fex.package/forge #{:forge/github
;;                             :forge/gitlab
;;                             ;; :forge/bitbucket
;;                             })
;; (s/def :fex.package.forge/repo :fex/repo) ; TODO maybe just use :fex/repo or ::forge-repo (and make the current ::forge-repo be ::forge-repo-str or something)
(s/def :fex.package/branch ::todo)
(s/def :fex.package/nonrecursive? #{true})
(s/def :fex.package/files :melpa.recipe/files) ; TODO This is "inheritance", maybe make this a "shared" spec like ::recipe-defaults or just allow :melpa.recipe/files as a key in :fex/package (maybe even rename it to ::melpa-style-files or something)

(s/def :fex/package
  (s/schema [:fex.package/url
             ;; :fex.package/forge
             ;; :fex.package.forge/repo
             :fex.package/branch
             :fex.package/nonrecursive?
             :fex.package/files]))





(def ^:private forge-domains
  {'github "github.com"
   'gitlab "gitlab.com"
   'bitbucket "bitbucket.com"})

(defn forge-repo-url [forge user-name repo-name]
  (str "https://" (get forge-domains forge) "/" user-name "/" repo-name ".git"))


(require '[clojure.set :refer [rename-keys]])
(defn select-and-rename-keys [m kmap]
  (as-> m $
    (select-keys $ (keys kmap))
    (rename-keys $ kmap)))






(defmacro defkmultis [& methods]
  (let [create (fn [name]
                 `(defmulti ~name ~(fn [k & _] k)))]
    `(do
       ~@(map create methods))))

(defmacro defkmethods [k & methods]
  (let [register
        (fn [[name argslist & body]]
          `(defmethod ~name ~k ~(vec (cons '_ argslist)) ~@body))]
    `(do
       ~@(map register methods))))





;; Archives
(defkmultis
  ;; has-recipe
  get-recipe) ; TODO maybe rename this get-package or something, I'm returning fex packages, not straight/melpa recipes


(defn gnu-elpa-mirror-recipe-filename [p]
  (str "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/gnu-elpa-mirror" "/" p))

(defkmethods
  :archive/gnu-elpa-mirror
  (get-recipe [p] (let [f (gnu-elpa-mirror-recipe-filename p)]
                    ;; TODO straight checks against straight-recipes-gnu-elpa-ignored-packages for this archive, I might need to do that too. There are other notes on this already.
                    (when (file-exists? f)
                      {:fex.package/url (forge-repo-url
                                         (symbol :github) "emacs-straight" p)
                       :fex.package/files {:elements [[:glob "*"]]}})))) ; TODO straight also has ~(:exclude ".git")~ here but I don't think I need that.

(defn melpa-recipe-filename [p]
  (str "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/melpa/recipes" "/" p))

(defkmethods
  :archive/melpa
  ;; (has-recipe [p] (file-exists? (melpa-recipe-filename p)))
  (get-recipe [p] (let [f (melpa-recipe-filename p)]
                    (when (file-exists? f)
                      (let [text (slurp f)
                            parsed
                            (s/conform (s/and
                                        ::str->edn
                                        :melpa/recipe
                                        (s/conformer :props))
                                       text)]
                        ;; TODO check that `parsed` is not invalid?
                        ;; TODO "supported"-ness: this might be the place to check that the melpa recipe fetcher isn't 'hg. Alternatively, or perhaps preferably (it would match straight's behavior) just report there's no package if the fetcher is 'hg (or isn't 'git, 'github, or 'gitlab)
                        ;; TODO additional things straight does for this archive: adds -pkg.el to :files and sets flavor to melpa. Donno if I need these. There are other todos/notes on these already
                        (merge
                         {:fex.package/url (let [fetcher (:fetcher parsed)]
                                             (condp some #{fetcher}
                                               #{'git} (:url parsed)
                                               #{'github 'gitlab} (let [repo (:repo parsed)]
                                                                    (forge-repo-url
                                                                     fetcher
                                                                     (:user-name repo)
                                                                     (:repo-name repo)))))}
                         (select-and-rename-keys
                          parsed {:branch :fex.package/branch
                                  :files :fex.package/files})
                         ;; TODO not using, remove
                         ;; (when-let [files (:files parsed)]
                         ;;   {:fex.package/files (s/unform :melpa.recipe/files files)})
                         ))))))

;; Testing
;; (get-recipe :archive/melpa "yasnippet")

;; TODO I don't think the lisp/* bits are necessary since these already have :defaults but for now I've copied the :files over just like they are in straight.
(defkmethods
  :archive/org-elpa
  (get-recipe [p] (case p
                    "org"
                    {:fex.package/url "https://git.savannah.gnu.org/git/emacs/org-mode.git"
                     :fex.package/files {:defaults :defaults
                                         :elements [[:glob "lisp/*.el"]
                                                    [:sublist
                                                     {:subdirective [:subdir "etc/styles/"]
                                                      :elements [[:glob "etc/styles/*"]]}]]}}
                    "org-contrib"
                    {:fex.package/url "https://git.sr.ht/~bzg/org-contrib"
                     :fex.package/files {:defaults :defaults
                                         :elements [[:glob "lisp/*.el"]]}}
                    nil)))


;; TODO make this configurable (of course) and probably not global (pass it as an argument to functions that use it)
(def archives [:archive/org-elpa
               :archive/melpa
               :archive/gnu-elpa-mirror])

;; TODO probably add emacsmirror, etc archives but make all of the methods throw an exception stating that they're not implemented "yet".
;; (def archive-priority [:archive/org-elpa
;;                        :archive/melpa
;;                        :archive/gnu-elpa-mirror])

;; TODO maybe a way to get these from Doom programatically is to advise `straight-use-recipes` but then I'd have to run `doom--ensure-straight` as well
;; (def doom-recipe-repos
;;   '((org-elpa :local-repo nil)
;;     (melpa              :type git :host github
;;                         :repo "melpa/melpa"
;;                         :build nil)
;;     (gnu-elpa-mirror    :type git :host github
;;                         :repo "emacs-straight/gnu-elpa-mirror"
;;                         :build nil)
;;     (el-get             :type git :host github
;;                         :repo "dimitri/el-get"
;;                         :build nil)
;;     (emacsmirror-mirror :type git :host github
;;                         :repo "emacs-straight/emacsmirror-mirror"
;;                         :build nil)))
;; (def doom-straight-recipe-repositories
;;   '(org-elpa melpa gnu-elpa-mirror el-get emacsmirror-mirror))




(require '[clojure.java.shell :refer [sh]])
(def eb-dir "/home/pharcosyle/work/phrenetic/phrenetic")
(def guix-repl-cmd ["guix" "repl" "-L" "." "--" "phrenetic/packaging-runner.scm"])
(defn sh-call [f & args]
  (apply sh (concat guix-repl-cmd
                    [(name f)]
                    (map pr-str args)
                    [:dir eb-dir])))
;; (sh-call :guix/asdf 6)
(def get-origin-data (partial sh-call :guix/get-origin-data))







(defn get-archive-package [archives package-name]
  (first (map #(get-recipe % package-name) archives)))

(defn package-with-inheritance [package-name package]
  (merge
   (get-archive-package package-name)
   package))






(defn convert-straight-recipe-props-to-package [props]
  (let [; parsed (s/conform :straight.recipe/props-asdf props)
        parsed props]
    ;; TODO check that `parsed` is not invalid?
    ;; TODO "supported"-ness: is this the place to check that there aren't unsupported keys and provided keys have supported values (including that the :files is a valid /melpa/ :files)?
    (merge
     {:fex.package/url
      (let [{:keys [host repo]} parsed]
        (if host
          (forge-repo-url
           host
           (:user-name repo)
           (:repo-name repo))
          repo))}
     (select-and-rename-keys
      parsed {:branch :fex.package/branch})
     (when (:nonrecursive parsed)
       {:fex.package/nonrecursive? true})
     (when-let [files (:files parsed)]
       ;; TODO donno why I want to do it this convoluted way, maybe because I don't want to use the "raw" props?
       {:fex.package/files
        ;; (s/conform :melpa.recipe/files props)
        (->> files
             (s/unform :straight.recipe/files)
             (s/conform :melpa.recipe/files))}))))




;; (def my-doom-packages-test "/home/pharcosyle/work/phrenetic/doom-packaging/my-doom-packages.el")
;; (def my-doom-packages-test "/home/pharcosyle/work/phrenetic/doom-packaging/my-doom-packages-edited.el")
(def my-doom-packages-test "/home/pharcosyle/work/phrenetic/doom-packaging/my-doom-packages-small.el")

(defn test-packages []
  (let [data (-> my-doom-packages-test
                 slurp
                 edn/read-string)
        conformed (s/conform (s/coll-of :doom/package) data)]
    ;; (s/explain (s/coll-of :doom/package) data)
    (as-> conformed $
      (map #(get-in % [:props :recipe]) $)
      (map convert-straight-recipe-props-to-package $))))

;; (test-packages)





(def straight-allow-recipe-inheritance? true)

;; TODO Ideally I think I want to grab any pertinent straight settings from Doom Emacs
;; By serializing them "in the same run" as when I grab e.g `doom-packages`. Update: but wait I won't have straight installed when I do this, perhaps scrape the straight code for sexps or maybe it'll be enough to just get the ones that Doom sets itself (see core-packages.el line 78-97)
;; - default protocol, allow inheritance, the recipe repos Doom sets up, etc
;; - straight-default-vc
;; - look through straight's ~defcustom~s
(def defaults {:recipe/protocol "https"})
;; maybe?:
;; :files '("*.el" "*.el.in" "dir"
;;          "*.info" "*.texi" "*.texinfo"
;;          "doc/dir" "doc/*.info" "doc/*.texi" "doc/*.texinfo" "lisp/*.el"
;;          (:exclude ".dir-locals.el" "test.el" "tests.el" "*-test.el" "*-tests.el")

;; TODO regarding :flavor: read `straight-expand-files-directive' and see if I need this / what I should do about :files. Also read the melpa readme about the rules it has for expanding its :files property
;; - :melpa/recipe shouldn't have a flavor, right? Just straight recipes?
;; - new thoughts
;;   - I might need it to make sure template files are copied over "before build", does that make sense I can't be fucked to think through the ordering at present
;;   - If I do need to consider .el.in files perhaps I can prepreocess the :fex.package/files returned from the melpa archive (but that might not be feasable, the .el.in logic is deep in the melpa/straight files expansion logic)
;;   - The Guix elpa importer doesn't even consider .el.in files, maybe they're super rare
;;   - nb: straight recipe inheritance logic includes :flavor and I'm not presently doing that
;;   - reconcile the Guix elpa importer's file expansion logc with melpa's to make sure it's thorough (not straight's, it's different, but do look it over afterwards anyway)
;; TODO downloading to a cache like the elpa importer does would speed up successive/reattempted runs, no?
;; - assuming that is what it's doing (check). Do those repo caches stick around forever though? Will adding my own interfere with anything?
;; - if it's /really/ fast maybe I could get rid of the later-to-come bump "scripts"'s need to read an existing list of generated packges at all! I wouldn't even have to save it to disk, just the lockfile!
;;   - even if the guix git repositories cache thing is untenable maybe there's some other cache I could write the repos or the generated packages-with-hashes to, even just ~./cache. I'd like to not have to manage a generated packages file if I don't have to
;; TODO handle :host: search "bitbucket" in straight to see stuff that affects hosts. If necessary add a check to make sure a supported host is provided.
;; TODO use value of `straight-built-in-pseudo-packages' (let-alist emacs nadvice python) in addition to elpa.scm's `emacs-standard-library?'? What about `straight-recipes-gnu-elpa-ignored-packages'? What about straight--package-built-in-p and package--builtins (read its doc)?
;; - Straight claims to be able to "deal with built-in packages" even without this variable. How? Something like hlissner does when :built-in is set to 'prefer? Use one
;;   of these approaches instead of making a (brittle) list of built-in pseudo packages?
;; - Remember, sometimes even if a package is built-in it should still be installed (like org)
;; - unrelated: are there any built-in dependencies with newer upstream/external versions? Do I want them?
;;   Perhaps not even proper versions just newer commits in a git repo
;; TODO always include *pkg.el like straight.el::3168 says?
;; Is that just about making sure that dependencies get resolved? It says "linked over" though. But then why wouldn't the other `straight-recipes-REPO-retrieve' methods have it? For
;; the elpa one at least it could be because it includes everything (=:files "*"=)
;; - also see the github melpa readme: "For multi-file packages, the file <NAME>-pkg.el is automatically generated..."
;; - update: shit is the /built/ package (after the :files directive has been "applied", among other things) used for determining dependencies? That's the way straight does it, I was just going to use the "raw" cloned repo to find dependencies. Note that e.g. ghub, magit-secion have their -pkg.el files in a subfolder so assuming -pkg.el lives in the root of the unbuilt repo isn't going to work the way I have it now. Conceivably the same could be true of a regular packagename.el file: it could be in a subdirectory.
;;   - I'll probably have to build the package before I get dependencies like straight does. Is there anything else about building the package, besides doing the :files copying/linking, that could affect the packagename.el and packagename-pkg.el files and thus dependency resolution?
;; TODO do I actually need :includes / consider the org-elpa pseudo repository (look at straight-recipes-org-elpa-retrieve in particular)
;; I think the Doom package declarations of org/org-contrib are inheriting from org-elpa and all that stuff it does with :includes and maybe other stuff /does/ matter?
;; - how does Guix handle org? One package, multiple?
;; TODO consider `straight--convert-recipe'
;; TODO consider straight-built-in-pseudo-packages
;; esp. in straight--convert-recipe
;; TODO consider how straight.el recipe inheritance works
;; esp. in straight--convert-recipe

;; TODO hack
;; Wait to do this until the end when I have a concrete idea of all the stuff I'll have to read (doom packages, melpa recipes...) and how I want to do it.
;; Ideas:
;; - hack scm/edn.scm somehow?
;; - convert `doom-packages` (and melpa recipes) package names to strings on the elisp side
;;   Would be messy with melpa recipes since there's no "elisp-reading phase"
;; - elisp "parseclj"/"parseedn" are nice but they don't solve the 0x0 problem
;;   Are they worth the additional overhead of running them on the elisp side? Again, with melpa there might not /be/ an elisp side
;;   - nice to have but maybe not necessary: handling dotted pairs, t/nil become true/nil
;; - don't use the 0x0 package
(defn icky [x]
  (if (= x "0")
    "0x0" x))

;; TODO probably do this with spec, but wait until a bit later / the end
;; (if-let [unsupported (seq (filter (fn [p]
;;                                       (or (let [type (get p :doom.package/type)]
;;                                             (some (hash-set type) (vector :doom.package.type/local :doom.package.type/built-in)))
;;                                           (let [vc (get-in p (vector :package/recipe :recipe/vc))]
;;                                             (and vc (not= vc :vc/git)))
;;                                           (get-in p (vector :package/recipe :straight.recipe/protocol))
;;                                           (get-in p (vector :package/recipe :straight.recipe/source))
;;                                           (get-in p (vector :package/recipe :straight.recipe/fork))
;;                                           (get-in p (vector :package/recipe :straight.recipe/upstream))
;;                                           (get-in p (vector :package/recipe :straight.recipe/includes))))
;;                                   $))]
;;         (throw (ex-info "Package(s) with unsupported configuration" {:packages unsupported}))
;;         $)
;; TODO NEW stuff I've decided I'm /definitely/ not supporting: fork, source
;; - don't support :build. (At leat for values other than 't, which is harmless and which Doom's org package declaration uses. Maybe just override the Doom org package like I'm going to do for its :pre-build)
;; - don't support :pre-build/:post-build (Doom's org and notmuch packages use :pre-build though, so find probably override those recipes to not have :pre-build steps and make sure the Guix packages for them do what the :pre-build steps would have done).
;; - probably not supporting manually-set inherit property (and straight-allow-recipe-inheritance must be true)
;; - list of straight package props Doom actually uses
;;   host
;;   repo
;;   files
;;   nonrecursive
;;   branch
;;   local-repo
;;   - Only straight has this and it doesn't matter for me
;;   build
;;   - only org (:build t)
;;   pre-build
;;   - only org and notmuch
;;   depth
;;   - only org (:depth 1)
;; - spec that both host and repo must be specified so in inheritance one isn't overridden without the other?
#+end_src
******** deps
Had =:tangle phrenetic/deps.edn :comments link=
#+begin_src clojure :tangle no
{:paths ["src" "resources"]
 :deps {org.clojure/clojure {:mvn/version "1.11.1"}
        org.clojure/alpha.spec {:git/url "https://github.com/clojure/spec-alpha2.git"
                                :sha "99456b1856a6fd934e2c30b17920bd790dd81775"}
        babashka/fs {:mvn/version "0.1.6"}}
 :aliases
 {:run-m {:main-opts ["-m" "protostar.hickeyland"]}
  :run-x {:ns-default protostar.hickeyland
          :exec-fn greet
          :exec-args {:name "Clojure"}}
  :build {:deps {io.github.seancorfield/build-clj
                 {:git/tag "v0.6.3" :git/sha "9b8e09b"
                  ;; since we're building an app uberjar, we do not
                  ;; need deps-deploy for clojars.org deployment:
                  :deps/root "slim"}}
          :ns-default build}
  :test {:extra-paths ["test"]
         :extra-deps {org.clojure/test.check {:mvn/version "1.1.1"}
                      io.github.cognitect-labs/test-runner
                      {:git/tag "v0.5.0" :git/sha "48c3c67"}}}}}
#+end_src
******* guix part
Had =:tangle phrenetic/lokke/ns/phrenetic/packaging-wip.clj :comments link=
#+begin_src clojure :tangle no
(ns phrenetic.packaging-wip
  (:require [guile :refer [command-line]]
            [guile.guix.base32 :refer [bytevector->nix-base32-string]]
            [guile.guix.git :refer [latest-repository-commit]]
            [guile.guix.hash :refer [file-hash*]]
            [guile.guix.store :refer [with-store]]
            [guile.srfi.srfi-11 :as srfi-11]

            [guile.guix.build-system.emacs :refer [emacs-build-system]]
            [guile.guix.git-download :refer [git-fetch git-reference git-file-name]]
            [guile.guix.packages :refer [package origin content-hash]]))

(defn- pair [a b]
  (guile/cons a b))

(defmacro let-values [bindings & body]
  (let [bindings*
        (->> bindings
             (partition 2)
             (map (fn [[names expr]]
                    (list
                     (apply list names) expr))))]
    `(srfi-11/let-values ~bindings*
       ~@body)))

(defn- download-git-repo! [url [ref' ref''] recursive?]
  (let-values
   [[dir commit]
    (with-store store
      (latest-repository-commit store url
                                :ref (pair (symbol ref') ref'')
                                :recursive? recursive?))]
   {:dir dir :commit commit}))

;; (println
;;  (download-git-repo! "https://github.com/raxod502/straight.el.git" [:branch "develop"] false))
;; (println
;;  (download-git-repo! "https://github.com/minad/consult.git" '()))

(defn get-origin-data [url ref recursive?]
  (let [{:keys [dir commit]} (download-git-repo! url ref recursive?)]
   {:commit commit
    :hash (bytevector->nix-base32-string
           (file-hash* dir))}))

;; (println
;;  (get-origin-data "https://github.com/raxod502/straight.el.git" [:branch "develop"] false))





(defn fex-package [package-name url commit recursive? hash]
  (package
   (name (str "emacs-" package-name))
   (version "0.0.1")
   (source
    (origin
     (method git-fetch)
     (uri (git-reference
           (url url)
           (commit commit)
           (recursive? recursive?)))
     (file-name (git-file-name name version))
     (hash
      (content-hash hash))))
   (build-system emacs-build-system)
   ;; (arguments
   ;;  `(#:phases
   ;;    (modify-phases %standard-phases
   ;;      (add-after 'unpack 'move-source-files
   ;;        (lambda _
   ;;          (let ((el-files (find-files "./extensions" ".*\\.el$")))
   ;;            (for-each (lambda (f)
   ;;                        (rename-file f (basename f)))
   ;;                      el-files)))))))
   ;; (native-inputs
   ;;  (list texinfo))
   (home-page nil)
   (synopsis nil)
   (description nil)
   (license nil)))

;; (println
;;  (fex-package "tldr"
;;               "https://github.com/kuanyui/tldr.el"
;;               "7203d1be3dcbf12131846ffe06601933fa874d74"
;;               nil
;;               "1bw6la463l2yfm7rp76ga4makfy4kpxgwi7ni5gxk31w11g26ryk"))




;; (defn call [nm & args]
;;   (let [f (ns-resolve *ns* (symbol nm))]
;;     (apply f args)))

(defn asdf [n]
  (+ 1 n))

(when (< (count (command-line)) 1) ; temporarily let me run this file manually
  (let [f (-> (command-line) second)
        args (-> (command-line) next next)]
    (println
     (let [func
           (case f
             "asdf" asdf)]
       (apply func (map read-string args))))))
#+end_src
******* packaging runner
Had =:tangle (meta-in-dir "packaging-runner.scm")=
#+begin_src scheme :tangle no
(use-modules (lokke ns))
(require #(phrenetic.packaging-wip))
#+end_src
******* test clj
Had =:tangle phrenetic/lokke/ns/phrenetic/test-clj.clj :comments link=
#+begin_src clojure :tangle no
(ns phrenetic.test-clj
  (:require [guile.guix.gexp :as g]
            [guile.guix.packages :refer [package package-description]]))

(println
 (gexp "asdf"))

;; (println
;;  (p/package (name "asdf")))

;; (println
;;  (package-description
;;   (package
;;     (name "asdf")
;;     (version "0")
;;     (source nil)
;;     (build-system nil)
;;     (synopsis "asdf")
;;     (description "asdf3333")
;;     (home-page nil)
;;     (license nil))))

(+ 1 1)
(println 5)

#+end_src
******* test scm
Had =tangle (meta-in-dir "test-scm.scm")=
#+begin_src scheme :tangle no
(use-modules (lokke ns))
(require #(phrenetic.test-clj))
#+end_src
******* elisp
Had =:tangle (meta-in-dir "parse-doom-packages.el")=
- [2022-09-11 Sun] nb: I removed the global lexical arg to emacs-lisp code blocks. Probably doesn't matter.
#+begin_src emacs-lisp :tangle no
(defun m-slurp (f)
  (with-temp-buffer
    (insert-file-contents f)
    (buffer-string)))

(defun m-spit (f content)
  (with-temp-file f
    (insert content)))




(defun m-process ()
  (-as-> (m-slurp "~/work/phrenetic/doom-packaging/my-doom-packages.el") $
         (read $)
         (-map #'-first-item $)
         (-map #'symbol-name $)))

(defun write-doom-pkgs-txt ()
  (m-spit "doom-packaging/guix-doom-emacs-packages.txt"
          (pp (m-process))))





(defun repo-commit (r)
  (let ((default-directory (concat "~/.local/var/lib/doom-local/straight/repos/" r)))
    (straight--process-output "git" "rev-parse" "HEAD")))

(defun write-current-commits ()
  (let ((pkgs-to-repos
         (-map
          (lambda (x)
            (cons
             (-first-item x)
             (-as-> x $
                    (-fourth-item $)
                    (plist-get $ :local-repo))))
          (map-into straight--build-cache 'list))))
    (-map (lambda (x)
            (cons (car x)
                  (if-let ((y (cdr x)))
                      (if (not (equal y "/home/pharcosyle/work/dotfiles/donnager"))
                          (repo-commit y)
                        nil)
                    y)))
          pkgs-to-repos)))

;; (write-current-commits)
#+end_src
**** Doom services
***** Core
#+begin_src scheme
(define* (doom-core #:key
                    stateless?
                    evil?
                    icons?
                    email)
  (append
   (doom-general #:stateless? stateless?
                 #:evil? evil?
                 #:icons? icons?)
   (doom-user #:email email)
   (doom-keymaps)
   (doom-undo #:stateless? stateless?)
   (doom-emacs-lisp)
   (doom-markdown)))
#+end_src
****** General :bindings:
#+begin_src scheme
(define* (doom-general #:key
                       stateless?
                       evil?
                       icons?
                       (childframe? #t))
  (let ((name 'general))
    (cons
     (doom-service
      name
      #:modules
      `((#:completion
         (company ,@(if childframe? '(+childframe) '()))
         (vertico ,@(if icons? '(+icons) '())))

        (#:ui
         doom
         doom-dashboard
         (emoji +unicode)
         hl-todo
         hydra
         indent-guides
         ;; (ligatures +extra)
         modeline
         nav-flash
         ophints
         (popup +defaults +all)
         treemacs
         vi-tilde-fringe
         window-select
         workspaces
         zen)

        (#:editor
         ,@(if evil? '((evil +everywhere)) '())
         file-templates
         fold
         format
         lispy
         multiple-cursors
         rotate-text
         snippets
         word-wrap)

        (#:emacs
         electric
         (ibuffer ,@(if icons? '(+icons) '())))

        (#:checkers
         (syntax ,@(if childframe? '(+childframe) '())))

        (#:tools
         (eval +overlay)
         lookup
         (pass +auth)
         pdf
         prodigy
         rgb
         taskrunner)

        (#:config
         (default +bindings +smartparens)))

      #:packages
      '((package! expand-region :pin "c5c4362741deebb0985a8a29f9b8b0e25160764a")
        (package! tldr :pin "d3fd2a809a266c005915026799121c78e8b358f0")
        ;; (package! 0x0 :pin "63cd5eccc85e527f28e1acc89502a53245000428") ; TODO `elisp-serialize' makes the `0x0' into `#{0x0}#'.
        )

      #:config
      (append
       '((setq scroll-margin 10
               save-interprogram-paste-before-kill t)

         ;; I like having line numbers on but hlissner says they're slow so I might want to disable them at some point. Keep in mind I use them to determine what lines are continuation lines so I might have to make the right fringe bigger if I do this and set visual-line-fringe-indicators.
         ;; (setq display-line-numbers-type nil)

         (setq-default indent-tabs-mode t) ; Doom sets this to nil, reset it.

         ;; I'd like to have this on but in the Doom code it says it's more efficient not to.
         ;; (setq-default cursor-in-non-selected-windows t)

         (after! bookmark
                 (setq bookmark-save-flag 1))

         (after! doom-modeline
                 ;; (setq doom-modeline-checker-simple-format nil)
                 (setq doom-modeline-major-mode-icon t)
                 (setq doom-modeline-persp-name t))

         (use-package! highlight-indent-guides
                       :defer t
                       :init
                       ;; I don't want indent guides on by default, remove all the Doom module's hooks.
                       (remove-hook! '(prog-mode-hook
                                       text-mode-hook
                                       conf-mode-hook)
                                     #'highlight-indent-guides-mode))

         (use-package! lispy
                       :defer t
                       :init
                       ;; Not using lispy, remove all the Doom module's hooks.
                       (remove-hook! '(lisp-mode-hook
                                       emacs-lisp-mode-hook
                                       ielm-mode-hook
                                       scheme-mode-hook
                                       racket-mode-hook
                                       hy-mode-hook
                                       lfe-mode-hook
                                       dune-mode-hook
                                       clojure-mode-hook
                                       fennel-mode-hook)
                                     #'lispy-mode)
                       (remove-hook! 'eval-expression-minibuffer-setup-hook #'doom-init-lispy-in-eval-expression-h))

         (use-package! lispyville
                       :hook (prog-mode . lispyville-mode)
                       :init
                       (setq lispyville-key-theme nil) ; Prevent Doom module's invocation of `lispyville-set-key-theme' from doing anything.
                       :config
                       (lispyville-set-key-theme
                        '(operators
                          c-w
                          c-u
                          commentary))
                       (map! :map lispyville-mode-map
                             "C-s-j" #'lispyville-beginning-of-next-defun
                             "C-s-k" #'lispyville-beginning-of-defun
                             "C-s-," #'lispyville-end-of-defun
                             "C-s-a" #'lispyville-drag-backward
                             "C-s-g" #'lispyville-drag-forward
                             "C-s-p" #'lispyville-prettify
                             (:prefix "C-s-;"
                              "R" #'lispyville-raise-list)))

         (use-package! expand-region
                       :defer t
                       :init
                       (map! :nv "s-e" #'er/expand-region
                             :nv "s-E" #'er/contract-region)
                       :config
                       (setq expand-region-fast-keys-enabled nil) ; My mapping is conventient enough and I don't want the repeat key to conflict with anything.
                       ;; Copied from Doom config: ~/.config/emacs/modules/config/default/+emacs.el:12
                       (defadvice! biome--quit-expand-region-a (&rest _)
                         "Properly abort an expand-region region."
                         :before '(evil-escape doom/escape) ; TODO `evil-escape': maybe gate with `evil?'
                         (when (memq last-command '(er/expand-region er/contract-region))
                           (er/contract-region 0))))

         ;; REVIEW Trying out not having this so I can use avy dispatch commands.
         ;; (after! avy
         ;;   (setq avy-single-candidate-jump t))

         (after! paren
                 (setq! show-paren-delay 0))

         (add-hook! 'prog-mode-hook #'biome-sp-strict-h)

         (after! rainbow-delimiters
                 ;; Doom sets this to 4 for possible performance reasons. I like having more (and 9 is the rainbow-delimiters default). The Doom base theme defines 9 too so this should look okay on most themes (though if they define their own faces there might be some duplication/clash where their definitions stop and the base theme's start).
                 (setq rainbow-delimiters-max-face-count 9))

         (after! recentf
                 (setq recentf-max-saved-items 500))

         (after! smartparens
                 (map! :map smartparens-mode-map
                       "C-s-h" #'sp-backward-sexp
                       "C-s-l" #'sp-forward-sexp
                       "C-s-u" #'sp-backward-up-sexp
                       "C-s-o" #'sp-up-sexp
                       :gn "C-s-m" #'sp-backward-down-sexp ; Bind in normal mode explicitly to override the Doom mapping in ~/.config/emacs/modules/config/default/config.el:447
                       "C-s-." #'sp-down-sexp
                       "C-s-c" #'sp-splice-sexp
                       "C-s-s" #'sp-splice-sexp-killing-backward
                       "C-s-f" #'sp-splice-sexp-killing-forward
                       "C-s-x" #'sp-backward-slurp-sexp
                       "C-s-v" #'sp-forward-slurp-sexp
                       "C-s-w" #'sp-backward-barf-sexp
                       "C-s-r" #'sp-forward-barf-sexp
                       (:prefix "C-s-;"
                        "(" #'sp-wrap-round
                        "[" #'sp-wrap-square
                        "{" #'sp-wrap-curly
                        "s" #'sp-split-sexp
                        "j" #'sp-join-sexp
                        "r" #'sp-raise-sexp
                        "c" #'sp-convolute-sexp
                        "w" #'sp-rewrap-sexp)))

         (defun biome-sp-strict-h ()
           (add-hook! 'smartparens-enabled-hook :local
                      #'turn-on-smartparens-strict-mode
                      (defun biome-modify-sp-strict-mode-map-h ()
                        (map! :map smartparens-strict-mode-map
                              :i "DEL" #'sp-backward-delete-char)))))

       (if evil?
           '((after! evil
                     (map! :m (vector 'C-i) nil)) ; Remove Doom's binding for `evil-jump-forward'.

             (after! evil-multiedit
                     (setq evil-multiedit-follow-matches t)))
           '())

       (wip-config)))

     (if stateless?
         (list
          (doom-service
           'bookmarks-indirection
           #:config
           ;; The Emacs bookmark package checks the modification time of the bookmarks file and offers to reload it if it changed. In the stateless case the file is a symlink and it's modified on every reconfigure (the symlink is recreated). This both breaks the funcationality (it should be checking the target file, not the symlink) and ressults in annoying prompts on reconfigure.
           '((after! bookmark
                     (setq bookmark-default-file (concat doom-data-dir "bookmarks/bookmarks")))))

          (doom-stateless-service
           name
           #:state '(((#:path . ("autosave/" #:doom-base #:cache))
                      (#:storage . #:machine))
                     ((#:path . ("bookmarks/" #:doom-base #:data))
                      (#:storage . #:persist))
                     ((#:path . ("recentf" #:doom-base #:cache))
                      (#:storage . #:persist))
                     ((#:path . ("savehist" #:doom-base #:cache))
                      (#:storage . #:persist))
                     ((#:path . ("saveplace" #:doom-base #:cache))
                      (#:storage . #:persist))
                     ((#:path . ("tramp" #:doom-base #:cache))
                      (#:storage . #:machine))
                     ((#:path . ("tramp-autosave/" #:doom-base #:cache))
                      (#:storage . #:machine))

                     ((#:path . ("scratch/" #:doom-base #:data))
                      (#:storage . #:persist))

                     ((#:path . ("projectile.projects" #:doom-base #:cache))
                      (#:storage . #:persist))
                     ((#:path . ("projectile.cache" #:doom-base #:cache))
                      (#:storage . #:machine))

                     ((#:path . ("workspaces/" #:doom-base #:data))
                      (#:storage . #:machine)))))
         '()))))



;; TODO WIP. Some of this stuff belongs in other components or gated.

(define (wip-config)
  '((after! emojify
            (setq emojify-display-style 'unicode))

    ;; TODO donno where this should go, ~+default-minibuffer-maps~ is a doom thing I guess
    (define-key! :keymaps +default-minibuffer-maps
      "s-J" #'scroll-up-command
      "s-K" #'scroll-down-command)

    ;; I don't think I'll ever need this with Sway. Is it worth keeping this and having an "I'm not on Sway / some WM" conditional around it?
    ;; (add-to-list 'initial-frame-alist '(fullscreen . fullboth))

    (map! "s-&" (lambda (command)
                  (interactive (list (read-shell-command "$ ")))
                  (call-process-shell-command command nil 0 nil)))

    (map! :leader
          "s-," (lookup-key doom-leader-map (kbd "<")))

    (after! company
            (map! :map company-active-map
                  "s-[" #'company-show-doc-buffer ; Currently opens Help, it would be better if I made it use Helpful.
                  "s-]" #'company-show-location))

    (after! evil-org
            (map! :map evil-org-mode-map
                  (:prefix "g"
                   :nv "{" #'evil-backward-paragraph
                   :nv "}" #'evil-forward-paragraph)))

    ;; Doesn't work yet: you have to switch to the buffer "manually" once before it starts being treated as real
    (map! "s-d m" (cmd! (doom-set-buffer-real (current-buffer) t)))

    ;; `forward-char' in original definition is messing things up, do this for now
    ;; (defun +eshell/search-history ()
    ;;   (interactive)
    ;;   (consult-history))
    (after! esh-mode
            (map! :map eshell-mode-map
                  "C-s" #'consult-history))

    (after! vertico
            (setq vertico-count 20  ; Trying out, maybe too big.
                  vertico-scroll-margin 7))

    (map! (:leader
           "A" #'embark-dwim)
          ;; Trying out cycling (temp)
          "C-:" #'embark-act
          "s-q" #'embark-cycle)

    ;; REVIEW Might be useful if there end up being a lot more of these and they have a lot of similarities: https://www.gnu.org/software/emacs/manual/html_node/elisp/Extending-Rx.html
    ;; TODO `better-jumper-jump-backward' doesn't consider these buffers, that's probably not a problem with `doom-real-buffer-functions' but rather something I have to do specially for it.
    (use-package! s)
    (add-hook! 'doom-real-buffer-functions
               ;; (defun biome-new-buffer-p (buf)
               ;;   (s-matches?
               ;;    (rx bol "*new*"
               ;;        (* "<" (+ digit) ">")
               ;;        eol)
               ;;    (buffer-name buf)))
               ;; TODO This should be in my Org config section / module but wait to move it until I'm confident I'll be continuing with this marking-buffers-as-real approach.
               (defun biome-org-src-edit-buffer-p (buf)
                 (s-matches?
                  (rx bol "*Org Src " (+ anything) "*"
                      (* "<" (+ digit) ">")
                      eol)
                  (buffer-name buf))))

    ;;  TODO Might be easier to do this with file-local variables.
    ;; (setq biome--phrenetic-dir "~/work/phrenetic")
    ;; (add-hook! 'org-mode-hook
    ;;   (defun biome-add-org-autotangle-after-save-hook-h ()
    ;;     (add-hook! 'after-save-hook :local
    ;;       (defun biome-autotangle-h ()
    ;;         (when (file-in-directory-p buffer-file-name biome--phrenetic-dir)
    ;;           ;; TODO ensure there aren't files in the output directory that no longer correspond to the org file. Just wipe it?
    ;;           (let ((org-confirm-babel-evaluate nil))
    ;;             (org-babel-tangle)))))))

    ;; (use-package! org-tanglesync
    ;;   :hook ((org-mode . org-tanglesync-mode)
    ;;          ((prog-mode text-mode) . org-tanglesync-watch-mode))
    ;;   :config
    ;;   (setq org-tanglesync-watch-files '("/home/pharcosyle/work/phrenetic/phrenetic.org")))

    ;; Maybe `s-S' to save-and-tangle? If I don't get some sort of auto-tangling thing going
    ;; - maybe it could be "save and eval defun (C-M-x)" in lisp/programming modes?'
    ;; Maybe a hotkey that just jumps back and forth between my most recently focused browser window and eemacs?
    ;; Maybe bind `s-o' in `consult-buffer' to "close consult-buffer and open +vertico/switch-workspace-buffer"

    (map! "s-o" (lookup-key doom-leader-map (kbd "<")))
    ;; Get rid of binding for =s-r=?
    (map! "s-r" nil)

    ;; Also messes with my sexp-movement bindings
    ;; (map! "C-s-j" #'evil-scroll-down
    ;;       "C-s-k" #'evil-scroll-up)

    (after! evil
            (map! :map evil-motion-state-map
                  ;; Maybe "C-s-o" but then I'll have to change my sexp-movement command(s). There are other bindings for jump-forward though, maybe I'll just use those.
                  "C-S-o" #'evil-jump-forward))))
#+end_src
****** User
#+begin_src scheme
(define* (doom-user #:key email)
  (list
   (doom-service
    'user
    #:config
    `((setq user-mail-address ,email)))))
#+end_src
****** Keymaps :bindings:
#+begin_src scheme
(define (doom-keymaps)
  (append
   (list
    (doom-service
     'keymaps
     #:config
     '((defun biome--trans (&rest rest)
         (-each (-partition 2 rest)
                (-lambda ((to from))
                         (define-key key-translation-map (kbd to) (kbd from)))))

       (biome--trans "C-h" "DEL"
                     "C-?" "C-h"

                     "s-h" "<left>"
                     "s-j" "<down>"
                     "s-k" "<up>"
                     "s-l" "<right>")

       (setq doom-leader-alt-key "s-SPC"
             doom-localleader-key "s-m"
             doom-localleader-alt-key "s-m")

       (defalias 'original-yank-pop #'yank-pop)

       ;; REVIEW Some of these should be in `:after' (or their respective package) sections but I'm not totally certain where I want to put bindings yet and I'm lazy.
       (map! "s-V" #'original-yank-pop

             "s-SPC" doom-leader-map

             ;; Adapted from Doom macOS bindings: ~/.config/emacs/modules/config/default/config.el:263
             "s-`" #'other-frame
             "s-n" #'+default/new-buffer
             "s-z" #'undo
             "s-Z" #'redo
             "s-c" (if (featurep 'evil) #'evil-yank #'copy-region-as-kill) ; TODO If keeping this, gate with `evil?'.
             "s-v" #'yank
             "s-s" #'save-buffer
             "s-x" #'execute-extended-command
             ;; REVIEW I don't think I need this, any time I'm in visual mode I can use `evil-delete` ("d")
             ;; :v "s-x" #'kill-region
             "s-/" (cmd! (save-excursion (comment-line 1)))
             ;; TODO If keeping this, gate with `evil?'.
             :n "s-/" #'evilnc-comment-or-uncomment-lines
             :v "s-/" #'evilnc-comment-operator

             "s-t" (lookup-key doom-leader-map (kbd "`"))
             "s-f" (lookup-key doom-leader-map (kbd "s b"))
             "s-r" (lookup-key doom-leader-map (kbd "f r"))
             "s-w" (lookup-key doom-leader-map (kbd "b k"))
             "s-d w" (lookup-key doom-leader-map (kbd "w d"))
             "s-d s-w" (cmd! (kill-current-buffer)
                             (+workspace/close-window-or-workspace))
             "s-g" (lookup-key doom-leader-map (kbd "g g"))
             "s-," (lookup-key doom-leader-map (kbd "w w"))
             "s-<" (lookup-key doom-leader-map (kbd "w W"))
             "s-y" (lookup-key doom-leader-map (kbd "i y"))
             "s-{" (lookup-key doom-leader-map (kbd "b p"))
             "s-}" (lookup-key doom-leader-map (kbd "b n"))
             "s-p" (lookup-key global-map (kbd "C-~")) ; TODO if I'm keeping this, improve it to first switch focus to a/the popup window if one isn't focused already

             "s-u" (lookup-key doom-leader-map (kbd "u"))
             "s-U" #'negative-argument ; REVIEW Trying this out.
             (:map universal-argument-map
              "s-u" #'universal-argument-more)

             ;; TODO Gate with `evil?'.
             (:after evil-easymotion
              "s-a" (lookup-key evilem-map (kbd "SPC")))

             "s-." #'repeat

             ;; TODO Gate with `evil?'.
             "s-J" #'evil-scroll-down
             "s-K" #'evil-scroll-up

             (:prefix "s-d"
              "." #'repeat-complex-command

              "h" #'git-gutter:popup-hunk
              ;; "o" #'+macos/open-in-default-program ;; TODO consider a Guix alternative? Meh.
              "r" #'projectile-replace
              "t" #'tldr
              "s" #'org-save-all-org-buffers
              "a" #'link-hint-open-multiple-links
              ;; TODO Gate with `evil?'.
              ;; "b" (cmd! (evil-local-mode 'toggle)
              ;;           (when evil-local-mode (evil-normal-state)))
              (:prefix "c"
               "f" #'org-gcal-fetch
               "s" #'org-gcal-sync
               "p" #'org-gcal-post-at-point)))

       ;; TODO wip stuff
       ;; If I keep this I can get rid of the "C-_" binding I have too. Update: maybe? Some places C-_ works and some s-h does (in vertico)? What about my key translation for C-? ? Straighten all this shit out.
       ;; - update: Guile won't accept the help-char string escape the way it is so I've removed it for now:
       ;;   (setq help-char (string-to-char "\C-_"))
       (biome--trans "s-h" "C-h")
       ;; Maybe "C-s-i" but then I'll have to change my sexp-movement command(s). Maybe keep this even if I do that, for consistency.
       (biome--trans "C-S-i" "<backtab>"))))

   (doom-dash)))
#+end_src
****** Undo
#+begin_src scheme
(define* (doom-undo #:key stateless?)
  (let ((name 'undo))
    (list
     (doom-service
      name
      #:modules '((#:emacs
                   undo))
      #:config
      '((after! undo-fu
                (setq undo-fu-ignore-keyboard-quit t))

        ;; (after! undo-tree
        ;;   (setq undo-tree-visualizer-timestamps t))
        ))

     (when stateless?
       (doom-stateless-service
        name
        #:state '(((#:path . ("undo-fu-session/" #:doom-base #:cache))
                   (#:storage . #:machine)))))

     (simple-service
      (symbol-append 'doom- name '-add-zstd)
      home-profile-service-type
      (list zstd)))))
#+end_src
***** Languages
#+begin_src scheme
(define* (doom-ts-lang lang
                       #:key
                       tree-sitter?)
  (append
   (list
    (doom-service
     lang
     #:modules `((#:lang
                  (,lang ,@(if tree-sitter? '(+tree-sitter) '()))))))

   (if tree-sitter?
       (doom-tree-sitter) '())))

(define (doom-tree-sitter)
  (list
   (doom-service
    'tree-sitter
    #:modules `((#:tools
                 tree-sitter)))))
#+end_src
****** Emacs Lisp
#+begin_src scheme
(define (doom-emacs-lisp)
  (list
   (doom-service
    'emacs-lisp
    #:modules `((#:lang
                 emacs-lisp))
    #:config
    '((after! elisp-mode
              (setq-hook! 'emacs-lisp-mode-hook indent-tabs-mode nil))))))
#+end_src
****** Javascript
#+begin_src scheme
(define* (doom-javascript #:key tree-sitter?)
  (append
   (doom-ts-lang 'javascript #:tree-sitter? tree-sitter?)
   (doom-ts-lang 'json #:tree-sitter? tree-sitter?)))
#+end_src
****** Markdown
#+begin_src scheme
(define* (doom-markdown)
  (list
   (doom-service
    'markdown
    #:modules `((#:lang
                 markdown)))))
#+end_src
****** XML and CSV
#+begin_src scheme
(define (doom-xml+csv)
  (list
   (doom-service
    'xml+csv
    #:modules `((#:lang
                 data)))))
#+end_src
****** Web
#+begin_src scheme
(define* (doom-web #:key tree-sitter?)
  (append
   (doom-ts-lang 'web #:tree-sitter? tree-sitter?)
   (doom-javascript #:tree-sitter? tree-sitter?)

   (list
    (doom-service
     'rest
     #:modules `((#:lang
                  (rest +jq)))))))
#+end_src
***** Libraries
****** Dash
#+begin_src scheme
(define (doom-dash)
  (list
   (doom-service
    'dash
    #:packages
    '((package! dash :pin "0ac1ecf6b56eb67bb81a3cf70f8d4354b5782341"))
    #:config
    '((use-package! dash)))))
#+end_src
****** Transient
#+begin_src scheme
(define* (doom-transient #:key stateless?)
  (let ((name 'transient))
    (list
     (doom-service
      name
      #:config
      `((after! transient
                (setq transient-history-limit ,very-big-history))))

     (when stateless?
       (doom-stateless-service
        name
        #:state '(((#:path . ("transient/history" #:doom-base #:data))
                   (#:storage . #:persist))))))))
#+end_src
**** Desktop
#+begin_src scheme
(define* (doom-desktop #:key
                       theme
                       light-colors
                       dark-colors
                       font
                       font-variable-pitch
                       font-unicode
                       font-serif)
  (append
   (doom-themes #:theme theme
                #:light-colors light-colors
                #:dark-colors dark-colors)
   (doom-fonts #:font font
               #:font-variable-pitch font-variable-pitch
               #:font-unicode font-unicode
               #:font-serif font-serif)))
#+end_src
***** Themes
#+begin_src scheme
(define* (doom-themes #:key
                      theme
                      light-colors
                      dark-colors)
  (let ((light-theme-name 'doom-one-light)
        (dark-theme-name 'doom-nuclear))
    (list
     (doom-service
      'themes
      #:config
      `((setq doom-theme ',(case theme
                             ((#:theme/light) light-theme-name)
                             ((#:theme/dark) dark-theme-name))))
      #:themes
      (append
       (doom-light-theme #:name light-theme-name
                         #:colors light-colors)
       (doom-dark-theme #:name dark-theme-name
                        #:colors dark-colors))))))
#+end_src
****** Light
#+begin_src scheme
;; Nothing here yet.
(define* (doom-light-theme #:key name colors)
  `())
#+end_src
****** Dark
Some colors from the original Atom theme on which I based mine that might be useful:
- ~#363b4e~
  Dark with a bluish tint. Was previously used as the line highlight color.
- ~#666d7a~
#+begin_src scheme
(define* (doom-dark-theme #:key name colors)
  (let ((clr (lambda (color)
               (assoc-ref colors color))))
    `((,name
       ((fg        '(,(clr #:color/fg)      "#bfbfbf" "brightwhite"))
        (bg        '(,(clr #:color/bg)      "black"   "black"))

        (fg-alt    '("#63677f"              "#2d2d2d" "white"))
        (bg-alt    '("#262831"              "black"   "black"))

        (base0     '(,(clr #:color/base0)   "black"   "black"))
        (base1     '("#202229"              "#1e1e1e" "brightblack")) ; (doom-darken "#262831" 0.15)
        (base2     '("#22242c"              "#2e2e2e" "brightblack")) ; (doom-darken "#262831" 0.10)
        (base3     '("#24262e"              "#262626" "brightblack")) ; (doom-darken "#262831" 0.05)
        (base4     '("#484b5b"              "#3f3f3f" "brightblack"))
        (base5     `(,(car fg-alt)          "#525252" "brightblack"))
        (base6     '("#7c82a0"              "#6b6b6b" "brightblack")) ; (doom-darken "#939abd" 0.15)
        (base7     '("#939abd"              "#979797" "brightblack"))
        (base8     '(,(clr #:color/base8)   "#dfdfdf" "white"))

        (grey      base4)
        (red       '(,(clr #:color/red)     "#ff6655" "red"))
        (orange    '(,(clr #:color/orange)  "#dd8844" "brightred"))
        (green     '(,(clr #:color/green)   "#99bb66" "green"))
        (teal      '("#fec0cb"              "#44b9b1" "brightgreen"))
        (yellow    '(,(clr #:color/yellow)  "#ECBE7B" "yellow"))
        (blue      '(,(clr #:color/blue)    "#51afef" "brightblue" ))
        (dark-blue '("#5f68de"              "#2257A0" "blue"))
        (magenta   '(,(clr #:color/magenta) "#c678dd" "brightmagenta"))
        (violet    '(,(clr #:color/violet)  "#a9a1e1" "magenta"))
        (cyan      '(,(clr #:color/cyan)    "#46D9FF" "brightcyan"))
        (dark-cyan '("#cf8191"              "#5699AF" "cyan"))

        (highlight      ,(clr #:color/accent))
        (vertical-bar   base0)
        (selection      dark-blue)
        (builtin        blue)
        (comments       base5)
        (doc-comments   base7)
        (constants      yellow)
        (functions      blue)
        (keywords       magenta)
        (methods        teal)
        (operators      cyan)
        (type           orange)
        (strings        green)
        (variables      red)
        (numbers        dark-cyan)
        (region         `(,(doom-lighten (car bg-alt) 0.15) ,@(doom-lighten (cdr base1) 0.35)))
        (error          red)
        (warning        yellow)
        (success        green)
        (vc-modified    orange)
        (vc-added       green)
        (vc-deleted     red))

       ;; Doom base theme overrides.
       ((cursor :background "#fdd94a")
        ((font-lock-comment-delimiter-face &override) :foreground base7)
        ((font-lock-doc-face &override) :foreground violet)
        ((line-number-current-line &override) :foreground violet)
        (mode-line :background base1 :foreground fg)
        (mode-line-inactive :background base3 :foreground base6)
        (org-block :background (doom-lighten bg-alt 0.02))
        (rainbow-delimiters-depth-1-face :foreground fg)
        (rainbow-delimiters-depth-2-face :foreground magenta)
        (rainbow-delimiters-depth-3-face :foreground blue)
        (rainbow-delimiters-depth-4-face :foreground cyan)
        (rainbow-delimiters-depth-5-face :foreground green)
        (rainbow-delimiters-depth-6-face :foreground yellow)
        (rainbow-delimiters-depth-7-face :foreground orange)
        (rainbow-delimiters-depth-8-face :foreground red)
        (rainbow-delimiters-depth-9-face :foreground teal)

        ;; Custom faces.
        (clojure-character-face :foreground teal :weight 'bold)
        (doom-modeline-bar :background highlight)
        (doom-modeline-buffer-file :inherit 'mode-line-buffer-id :weight 'bold)
        (doom-modeline-buffer-path :inherit 'mode-line-emphasis :weight 'bold)
        (doom-modeline-buffer-project-root :foreground green :weight 'bold)
        (solaire-mode-line-face :inherit 'mode-line :background base0)
        (solaire-mode-line-inactive-face :inherit 'mode-line-inactive :background base2)

        ;; These are present in the `doom-one' theme on which mine is based but I'm not sure if I need or want them. I'm keeping them around for now.
        (css-proprietary-property :foreground orange)
        (css-property :foreground green)
        (css-selector :foreground blue)
        (font-latex-math-face :foreground green)
        (markdown-markup-face :foreground base5)
        (markdown-header-face :inherit 'bold :foreground red)
        ((markdown-code-face &override) :background (doom-lighten base3 0.05))
        (rjsx-tag :foreground red)
        (rjsx-attr :foreground orange))))))
#+end_src
***** Fonts
#+begin_src scheme
(define* (doom-fonts #:key
                     font
                     font-variable-pitch
                     font-unicode
                     font-serif)
  (append
   (list
    (doom-service
     'fonts
     #:config
     `((defun biome--set-font-safe (sym font)
         (when (find-font font)
           (set sym font)))

       (biome--set-font-safe
        'doom-font
        (font-spec ;; :family ,(assoc-ref font #:font/name)
                   ;; Work around what I suspect is a PGTK issue. It's doesn't happen in Emacs 29, remove this when its released.
                   :family ,(if (equal? (assoc-ref font #:font/weight) 'medium)
                                (string-append (assoc-ref font #:font/name) " Medium")
                                (assoc-ref font #:font/name))
                   :size ,(+ (assoc-ref font #:font/size) 2)
                   :weight ',(or (assoc-ref font #:font/weight) 'normal)))

       (-each '((doom-variable-pitch-font ,(assoc-ref font-variable-pitch #:font/name))
                (doom-unicode-font ,(assoc-ref font-unicode #:font/name))
                (doom-serif-font ,(assoc-ref font-serif #:font/name)))
              (-lambda ((font-sym family))
                       (biome--set-font-safe
                        font-sym
                        (font-spec :family family)))))))

   (doom-dash)))
#+end_src
*** Package management
**** Guix
#+begin_src scheme
(define* (guix-pm #:key
                  stateless?
                  doom?
                  ;; channels
                  ;; channels-file
                  )
  (append
   ;; (list
   ;;  (let ((name 'guix-add-channels))
   ;;    (cond
   ;;     (channels
   ;;      (simple-service name
   ;;                      home-channels-service-type
   ;;                      channels))
   ;;     (channels-file
   ;;      (simple-service name
   ;;                      home-xdg-configuration-files-service-type
   ;;                      `(("guix/channels.scm"
   ;;                         ,channels-file)))))))

   (if stateless?
       (let ((guix-profile ".guix-profile")
             (guix-current "guix/current"))
         (list
          (simple-service
           'guix-ensure-profiles
           home-activation-service-type
           #~(#$stateless-ensure-profiles-gexp
              (let ((user-profiles-dir (string-append "/var/guix/profiles/per-user/" (passwd:name (getpwuid (getuid))))))
                (list (cons (string-append (getenv "HOME") "/" #$guix-profile)
                            (string-append user-profiles-dir "/guix-profile"))
                      (cons (string-append (getenv "XDG_CONFIG_HOME") "/" #$guix-current)
                            (string-append user-profiles-dir "/current-guix"))))))

          (home-stateless-service
           'guix
           #:state '(((#:path . ("guix/" #:xdg-base "XDG_CACHE_HOME"))
                      (#:storage . #:machine)))
           #:ignore `(((#:path . ,guix-profile))
                      ((#:path . (,guix-current #:xdg-base "XDG_CONFIG_HOME")))))))
       '())

   (guile-services #:stateless? stateless?
                   #:doom? doom?)

   (if doom?
       (doom-guix #:stateless? stateless?) '())))
#+end_src
***** Guile
#+begin_src scheme
(define* (guile-services #:key
                         stateless?
                         doom?)
  (append
   (list
    ;; Typically we would add the package to the home profile to not depend on packages being installed at the system level, however in Guile's case it will (I think?) always be installed system-level and users probably want the same version of Guile as the one on the system anyway.
    ;; (simple-service
    ;;  'guile-add-packages
    ;;  home-profile-service-type
    ;;  (list guile))

    (simple-service
     'guile-add-config
     home-files-service-type
     `((".guile"
        ,(skeleton-file ".guile"))
       (".gdbinit"
        ,(skeleton-file ".gdbinit"))))

    (when stateless?
      (home-stateless-service
       'guile
       #:state '(((#:path . ".guile_history")
                  (#:storage . #:persist))
                 ((#:path . ("guile/" #:xdg-base "XDG_CACHE_HOME"))
                  (#:storage . #:machine))))))

   (if doom?
       (doom-guile #:stateless? stateless?) '())))
#+end_src
***** Doom Guile
#+begin_src scheme
(define* (doom-guile #:key stateless?)
  (append
   (let ((name 'guile))
     (list
      (doom-service
       name
       #:modules '((#:lang
                    (scheme +guile)))
       #:packages
       '((package! geiser :pin "3123a38e9ea036db9d9a884e7bb414490813e93c")) ; TODO Manual bump, remove this when Doom bumps the module.

       #:config
       '((after! scheme
                 (setq-hook! 'scheme-mode-hook indent-tabs-mode nil))

         ;; TODO Maybe do this if popping to the side is too annoying
         ;; (after! geiser-repl
         ;;   (setq geiser-repl-use-other-window nil))
         ))

      (when stateless?
        (doom-stateless-service
         name
         #:state '(((#:path . ("geiser-history.guile" #:doom-base #:cache))
                    (#:storage . #:persist)))))))

   (doom-transient #:stateless? stateless?)))
#+end_src
***** Doom Guix :bindings:
#+begin_src scheme
(define* (doom-guix #:key stateless?)
  (append
   (let ((name 'guix))
     (list
      (doom-service
       name
       #:packages
       '((package! guix
                   :recipe (:fork
                            (:host nil
                             :repo "https://git.savannah.gnu.org/git/guix/emacs-guix.git"))
                   :pin "cf5b7a402ea503c3dcda85a86b9a6c6dd01896e0")
         (package! build-farm :pin "5c268a3c235ace0d79ef1ec82c440120317e06f5") ; REVIEW trying out
         (package! guix-packaging ; REVIEW trying out
                   :recipe (:host github
                            :repo "ryanprior/emacs-guix-packaging"
                            :files (:defaults "snippets"))
                   :pin "5bbd1f1a268b3dfd813a75125ca88cbf0bef6529"))
       #:config
       '((after! guix
                 (set-popup-rules!
                  '(("^\\*Guix" :height 0.5))))
         (use-package! guix-devel
                       :hook (scheme-mode . guix-devel-mode))
         (use-package! guix-popup
                       :defer t
                       :init
                       (map! :leader
                             "l" #'guix))  ; REVIEW temporary binding?
         (use-package! guix-prettify
                       :hook (doom-first-buffer . global-guix-prettify-mode))
         (after! guix-pcomplete
                 (fmakunbound 'pcomplete/guix)) ; Don't use pcompletion, it doesn't work (I get an error: "Unknown # object: #~") plus my completions are already good (maybe even better than what it provides).

         ;; TODO once I'm done packaging Doom figure out how to enable this
         ;; (use-package! guix-contributing)

         (use-package! guix-packaging
                       :defer t
                       :init
                       (setq guix-packaging--data-dir (concat doom-cache-dir "guix-packaging")))))

      (when stateless?
        (doom-stateless-service
         name
         #:state '(((#:path . ("guix-packaging/" #:doom-base #:cache))
                    (#:storage . #:machine)))))))

   (doom-guile #:stateless? stateless?)))
#+end_src
**** Nix
#+begin_src scheme
(define* (nix-pm #:key
                 stateless?
                 doom?
                 doom-tree-sitter?
                 login-shell
                 (channels (local-file "nix-channels"))
                 (nixpkgs-config (local-file "nixpkgs-config.nix")))
  (append
   (list
    (let ((name 'nix-source-profile)
          (source (local-file "source-nix-profile")))
      (case login-shell
        ((#:shell/bash)
         (simple-service name
                         home-bash-service-type
                         (home-bash-extension
                          (bash-profile
                           (list source)))))
        ;; ((#:shell/zsh)
        ;;  (simple-service name
        ;;                  home-zsh-service-type
        ;;                  (home-zsh-extension
        ;;                   (zprofile
        ;;                    (list source)))))
        ))

    (simple-service
     'nix-add-channels
     home-files-service-type
     `((".nix-channels"
        ,channels)))

    (simple-service
     'nix-add-nixpkgs-config
     home-xdg-configuration-files-service-type
     `(("nixpkgs/config.nix"
        ,nixpkgs-config))))

   (if stateless?
       (let ((nix-profile ".nix-profile")
             (nix-channels ".nix-defexpr/channels"))
         (list
          (simple-service
           'stateless-nix-ensure-profiles
           home-activation-service-type
           #~(#$stateless-ensure-profiles-gexp
              (let ((user-profiles-dir (string-append "/nix/var/nix/profiles/per-user/" (passwd:name (getpwuid (getuid))))))
                (list (cons (string-append (getenv "HOME") "/" #$nix-profile)
                            (string-append user-profiles-dir "/profile"))
                      (cons (string-append (getenv "HOME") "/" #$nix-channels)
                            (string-append user-profiles-dir "/channels"))))))

          (home-stateless-service
           'nix
           #:state '(((#:path . ("nix/" #:xdg-base "XDG_CACHE_HOME"))
                      (#:storage . #:machine)))
           #:ignore `(((#:path . ,nix-profile))
                      ((#:path . ,nix-channels))))))
       '())

   (if doom?
       (doom-nix #:stateless? stateless?
                 #:tree-sitter? doom-tree-sitter?)
       '())))
#+end_src
***** Source Nix profile
#+begin_src sh :tangle (meta-in-dir "source-nix-profile")
if [ -f /run/current-system/profile/etc/profile.d/nix.sh ]; then
  . /run/current-system/profile/etc/profile.d/nix.sh
fi
#+end_src
***** Nix channels
#+begin_src conf :tangle (meta-in-dir "nix-channels")
https://nixos.org/channels/nixpkgs-unstable nixpkgs
#+end_src
***** Nixpkgs config
#+begin_src nix :tangle (meta-in-dir "nixpkgs-config.nix")
{ allowUnfree = true; }
#+end_src
***** Doom Nix
#+begin_src scheme
(define* (doom-nix #:key
                   stateless?
                   tree-sitter?)
  (append
   (doom-ts-lang 'nix #:tree-sitter? tree-sitter?)
   (doom-transient #:stateless? stateless?)))
#+end_src
***** Setup instructions
#+begin_src sh :tangle no
nix-channel --update

# nix-env --install google-chrome
# ...
#+end_src
**** Shared
#+begin_src scheme
(define stateless-ensure-profiles-gexp
  (with-imported-modules '((guix build utils)
                           (phrenetic build utils))
    #~(lambda (profiles)
        (use-modules ((guix build utils) #:select (mkdir-p))
                     ((phrenetic build utils) #:select (no-follow-file-exists?)))

        (for-each
         (lambda (i)
           ;; I get an error if I try to use `match-lambda', I have no idea why.
           (let ((link (car i))
                 (profile (cdr i)))
             (when (and (no-follow-file-exists? profile)
                        (not (no-follow-file-exists? link)))
               (mkdir-p (dirname link))
               (symlink profile link))))
         profiles))))
#+end_src
*** Console
**** KMonad
#+begin_src scheme
(define* (kmonad-tool #:key
                      doom?
                      (device "/dev/input/by-id/usb-Apple_Inc._Apple_Internal_Keyboard___Trackpad-event-kbd")
                      ;; (kbd (local-file "config.kbd"))
                      (kbd (local-file "../mine.kbd")))
  (list
   (simple-service
    'kmonad
    home-shepherd-service-type
    (kmonad-shepherd-service kbd))

   (when doom?
     (doom-service
      'kmonad
      #:packages '((package! kbd-mode
                             :recipe (:host github
                                      :repo "kmonad/kbd-mode")
                             :pin "4a26abcbfc04208f437fd6b6a5bf3217b124db84"))))))

(define (kmonad-shepherd-service kbd)
  (list
   (shepherd-service
    (provision '(kmonad))
    (start #~(make-forkexec-constructor
              (list #$(file-append kmonad "/bin/kmonad") #$kbd)
              #:log-file #$(home-shepherd-service-log-file "kmonad.log")))
    (stop #~(make-kill-destructor)))))
#+end_src
*** Desktop
**** Pipewire
#+begin_src scheme
(define* (pipewire-multimedia #:key
                              stateless?
                              dbus?)
  (append
   (pipewire-services #:stateless? stateless?
                      #:dbus? dbus?)
   (wireplumber-services #:stateless? stateless?)))

(define* (pipewire-services #:key
                            stateless?
                            dbus?)
  (list
   (simple-service
    'pipewire-add-packages
    home-profile-service-type
    (list pipewire))

   (simple-service
    'pipewire-add-shepherd-daemons
    home-shepherd-service-type
    (list
     (shepherd-service
      (provision '(pipewire))
      (requirement (if dbus?
                       '(dbus) '()))
      (start #~(make-forkexec-constructor
                (list #$(file-append pipewire "/bin/pipewire"))
                #:log-file #$(home-shepherd-service-log-file "pipewire.log")
                #:environment-variables
                (append (list "DISABLE_RTKIT=1")
                        (default-environment-variables))))
      (stop  #~(make-kill-destructor)))
     (shepherd-service
      (provision '(pipewire-pulse pulseaudio))
      (requirement '(pipewire pipewire-media-session))
      (start #~(make-forkexec-constructor
                (list #$(file-append pipewire "/bin/pipewire-pulse"))
                #:log-file #$(home-shepherd-service-log-file "pipewire-pulse.log")
                #:environment-variables
                (append (list "DISABLE_RTKIT=1")
                        (default-environment-variables))))
      (stop  #~(make-kill-destructor)))))

   (simple-service
    'pipewire-add-alsa-config
    home-xdg-configuration-files-service-type
    `(("alsa/asoundrc"
       ,(mixed-text-file
         "asoundrc"
         "<" (file-append pipewire "/share/alsa/alsa.conf.d/50-pipewire.conf") ">" "\n"
         "<" (file-append pipewire "/share/alsa/alsa.conf.d/99-pipewire-default.conf") ">" "\n"
         "\n"
         "pcm_type.pipewire {" "\n"
         "  lib " (file-append pipewire "/lib/alsa-lib/libasound_module_pcm_pipewire.so") "\n"
         "}" "\n"
         "\n"
         "ctl_type.pipewire {" "\n"
         "  lib " (file-append pipewire "/lib/alsa-lib/libasound_module_ctl_pipewire.so") "\n"
         "}" "\n"))))

   (when stateless?
     (home-stateless-service
      'pipewire
      #:state '(((#:path . ("pulse/cookie" #:xdg-base "XDG_CONFIG_HOME"))
                 (#:storage . #:machine)
                 (#:parent-dir-perms . ((#:mode . #o700)))))))))
#+end_src
***** Wireplumber
#+begin_src scheme
(define* (wireplumber-services #:key stateless?)
  (list
   (simple-service
    'wireplumber-add-packages
    home-profile-service-type
    (list wireplumber))

   (simple-service
    'wireplumber-add-shepherd-daemon
    home-shepherd-service-type
    (list
     (shepherd-service
      (provision '(wireplumber pipewire-media-session))
      (requirement '(pipewire))
      (start #~(make-forkexec-constructor
                (list #$(file-append wireplumber "/bin/wireplumber"))
                #:log-file #$(home-shepherd-service-log-file "wireplumber.log")
                #:environment-variables
                (append (list "DISABLE_RTKIT=1")
                        (default-environment-variables))))
      (stop  #~(make-kill-destructor)))))

   (when stateless?
     (home-stateless-service
      'wireplumber
      #:state '(((#:path . ("wireplumber/" #:xdg-base "XDG_STATE_HOME"))
                 (#:storage . #:machine)
                 (#:mode . #o700)))))))
#+end_src
**** Colors
#+begin_src scheme
;; Nothing here yet.
(define %light-colors
  '())

(define %dark-colors
  '((#:color/fg . "#dee2f8")
    (#:color/bg . "#31343f")
    (#:color/base0 . "#1e1f27")
    (#:color/base8 . "#eef0fb") ; (doom-lighten "#dee2f8" 0.5)
    (#:color/accent . "#8496ff")
    (#:color/red . "#fb8578")
    (#:color/orange . "#fdce5f")
    (#:color/green . "#9fed9c")
    (#:color/yellow . "#eddc91")
    (#:color/blue . "#7db9fe")
    (#:color/magenta . "#e29bf7")
    (#:color/violet . "#aeb9f3")
    (#:color/cyan . "#75e0f9")))
#+end_src
**** Wallpapers
#+begin_src scheme
(define %wallpapers
  `((#:wallpaper/alucard . ,(local-file "wallpapers/alucard.png"))))
#+end_src
**** Font library
#+begin_src scheme
(define* (font-library #:key
                       stateless?
                       packages)
  (list
   (simple-service
    'fonts-add-packages
    home-profile-service-type
    packages)

   (when stateless?
     (home-stateless-service
      'fonts
      #:state '(((#:path . ("fontconfig/" #:xdg-base "XDG_CACHE_HOME"))
                 (#:storage . #:machine)))))))

(define %fonts
  (let ((font-size 10))
    `((#:fonts/mono . ((#:font/name . "Source Code Pro")
                       (#:font/size . ,font-size)
                       (#:font/weight . ,'medium)
                       (#:font/package . ,font-adobe-source-code-pro)))
      (#:fonts/sans . ((#:font/name . "Source Sans 3")
                       (#:font/size . ,font-size)
                       (#:font/package . ,font-adobe-source-sans)))
      (#:fonts/serif . ((#:font/name . "Iosevka Etoile")
                        (#:font/package . ,font-iosevka-etoile)))
      (#:fonts/unicode . ((#:font/name . "Noto Sans")
                          (#:font/package . ,font-google-noto))))))
(define %font-packages-misc
  (list font-noto-color-emoji
        font-liberation))
#+end_src
***** Source Code Pro :package:version:
#+begin_src scheme :tangle (meta-in-dir "packages/fonts.scm")
(define-module (phrenetic packages fonts)
  #:use-module (guix build-system font)
  #:use-module (guix git-download)
  #:use-module ((guix licenses) #:prefix license:)
  #:use-module (guix packages)
  #:use-module ((gnu packages fonts) #:select (font-adobe-source-code-pro) #:prefix fonts:)
  #:use-module (phrenetic utils))

(define-public font-adobe-source-code-pro
  (with-git-version
   fonts:font-adobe-source-code-pro
   #:version "2.038R-ro-1.058R-it-1.018R-VAR"
   #:commit "2.038R-ro/1.058R-it/1.018R-VAR"
   #:hash "00h4v3rmxyyaxni6nywacxvjnji2g2pi0b4js1yx0g67fvrv2gag"))

(define-public font-adobe-source-sans
  (package
    (name "font-adobe-source-sans")
    (version "3.046")
    (source
     (origin
       (method git-fetch)
       (uri (git-reference
             (url "https://github.com/adobe-fonts/source-sans")
             (commit "3.046R")))
       (file-name (git-file-name name version))
       (sha256
        (base32 "01dnhyfffnlyjzyh40x2z728qpc4i0jvrcxdcjfm17zrwhmw84lw"))))
    (build-system font-build-system)
    (home-page "https://github.com/adobe-fonts/source-sans")
    (synopsis "Sans serif font family for user interface environments")
    (description "Source Sans is a set of OpenType fonts that have been designed to work well in user interface (UI) environments.")
    (license license:silofl1.1)))
#+end_src
**** Date/time formats
#+begin_src scheme
(define %date-format "%a %b %-d")

(define %time-format "%-I:%M %p")
#+end_src
**** XDG
#+begin_src scheme
(define* (xdg #:key
              stateless?
              (desktop "$HOME/desktop")
              (documents "$HOME/docs")
              (download "$HOME/dl")
              (music "$HOME/music")
              (pictures "$HOME/pics")
              (publicshare "$HOME/public")
              (templates "$HOME/templates")
              (videos "$HOME/vids"))
  (list
   (simple-service
    'xdg-add-packages
    home-profile-service-type
    (list xdg-utils
          xdg-user-dirs ; I don't think I need this (the only reason would be if programs ever call the `xdg-user-dir' shell command and this package isn't an input to theirs).
          desktop-file-utils)) ; I don't think I need this at all but it adds elisp code (a mode for editing .desktop files). Andrew Tropin has it, I'll keep it just in case.

   (service
    home-xdg-user-directories-service-type
    (home-xdg-user-directories-configuration
     (desktop desktop)
     (documents documents)
     (download download)
     (music music)
     (pictures pictures)
     (publicshare publicshare)
     (templates templates)
     (videos videos)))

   (when stateless?
     (home-stateless-service
      'xdg
      #:state
      (append
       '(((#:path . ("Trash/" #:xdg-base "XDG_DATA_HOME"))
          (#:storage . #:machine)
          (#:mode . #o700))
         ;; Handle `XDG_LOG_HOME' here even though it isn't officially part of the XDG specification ("at least not yet", according to Andrew Tropin).
         ((#:path . (#:xdg-base "XDG_LOG_HOME"))
          (#:storage . #:machine)))
       (let ((normalize
              (lambda (dir)
                (as-> dir $
                      (let ((home-prefix "$HOME/"))
                        (if (string-prefix? home-prefix $)
                            (string-drop $ (string-length home-prefix))
                            $))
                      (string-append $ "/")))))
         `(,@(map (lambda (dir)
                    `((#:path . ,(normalize dir))
                      (#:storage . #:persist)))
                  (list desktop
                        documents
                        music
                        pictures
                        publicshare
                        templates
                        videos))
           ((#:path . ,(normalize download))
            (#:storage . #:machine)))))))))
#+end_src
**** Mesa
Maybe this shouldn't be a standalone component but rather added by programs that "use Mesa", if that's even the right way of thinking about it.
#+begin_src scheme
(define* (mesa #:key stateless?)
  (list
   (when stateless?
     (home-stateless-service
      'mesa
      #:state '(((#:path . ("mesa_shader_cache/" #:xdg-base "XDG_CACHE_HOME"))
                 (#:storage . #:machine)))))))
#+end_src
**** D-Bus
#+begin_src scheme
(define (dbus-ipc)
  (list
   (service home-dbus-service-type)))
#+end_src
**** Login management
***** Login managers
****** GDM
#+begin_src scheme
(define* (gdm #:key stateless?)
  (list
   (when stateless?
     (home-stateless-service
      'gdm
      #:state '(((#:path . ("gdm/" #:xdg-base "XDG_CACHE_HOME"))
                 (#:storage . #:machine)
                 (#:mode . #o700)))))))
#+end_src
***** Desktop TTY
#+begin_src scheme
(define* (desktop-tty #:key
                      sessions
                      start-cmds)
  (list
   (simple-service
    'desktop-tty-default-session-start
    home-profile-service-type
    (list (default-session-start
            (match-let (((default-session _ ...) sessions))
              (assoc-ref start-cmds default-session)))))))

(define (default-session-start cmd)
  (package
    (inherit simple-package)
    (name "default-session-start")
    (source cmd)
    (arguments
     `(#:builder
       ,#~(begin
            (let ((bin (string-append #$output "/bin")))
              (mkdir #$output)
              (mkdir bin)
              (symlink #$source (string-append bin "/default-session-start"))))))))
#+end_src
**** Sessions
***** Desktop environments
****** GNOME
#+begin_src scheme
(define* (gnome-desktop #:key stateless?)
  (list
   (simple-service
    'gnome-add-packages
    home-profile-service-type
    (list (gnome-start-package)
          gnome))

   ;; (when stateless?
   ;;   (home-stateless-service
   ;;    'gnome
   ;;    #:state ...))
   ))

(define (gnome-start)
  (file-append (gnome-start-package) "/bin/" gnome-start-exe))

(define gnome-start-exe "gnome-start")

(define (gnome-start-package)
  (session-start
   gnome-start-exe
   (environment-variable-shell-definitions
    (list xdg-session-type-wayland-env-var))
   "exec " (file-append gnome-session "/bin/gnome-session")))
#+end_src
***** Window managers
****** Sway
#+begin_src scheme
(define* (sway-wm #:key
                  pipewire?
                  doom?
                  portal-services
                  (sway-mod 'Mod1)
                  (xwayland? #t)
                  bg-image
                  kb-layout
                  kb-repeat-delay
                  kb-repeat-rate
                  idle-manager
                  screen-locker
                  notifier
                  status-bar
                  applets
                  app-launcher
                  terminal
                  backup-terminal
                  emacs-editor
                  extra-config)
  (append
   (list
    (simple-service
     'sway-add-packages
     home-profile-service-type
     (list (sway-start-package pipewire?)
           qtwayland-5 ; Copied from RDE. I don't know what this is for. It seems like a build, not runtime, dependency; however, before moving this package to the Sway config Andrew Tropin had it in home-services/gnupg.scm I think because it's necessary for `pinentry-qt'.
           swayhide)) ; TODO I'm pretty sure this isn't required for anything. I'm keeping it around for now so I can try it out, though.

    (service
     home-sway-service-type
     (home-sway-configuration
      (package sway) ; Remove this when I'm not using RDE's `sway-latest` any more (at the time of this writing, RDE has version  1.7 which Guix only has on core-updates).
      (config
       (append
        `((xwayland ,(if xwayland? 'enable 'disable))

          (set $mod ,sway-mod)

          (floating_modifier $mod normal)

          (bindsym $mod+Shift+r reload)

          ;; Some of these might not be necessary. To be safe I'm using a combination of those in RDE and suggested here:
          ;; - https://github.com/swaywm/sway/wiki#gtk-applications-take-20-seconds-to-start
          ;; - https://lists.sr.ht/~abcdw/rde-discuss/%3C87bku5ozzn.fsf%40bruun.xyz%3E
          ;; - https://github.com/emersion/xdg-desktop-portal-wlr#running
          (exec ,(file-append dbus "/bin/dbus-update-activation-environment")
                DISPLAY WAYLAND_DISPLAY XDG_CURRENT_DESKTOP SWAYSOCK)

          ;; Manipulating windows.
          (bindsym $mod+Shift+c kill)
          (bindsym $mod+Shift+f fullscreen)
          (bindsym $mod+Shift+space floating toggle)
          (bindsym $mod+Control+space focus mode_toggle)
          (bindsym $mod+h focus left)
          (bindsym $mod+j focus down)
          (bindsym $mod+k focus up)
          (bindsym $mod+l focus right)
          (bindsym $mod+Shift+h move left)
          (bindsym $mod+Shift+j move down)
          (bindsym $mod+Shift+k move up)
          (bindsym $mod+Shift+l move right)

          ;; Moving around workspaces.
          (bindsym $mod+tab workspace back_and_forth)
          ,@(append-map
             (lambda (x)
               `((bindsym ,(format #f "$mod+~a" (modulo x 10))
                  workspace number ,x)
                 (bindsym ,(format #f "$mod+Shift+~a" (modulo x 10))
                          move container to workspace number ,x)))
             (iota 10 1))

          ;; Scratchpad settings.
          (bindsym $mod+Shift+minus move scratchpad)
          (bindsym $mod+minus scratchpad show)

          (default_border pixel)
          (default_floating_border pixel)
          (gaps inner 8)

          (bindsym $mod+Shift+b splith)
          (bindsym $mod+Shift+v splitv)
          (bindsym $mod+Shift+s layout stacking)
          (bindsym $mod+Shift+w layout tabbed)
          (bindsym $mod+Shift+e layout toggle split)
          (bindsym $mod+Shift+a focus parent)
          (bindsym $mod+Shift+q exec ,(file-append sway "/bin/swaynag")
                   -t warning -m "'You pressed the exit shortcut. Do you really want to exit sway?'"
                   -B "'Yes, exit sway'" ,#~(format #f "'~a exit'" #$(file-append sway "/bin/swaymsg")))
          (gaps left 78) ; To accommodate the crack in my screen.

          ;; Andrew Tropin says there's a bug in Sway that could affect this (https://github.com/swaywm/sway/issues/6950). I haven't experienced it but it's something to consider if I have issues.
          (for_window "[title=\".* - Emacs Assistant\"]"
                      floating enable,
                      resize set
                      width ,(assoc-ref emacs-assistant-window-params #:width) ppt
                      height ,(assoc-ref emacs-assistant-window-params #:height) ppt))

        (if bg-image
            `((output * bg ,bg-image fill)) '())

        (sway-input #:kb-layout kb-layout
                    #:kb-repeat-delay kb-repeat-delay
                    #:kb-repeat-rate kb-repeat-rate)

        (sway-external-programs #:idle-manager idle-manager
                                #:screen-locker screen-locker
                                #:notifier notifier
                                #:status-bar status-bar
                                #:applets applets
                                #:app-launcher app-launcher
                                #:terminal terminal
                                #:backup-terminal backup-terminal
                                #:emacs-editor emacs-editor)

        (or extra-config '())))))

    (simple-service
     'sway-reload-config-on-change
     home-run-on-change-service-type
     `((,(string-append home-files-directory "/" xdg-configuration-files-directory "/sway/config")
        ,#~(system* #$(file-append sway "/bin/swaymsg") "reload"))))

    (when doom?
      (doom-service
       'sway
       #:packages '((package! i3wm-config-mode :pin "188e3978807ec39eba3cb69d973c0062af324215")))))

   (or portal-services '())))

(define (sway-start pipewire?)
  (file-append (sway-start-package pipewire?) "/bin/" sway-start-exe))

(define sway-start-exe "sway-start")

(define (sway-start-package pipewire?)
  (session-start
   sway-start-exe
   (environment-variable-shell-definitions
    (cons* (xdg-current-desktop-env-var "sway")
           xdg-session-type-wayland-env-var ; Seems to be set even without this but relying on that might be a brittle, see https://www.reddit.com/r/swaywm/comments/skdt2b/comment/hvk8m8o
           (wayland-env-vars pipewire?)))
   "exec " (file-append sway "/bin/sway") " > ${XDG_LOG_HOME}/sway.log 2>&1"))
#+end_src
******* Input
#+begin_src scheme
(define* (sway-input #:key
                     kb-layout
                     kb-repeat-delay
                     kb-repeat-rate)
  `((input type:keyboard
           ,(append
             (if kb-layout
                 (append
                  `((xkb_layout ,(keyboard-layout-name kb-layout)))
                  (if-let ((variant (keyboard-layout-variant kb-layout)))
                          `((xkb_variant ,variant)) '())
                  (if-let ((model (keyboard-layout-model kb-layout)))
                          `((xkb_model ,model)) '())
                  (let ((options (keyboard-layout-options kb-layout)))
                    (if (null? options)
                        '()
                        `((xkb_options ,(string-join
                                         (keyboard-layout-options kb-layout) ","))))))
                 '())
             `((repeat_delay ,(or kb-repeat-delay 200)))
             `((repeat_rate ,(or kb-repeat-rate 40)))))

    (input type:touchpad
           ((natural_scroll enabled)
            (tap enabled)))))
#+end_src
******* External programs
#+begin_src scheme
(define* (sway-external-programs #:key
                                 idle-manager
                                 screen-locker
                                 notifier
                                 status-bar
                                 applets
                                 app-launcher
                                 terminal
                                 backup-terminal
                                 emacs-editor)
  (let ((executions
         (append
          `((bar swaybar_command ,@(assoc-ref status-bar #:status-bar/command))
            (exec ,@idle-manager)
            (exec ,@(assoc-ref notifier #:notifier/daemon)))

          (map (lambda (applet)
                 `(exec ,@applet))
               applets)))

        (bindings
         (append
          `((bindsym $mod+Return exec ,@terminal)
            ,@(if backup-terminal
                  `((bindsym $mod+Control+Shift+Return exec ,@backup-terminal))
                  '())
            (bindsym $mod+Shift+d exec ,@app-launcher)
            ;; (bindsym $mod+Control+Shift+l exec ,@(or screen-locker
            ;;                                          (list
            ;;                                           (file-append elogind "/bin/loginctl")
            ;;                                           "lock-session")))
            (bindsym $mod+Shift+y exec ,@(assoc-ref emacs-editor #:emacs/program))
            (bindsym $mod+y exec ,@(assoc-ref emacs-editor #:emacs/new-frame)))

          (sway-notifications notifier)
          (sway-status-bar status-bar)
          (sway-backlight)
          (sway-volume)
          (sway-player)
          (sway-screenshot))))

    (append executions bindings)))

(define (sway-notifications notifier)
  `((bindsym $mod+m exec ,@(assoc-ref notifier #:notifier/dismiss))
    (bindsym $mod+Shift+m exec ,@(assoc-ref notifier #:notifier/restore))
    (bindsym $mod+Control+m exec ,@(assoc-ref notifier #:notifier/menu))))

(define (sway-status-bar status-bar)
  `((bindsym $mod+backslash exec ,@(assoc-ref status-bar #:status-bar/toggle))))

(define* (sway-backlight #:key (step 10))
  (let* ((step->symbol (lambda (op)
                         (symbol-append (string->symbol (number->string step)) '% op)))
         (brightnessctl (file-append brightnessctl "/bin/brightnessctl")))
    `((bindsym --locked XF86MonBrightnessUp exec ,brightnessctl set ,(step->symbol '+))
      (bindsym --locked XF86MonBrightnessDown exec ,brightnessctl set ,(step->symbol '-)))))

(define* (sway-volume #:key (step 5))
  (let* ((step->symbol (lambda (op)
                         (symbol-append op (string->symbol (number->string step)) '%)))
         (pactl (file-append pulseaudio "/bin/pactl"))
         (unmute `(exec ,pactl set-sink-mute @DEFAULT_SINK@ "false;")))
    `((bindsym --locked XF86AudioRaiseVolume
               ,@unmute
               exec ,pactl set-sink-volume @DEFAULT_SINK@ ,(step->symbol '+))
      (bindsym --locked XF86AudioLowerVolume
               ,@unmute
               exec ,pactl set-sink-volume @DEFAULT_SINK@ ,(step->symbol '-))
      (bindsym --locked XF86AudioMute
               exec ,pactl set-sink-mute @DEFAULT_SINK@ toggle)
      (bindsym --locked XF86AudioMicMute
               exec ,pactl set-source-mute @DEFAULT_SOURCE@ toggle))))

(define (sway-player)
  (let ((playerctl (file-append playerctl "/bin/playerctl")))
    `((bindsym --locked XF86AudioPlay exec ,playerctl play-pause)
      (bindsym --locked XF86AudioPrev exec ,playerctl previous)
      (bindsym --locked XF86AudioNext exec ,playerctl next))))

(define (sway-screenshot)
  `((bindsym $mod+grave exec ,shot-output)
    (bindsym $mod+Control+grave exec ,swappy-clipboard)
    (bindsym $mod+Shift+grave exec ,shot-window-or-selection)))
#+end_src
******* Screenshot
#+begin_src scheme
(define subject-output
  #~(format #f "~a -t get_outputs | ~a -r '.[] | select(.focused) | .name'"
            #$(file-append sway "/bin/swaymsg")
            #$(file-append jq "/bin/jq")))

(define subject-window-or-selection
  #~(format #f "~a -t get_tree | ~a -r '.. | select(.pid? and .visible?) \
| .rect | \"\\(.x),\\(.y) \\(.width)x\\(.height)\"' | ~a -b ~a -B ~a"
            #$(file-append sway "/bin/swaymsg")
            #$(file-append jq "/bin/jq")
            #$(file-append slurp "/bin/slurp")
            "303030AA"
            "303030AA"))

(define* (shot-script subject #:key output geom (file "-"))
  (program-file
   (string-append "sway-shot-" subject)
   #~(system
      (format #f "~a ~a~a~a | ~a"
              #$(file-append grim "/bin/grim")
              #$(if output #~(string-append "-o \"$(" #$output ")\" ") "")
              #$(if geom #~(string-append "-g \"$(" #$geom ")\" ") "")
              #$file
              #$(file-append wl-clipboard "/bin/wl-copy")))))

(define shot-output
  (shot-script "output" #:output subject-output))

(define shot-window-or-selection
  (shot-script "window-or-selection" #:geom subject-window-or-selection))

(define swappy-clipboard
  (program-file
   "sway-swappy-clipboard"
   #~(system
      (format #f "~a | ~a -f -"
              #$(file-append wl-clipboard "/bin/wl-paste")
              #$(file-append swappy "/bin/swappy")))))
#+end_src
****** Pieces
******* Screen lockers
******** Swaylock
#+begin_src scheme
(define* (swaylock-wm-piece #:key
                            colors
                            font
                            time-format
                            date-format
                            image
                            extra-config)
  (list
   (service
    home-swaylock-service-type
    (home-swaylock-configuration
     (swaylock swaylock-effects)
     (config
      (let ((clr (lambda* (color #:optional alpha)
                   (as-> color $
                         (assoc-ref colors $)
                         (string-drop $ 1)
                         (string-append $ (or alpha "")))))
            (alpha "7f")) ; 50%
        `((daemonize)

          (font . ,(assoc-ref font #:font/name))
          ,@(if image
                (list #~(string-append "image=" #$image)) ; HACK `serialize-swaylock-config' doesn't allow gexp terms (it probably should). Ideally this line would be `(image . ,image)'.
                '())

          (indicator)
          (indicator-idle-visible)
          (indicator-caps-lock)
          (indicator-radius . "150")
          (indicator-thickness . "10")

          (key-hl-color . ,(clr #:color/green))
          (bs-hl-color . ,(clr #:color/yellow))
          (inside-color . ,(clr #:color/bg alpha))

          (ring-color . ,(clr #:color/bg))
          (ring-clear-color . ,(clr #:color/bg alpha))
          (ring-ver-color . ,(clr #:color/bg alpha))
          (ring-wrong-color . ,(clr #:color/bg alpha))

          (text-clear-color . ,(clr #:color/orange))
          (text-ver-color . ,(clr #:color/blue))
          (text-wrong-color . ,(clr #:color/red))
          (inside-clear-color . ,(clr #:color/orange))
          (inside-ver-color . ,(clr #:color/blue))
          (inside-wrong-color . ,(clr #:color/red))

          (text-color . ,(clr #:color/violet))
          (separator-color . "00000000")
          (line-uses-ring)

          ;; Effects

          (grace . "15")
          (effect-blur . 7x5)
          (fade-in . "2")

          (clock)
          (timestr . ,time-format)
          (datestr . ,date-format)

          ,@(or extra-config '()))))))))

(define (swaylock-screen-locker)
  (let ((swaylock "/run/setuid-programs/swaylock"))
    `((#:screen-locker/lock . ,(list swaylock))
      (#:screen-locker/lock-immediately . ,(list
                                            swaylock
                                            "--grace=0")))))
#+end_src
******** WAIT [#E] Change ~swaylock-screen-locker~ to a store path
According to Andrew Tropin this can happen once [[https://issues.guix.gnu.org/53468][{RFC PATCH} gnu: linux-pam: Change path to unix_chkpwd helper]] is merged (currently it's only on =core-updates=).
Does this also mean I won't have to add Swaylock at the system level (as a ~screen-locker-service~) as well? I likely won't have to figure it out myself, just see what happens in RDE after the fix is merged.
******* Idle managers
******** Swayidle
#+begin_src scheme
(define* (swayidle-wm-piece #:key
                            session
                            screen-locker
                            (lock-timeout 300)
                            extra-config)
  (list
   (service
    home-swayidle-service-type
    (home-swayidle-configuration
     (config
      `(,@(if screen-locker
              (let ((lock-cmd-quoted #~(format #f "'~a'" (string-join '#$screen-locker))))
                `((lock ,lock-cmd-quoted)
                  (before-sleep ,lock-cmd-quoted)
                  (timeout ,lock-timeout ,lock-cmd-quoted)))
              '())
        ,@(or extra-config '())))))

   (case session
     ((#:session/sway)
      (let* ((swaymsg (file-append sway "/bin/swaymsg"))
             (swaymsg-cmd (lambda (cmd)
                            #~(format #f "'~a \"~a\"'" #$swaymsg #$cmd)))
             (idle-timeout (+ lock-timeout 30)))
        (simple-service
         'swayidle-add-sway-power
         home-swayidle-service-type
         `((timeout ,idle-timeout ,(swaymsg-cmd "output * power off") resume ,(swaymsg-cmd "output * power on")))))))))

(define (swayidle-idle-manager)
  (list
   (file-append swayidle "/bin/swayidle")
   "-w"))
#+end_src
******* Notification daemons
******** Mako
#+begin_src scheme
(define* (mako-wm-piece #:key
                        colors
                        font)
  (list
   (simple-service
    'mako-add-packages
    home-profile-service-type
    (list mako))

   (simple-service
    'mako-config
    home-xdg-configuration-files-service-type
    `(("mako/config"
       ,(ini-file
         "mako-config"
         (let ((clr (lambda* (color #:optional alpha)
                      (as-> color $
                            (assoc-ref colors $)
                            (string-append $ (or alpha ""))
                            (string->symbol $)))))
           `((global ((font . ,(string->symbol (font-specification font)))
                      (max-icon-size . 32)
                      (text-color . ,(clr #:color/fg))
                      (background-color . ,(clr #:color/bg "e6")) ; 90% alpha
                      (border-color . ,(clr #:color/accent))
                      (border-size . 2)
                      (border-radius . 8)))
             (urgency=low ((border-color . ,(clr #:color/green))))
             (urgency=high ((border-color . ,(clr #:color/red))))))
         #:ini-serialize
         (lambda (config)
           (ini-serialize config #:equal-string "="))))))))

(define (mako-notifier menu)
  (let ((makoctl (file-append mako "/bin/makoctl")))
    `((#:notifier/daemon . ,(list (file-append mako "/bin/mako")))
      (#:notifier/dismiss . ,(list makoctl
                                   "dismiss"))
      (#:notifier/restore . ,(list makoctl
                                   "restore"))
      (#:notifier/menu . ,`(,makoctl
                            "menu"
                            ,@menu
                            "\"Notification action\"")))))
#+end_src
******* Status bars
******** Waybar
#+begin_src scheme
(define* (waybar-wm-piece #:key
                          colors
                          font
                          modules
                          transitions?
                          height
                          output
                          extra-config)
  (append
   (list
    (service
     home-waybar-service-type
     (home-waybar-configuration
      (config `#(((position . top)
                  (name . main)
                  ,@(if height
                        `((height . ,height)) '())
                  ,@(if output
                        `((output . ,output)) '())
                  ,@(or extra-config '()))))
      (style-css
       `(,#~#$(->> `(("fg" . #:color/fg)
                     ("bg" . #:color/bg)
                     ("bg-alt" . #:color/base0) ; TODO change this (previously I had it as lighter than bg, not darker)
                     ("accent" . #:color/accent)
                     ("green" . #:color/green)
                     ("orange" . #:color/orange)
                     ("red" . #:color/red))
                   (map (match-lambda
                          ((name . color)
                           (string-append "@define-color " name " " (assoc-ref colors color) ";\n"))))
                   (apply string-append))
         (*
          ((font-family . #(FontAwesome
                            ,@(if font
                                  (list
                                   (as-> font $
                                         (assoc-ref $ #:font/name)
                                         (string-append "\"" $ "\"")
                                         (string->symbol $)))
                                  '())))
           ,@(if transitions? '() '((transition . none)))
           (box-shadow . none)
           (text-shadow . none)
           (min-height . 0)))

         (tooltip
          ((border . (solid @bg-alt))
           (background . @bg)
           (opacity . 0.9)))

         ((tooltip label)
          ((color . @fg)
           (padding . 0)))

         (#{#waybar}#
          ((color . @fg)
           (background . @bg)))

         (#((.modules-right label)
            (.modules-right image))
          ((margin . (0.4em 0.2em))
           (padding . (0 0.4em))
           (background . @bg-alt)
           (border-radius . 0.2em)))

         ;; To accommodate the crack in my screen.
         (.modules-left
          ((margin-left . 82px)))
         ;; (.modules-left
         ;;  ((margin-left . 0.2em)))

         (.modules-right
          ((margin-right . 0.2em))))))))

   modules

   (list
    (simple-service
     'waybar-add-font-package
     home-profile-service-type
     (list font-awesome))

    (simple-service
     'waybar-reload-config-on-change
     home-run-on-change-service-type
     (let ((waybar-file (lambda (name)
                          (string-append home-files-directory "/" xdg-configuration-files-directory "/waybar/" name)))
           (reload-cmd #~(system* #$(file-append psmisc "/bin/killall") "-SIGUSR2" "waybar")))
       (map (lambda (f)
              (list (waybar-file f) reload-cmd))
            '("config" "style.css")))))))

(define (waybar-status-bar)
  `((#:status-bar/command . ,(list
                              (file-append waybar "/bin/waybar")))
    (#:status-bar/toggle . ,(list
                             (file-append psmisc "/bin/killall")
                             "-SIGUSR1" "waybar"))))

(define* (waybar-modules #:key
                         session
                         date-format
                         time-format)
  (append
   (list
    (waybar-clock #:date-format date-format
                  #:time-format time-format))
   (case session
     ((#:session/sway)
      (list
       (waybar-sway-workspaces)
       (waybar-sway-window)))
     (else '()))
   (let ((show-percentage? #f))
     (list
      (waybar-tray)
      (waybar-idle-inhibitor)
      (waybar-volume #:show-percentage? show-percentage?)
      (waybar-microphone #:show-percentage? show-percentage?)
      (waybar-backlight #:show-percentage? show-percentage?)
      (waybar-cpu)
      (waybar-memory)
      (waybar-battery #:show-percentage? #t)))))
#+end_src
******** Modules
#+begin_src scheme
(define* (waybar-module name
                        #:optional
                        config
                        style
                        #:key
                        (placement 'modules-right)
                        (bar-id 'main))
  (simple-service
   (symbol-append 'waybar-module- name)
   home-waybar-service-type
   (home-waybar-extension
    (config `#(((name . ,bar-id)
                (,placement . #(,name))
                (,name . ,(if config
                              config '())))))
    (style-css (if style
                   style '())))))
#+end_src
********* Backlight
#+begin_src scheme
(define* (waybar-backlight #:key show-percentage?)
  (waybar-module
   'backlight
   `((format . ,(string-append
                 "{icon}"
                 (if show-percentage? " {percent}" "")))
     (fomat-icons . #(🌕 🌔 🌗 🌒 🌑))))) ; TODO These aren't displaying for some reason.
#+end_src
********* Battery
#+begin_src scheme
(define* (waybar-battery #:key show-percentage?)
  (waybar-module
   'battery
   (let ((base-format (string-append
                       "{icon}"
                       (if show-percentage? " {capacity}%" ""))))
     `((format . ,base-format)
       (format-charging . ,(string-append "⚡ " base-format))
       (states . ((empty . 10)
                  (low . 20)
                  (half-low . 40)
                  (half . 60)
                  (high . 90)
                  (full . 100)))
       (format-icons . ((empty . )
                        (low . )
                        (half-low . )
                        (half . )
                        (high . )
                        (full . )))
       (tooltip-format . "Current capacity: {capacity}%\n\n{timeTo}")))
   `((#{#battery.discharging.empty}#
      ((color . @red)))
     (#{#battery.discharging.low}#
      ((color . @orange)))
     (#{#battery.full}#
      ((color . @green))))))
#+end_src
********* Clock
#+begin_src scheme
(define* (waybar-clock #:key
                       date-format
                       time-format)
  (waybar-module
   'clock
   `((tooltip-format . "<big>{:%Y %B}</big>\n<tt><small>{calendar}</small></tt>")
     ;; Workarounds for https://github.com/Alexays/Waybar/issues/1452.
     (format . ,(string-append "{:"
                               ((@ (ice-9 string-fun) string-replace-substring) date-format "%-d" "%d")
                               "  "
                               ((@ (ice-9 string-fun) string-replace-substring) time-format "%-I" "%I")
                               "}")))
   '()
   #:placement 'modules-left))
#+end_src
********* CPU
- TODO histogram
  - I don't understand the histogram output.
  - The histogram is "jumpy", it changes width.
#+begin_src scheme
(define* (waybar-cpu #:key (histogram? #t))
  (if histogram?
      (waybar-module
       'custom/cpu-hist
       `((format . {})
         (return-type . "json")
         (exec . ,#~(let ((cmd (string-append #$(file-append waybar-cpu-histogram "/bin/cpu-hist")
                                              " 2> /dev/null")))
                      (string-append "\"" cmd "\"")))
         (interval . 10)))
      (waybar-module
       'cpu
       '((format . " {usage}%")))))
#+end_src
********* Idle inhibitor
#+begin_src scheme
(define (waybar-idle-inhibitor)
  (waybar-module
   'idle_inhibitor
   '((format . {icon})
     (format-icons . ((activated . )
                      (deactivated . ))))))
#+end_src
********* Memory
#+begin_src scheme
(define (waybar-memory)
  (waybar-module
   'memory
   '((format . " {}%"))))
#+end_src
********* Microphone
#+begin_src scheme
(define* (waybar-microphone #:key show-percentage?)
  (waybar-module
   'pulseaudio#source
   `((format . "{format_source}")
     (format-source . ,(string-append
                        (if show-percentage? "{volume}% " "")
                        ""))
     (format-source-muted . "")
     (tooltip-format . "{source_desc} is on {source_volume}%")
     (on-click . ,#~(let ((cmd (list
                                #$(file-append pavucontrol "/bin/pavucontrol")
                                "--tab=4")))
                      (string-append "\"" (string-join cmd) "\""))))))
#+end_src
********* Tray
#+begin_src scheme
(define (waybar-tray)
  (waybar-module
   'tray
   `()
   `(((#{#tray}# menu)
      ((color . @fg)
       (background . @bg)
       (border . (solid 1px))
       (border-color . @bg-alt)))

     ((#{#tray}# menu menuitem)
      ((padding-top . 0px)
       (padding-bottom . 0px)
       (margin-top . 0.1em)
       (margin-bottom . 0em)))

     ((#{#tray}# menu menuitem:hover)
      ((background . none)))

     ((#{#tray}# menu separator)
      ((background . @bg-alt)
       (padding-top . 1px)
       (margin-top . 0.2em)
       (margin-bottom . 0.2em))))))
#+end_src
********* Volume
#+begin_src scheme
(define* (waybar-volume #:key show-percentage?)
  (waybar-module
   'pulseaudio#sink
   (let ((base-format (string-append
                       (if show-percentage? "{volume}% " "")
                       "{icon}")))
     `((format . ,base-format)
       (format-muted . "🔇")
       (format-bluetooth . ,(string-append base-format ""))
       (format-icons . ((default . #(🔈 🔉 🔊 📢))))
       (tooltip-format . "{desc} is on {volume}%")
       (on-click . ,(file-append pavucontrol "/bin/pavucontrol"))))))
#+end_src
********* Sway
********** Sway window
#+begin_src scheme
(define (waybar-sway-window)
  (waybar-module
   'sway/window
   `()
   `((#{#window}#
      ((margin-left . 1em)
       (margin-right . 1em))))
   #:placement 'modules-center))
#+end_src
********** Sway workspaces
#+begin_src scheme
(define* (waybar-sway-workspaces
          #:key
          persistent-workspaces
          (format-icons '(("1" . )
                          ("2" . )
                          ("3" . )
                          ("4" . )
                          ("5" . )
                          ("6" . ) ; 
                          ("7" . )  ; 
                          ("8" . )
                          ("9" . )
                          ("10" . )
                          ("urgent" . )
                          ("focused" . )
                          ("default" . ))))
  (waybar-module
   'sway/workspaces
   `((disable-scroll . #t)
     (format . {icon})
     (format-icons . ,format-icons)
     (persistent_workspaces . ,(if persistent-workspaces
                                   persistent-workspaces '())))
   `(((#{#workspaces}# button)
      ((background . none)
       (border-radius . 0.2em)
       (margin . (0.4em 0.2em))
       (padding . (0.2em 0.2em))
       (color . @fg)))

     ((#{#workspaces}# button:hover)
      ((background . none)
       (border-color . @accent)))

     ((#{#workspaces}# button.focused)
      ((background . @bg-alt)
       (color . @accent)))

     ((#{#workspaces}# button.urgent)
      ((color . @red))))
   #:placement 'modules-left))
#+end_src
******* Display configuration
******** Kanshi
#+begin_src scheme
(define* (kanshi-wm-piece #:key extra-config)
  (list
   (service
    home-kanshi-service-type
    (home-kanshi-configuration
     (config
      `(,@(or extra-config '())))))))
#+end_src
******* Applets
******** Network
********* Network manager
#+begin_src scheme
(define (network-manager-wm-applet)
  (list
   (simple-service
    'applet-network-manager-add-packages
    home-profile-service-type
    (list gnome:network-manager-applet))))

(define (network-manager-applet)
  (list
   (file-append gnome:network-manager-applet "/bin/nm-applet")
   "--indicator"))
#+end_src
******** Gammastep
#+begin_src scheme
(define (gammastep-wm-applet)
  (list
   ;; The applet can't find its icon unless the package is installed.
   (simple-service
    'applet-gammastep-add-packages
    home-profile-service-type
    (list gammastep))))

(define (gammastep-applet)
  (list
   (file-append gammastep "/bin/gammastep-indicator")
   "-l" "44:-123")) ; TODO Don't hardcode lat/long (use geoclue?) or make it a parameter.
#+end_src
******** Udiskie
#+begin_src scheme
(define (udiskie-wm-applet)
  (list
   (simple-service
    'applet-udiskie-add-packages
    home-profile-service-type
    (list udiskie))))

(define (udiskie-applet)
  (list
   (file-append udiskie "/bin/udiskie")
   "--tray"))
#+end_src
***** Shared
#+begin_src scheme
(define* (session-start exe #:rest content)
  (package
    (inherit simple-package)
    (name (string-append "session-" exe))
    (source (apply mixed-text-file exe content))
    (arguments
     `(#:builder
       ,#~(begin
            (let* ((bin (string-append #$output "/bin"))
                   (f (string-append bin "/" #$exe)))
              (mkdir #$output)
              (mkdir bin)
              (copy-file #$source f)
              (chmod f #o555)))))))

(define (xdg-current-desktop-env-var val)
  `("XDG_CURRENT_DESKTOP" . ,val)) ; "Normally" provided by a login manager.

(define xdg-session-type-wayland-env-var
  '("XDG_SESSION_TYPE" . "wayland")) ; "Normally" provided by a login manager.

;; I think these should really be set in packages / package program wrappers but this is easier and Andrew Tropin does it this way so I'll leave it as-is for now.
(define (wayland-env-vars pipewire?)
  ;; Copied from RDE: I don't know what all of these do. For some explanation see https://github.com/swaywm/sway/wiki/Running-programs-natively-under-Wayland.
  (append
   '(("SDL_VIDEODRIVER" . "wayland")
     ("MOZ_ENABLE_WAYLAND" . "1") ; The nongnu `firefox-wayland' package sets this in a program wrapper so it's probably not necessary unless I'm using some other Mozilla thing (e.g. `icecat') and even then it'd be better to add it to a wrapper.
     ("CLUTTER_BACKEND" . "wayland")
     ("ELM_ENGINE" . "wayland_egl")
     ("ECORE_EVAS_ENGINE" . "wayland-egl")
     ("QT_QPA_PLATFORM" . "wayland-egl") ; Might not be necessary since I set `XDG_SESSION_TYPE=wayland', see https://github.com/swaywm/sway/wiki/Running-programs-natively-under-Wayland#qt5
     ("_JAVA_AWT_WM_NONREPARENTING" . "1"))
   (if pipewire?
       '(("RTC_USE_PIPEWIRE" . "true")) '()))) ; No idea what this is for. I thought it was equivalent to toggling on chrome://flags/#enable-webrtc-pipewire-capturer but it's not. The `rtc_use_pipewire=true' in the ungoogled-chromium configure flags is a separate issue too (it only builds Chromium with support for pipewire, it still has to be turned on in the settings or with a flag).
#+end_src
**** Portals
#+begin_src scheme
(define* (portal-services #:key wayland?)
  (list
   (simple-service
    'portals-add-packages
    home-profile-service-type
    (list xdg-desktop-portal
          (if wayland?
              xdg-desktop-portal-wlr
              xdg-desktop-portal-gtk)))

   (when wayland?
     (simple-service
      'portals-wlr-config
      home-multi-xdg-configuration-files-service-type
      `(("xdg-desktop-portal-wlr/config"
         ,(ini-file
           "xdg-desktop-portal-wlr-config"
           `((screencast ((chooser_cmd . ,#~(string-append #$(file-append slurp "/bin/slurp")
                                                           " -f %o -or -c ff0000"))
                          (chooser_type . simple))))
           #:ini-serialize
           (lambda (config)
             (ini-serialize config #:equal-string "="))))))))) ; Donno if this is necessary (the examples don't have spaces around the equals), let's be safe.
#+end_src
**** Shared
#+begin_src scheme
(define* (ini-file name config
                   #:key (ini-serialize ini-serialize))
  (apply mixed-text-file name (ini-serialize config)))

(define (font-specification font)
  (string-join
   (list
    (assoc-ref font #:font/name)
    (number->string
     (assoc-ref font #:font/size)))))
#+end_src
*** Virtualization
#+begin_src scheme
(define (virtualization)
  (list
   (simple-service
    'virtualization-add-packages
    home-profile-service-type
    (list ;; qemu ; QEMU is kind of a fatty, maybe don't keep it installed all the time.
          ))))
#+end_src
*** Programs
**** AWS
#+begin_src scheme
(define (aws-prog)
  (list
   (simple-service
    'aws-add-packages
    home-profile-service-type
    (list awscli-2))))
#+end_src
***** AWS CLI 2 :package:version:upstream:
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "packages/aws.scm")
:END:
- TODO
  - generate the autocompletion index
    As described here:
    [[https://github.com/aws/aws-cli/tree/v2#cli-dev-version][GitHub - aws/aws-cli at v2 (cli dev version)]]
    [[https://github.com/NixOS/nixpkgs/blob/nixos-unstable/pkgs/tools/admin/awscli2/default.nix#L95][nixpkgs/default.nix at nixos-unstable · NixOS/nixpkgs · GitHub]]
  - set up command completion
    [[https://github.com/aws/aws-cli/tree/v2#command-completion][GitHub - aws/aws-cli at v2 (command completion)]]
  - [2022-04-13 Wed] dependencies don't need to be propagated?
    [[https://github.com/guix-mirror/guix/commit/fc89b50b7bb2edbc38b20adf8c899934dedcb6c3][gnu: awscli: Do not propagate inputs. · guix-mirror/guix@fc89b50 · GitHub]]
    This is for v1, might not apply here. At the time of this writing, this commit is only two hours old, see if there's any follow-up.
#+begin_src scheme
(define-module (phrenetic packages aws)
  #:use-module (guix build-system python)
  #:use-module (guix download)
  #:use-module (guix gexp)
  #:use-module (guix git-download)
  #:use-module ((guix licenses) #:prefix license:)
  #:use-module (guix packages)
  #:use-module ((guix utils) #:select (substitute-keyword-arguments))
  #:use-module ((gnu packages check) #:select (python-mock python-pytest python-coverage python-pytest-cov python-pytest-xdist))
  #:use-module ((gnu packages cmake) #:select (cmake))
  #:use-module ((gnu packages groff) #:select (groff))
  #:use-module ((gnu packages python-web) #:select (awscli) #:prefix python-web:)
  #:use-module ((gnu packages python-web) #:select (python-urllib3))
  #:use-module ((gnu packages python-xyz) #:select (python-prompt-toolkit) #:prefix python:)
  #:use-module ((gnu packages python-xyz) #:select (python-colorama-for-awscli python-docutils-0.15 python-wcwidth python-distro python-jmespath python-boto3 python-botocore python-six python-jsonschema))
  #:use-module ((gnu packages python-crypto) #:select (python-cryptography) #:prefix python-crypto:)
  #:use-module ((gnu packages serialization) #:select (python-ruamel.yaml))
  #:use-module ((gnu packages time) #:select (python-dateutil)))

(define-public awscli-2
  (package
    (inherit python-web:awscli)
    (version "2.4.23")
    (source
     (origin
       (method git-fetch)
       (uri (git-reference
             (url "https://github.com/aws/aws-cli")
             (commit version)))
       (sha256
        (base32
         "1xdgj6w6ibfiwpzd85g9lhk106nxrw06c9bdcrmfr68zaa32k6ff"))
       (file-name (git-file-name (package-name python-web:awscli) version))))
    (arguments
     (substitute-keyword-arguments (package-arguments python-web:awscli)
       ;; A few tests fail at present but I'm not gonna sweat it. A number more error but I think that's mostly due to the lack of network access. The vast majority pass:
       ;; Total tests ~7000 (failures=3, errors=222, skipped=6)
       ((#:tests? _) #f)))
    (propagated-inputs
     (list python-colorama-for-awscli
           python-docutils-0.15
           python-cryptography
           python-ruamel.yaml-0.15
           python-wcwidth
           python-prompt-toolkit
           python-distro-1.5
           python-awscrt
           python-dateutil
           python-jmespath
           python-urllib3))
    (native-inputs
     (list groff
           ;; For tests.
           python-jsonschema
           python-mock
           python-pytest
           python-coverage
           python-pytest-cov
           python-pytest-xdist))))
#+end_src
****** Deps :package:version:
#+begin_src scheme
(define python-awscrt
  (package
    (name "python-awscrt")
    (version "0.12.4")
    (source
     (origin
       (method url-fetch)
       (uri (pypi-uri "awscrt" version))
       (sha256
        (base32 "1cmfkcv2zzirxsb989vx1hvna9nv24pghcvypl0zaxsjphv97mka"))))
    (build-system python-build-system)
    (native-inputs
     (list
      cmake
      ;; For tests.
      python-boto3))
    (home-page "https://github.com/awslabs/aws-crt-python")
    (synopsis "A common runtime for AWS Python projects")
    (description "This package provides a common runtime for AWS Python projects")
    (license license:asl2.0)))

(define python-cryptography
  (package
    (inherit python-crypto:python-cryptography)
    (version "3.3.2")
    (source
     (origin
       (method url-fetch)
       (uri (pypi-uri "cryptography" version))
       (sha256
        (base32
         "1vcvw4lkw1spiq322pm1256kail8nck6bbgpdxx3pqa905wd6q2s"))))))

(define python-ruamel.yaml-0.15
  (package
    (inherit python-ruamel.yaml)
    (version "0.15.100")
    (source
     (origin
       (method url-fetch)
       (uri (pypi-uri "ruamel.yaml" version))
       (sha256
        (base32
         "1r5j9n2jdq48z0k4bdia1f7krn8f2x3y49i9ba9iks2rg83g6hlf"))))))

(define python-prompt-toolkit
  (package
    (inherit python:python-prompt-toolkit)
    (version "3.0.28")
    (source
     (origin
       (method url-fetch)
       (uri (pypi-uri "prompt_toolkit" version))
       (sha256
        (base32
         "0l0nnm9fvs8lklk2qq8mylb9jrlxvlqzpmqr4n7rdhl63rmx274z"))))))

(define python-distro-1.5
  (package
    (inherit python-distro)
    (version "1.5.0")
    (source
     (origin
       (method url-fetch)
       (uri (pypi-uri "distro" version))
       (sha256
        (base32
         "14nz51cqlnxmgfqqilxyvjwwa5xfivdvlm0d0b1qzgcgwdm7an0f"))))))
#+end_src
**** Clojure
#+begin_src scheme
(define* (clojure-prog #:key
                       stateless?
                       doom?
                       (jdk (list openjdk17 "jdk"))) ; Newest LTS release.
  (append
   (list
    (simple-service
     'clojure-add-packages
     home-profile-service-type
     (list clojure-tools
           jdk
           clj-kondo))

    (when stateless?
      (home-stateless-service
       'clojure
       #:state '(((#:path . ".m2/")
                  (#:storage . #:machine))))))

   (if doom?
       (doom-clojure #:stateless? stateless?) '())))
#+end_src
***** Clojure tools :package:
#+begin_src scheme :tangle (meta-in-dir "packages/clojure.scm")
(define-module (phrenetic packages clojure)
  #:use-module (guix gexp)
  #:use-module (guix packages)
  #:use-module ((guix utils) #:select (substitute-keyword-arguments))
  #:use-module ((gnu packages clojure) #:select (clojure-tools) #:prefix clojure:))

(define (with-man-pages clojure-tools)
  (package
    (inherit clojure-tools)
    (arguments
     (substitute-keyword-arguments (package-arguments clojure-tools)
       ((#:install-plan install-plan)
        #~(append #$install-plan '(("clojure.1" "/share/man/man1/")
                                   ("clj.1" "/share/man/man1/"))))))))

(define-public clojure-tools
  (with-man-pages clojure:clojure-tools))
#+end_src
***** Doom Clojure
#+begin_src scheme
(define* (doom-clojure #:key stateless?)
  (append
   (let ((name 'clojure))
     (list
      (doom-service
       name
       #:modules '((#:lang
                    clojure))
       #:config
       `((use-package! clojure-mode
                       :defer t
                       :init
                       (setq clojure-refactor-map-prefix (kbd "s-M r")) ; Has to be set before clojure-mode loads. ; REVIEW temporary binding
                       :config
                       (set-ligatures! 'clojure-mode :lambda "fn"))

         (use-package! cider
                       :defer t
                       :init
                       (-each '((cider-preferred-build-tool symbolp)
                                (cider-default-cljs-repl symbolp)
                                (cider-shadow-default-options stringp)
                                (cider-offer-to-open-cljs-app-in-browser booleanp)
                                (cider-clojure-cli-global-options stringp)
                                (cider-clojure-cli-global-options booleanp))
                              (-lambda ((sym f))
                                       (put sym 'safe-local-variable f)))
                       :config
                       (setq cider-repl-history-size ,very-big-history
                             cider-print-options '(("length" 100)))) ; TODO Upstream this fix. Also re-evaluate if it's necessary?

         ;; REVIEW make sure this is still working after nesting in `after!'
         (after! cider-repl
                 (add-hook! 'cider-repl-mode-hook
                            #'goto-address-prog-mode
                            #'highlight-numbers-mode
                            #'rainbow-delimiters-mode
                            #'yas-minor-mode-on
                            #'biome-sp-strict-h))

         (after! clj-refactor
                 (cljr-add-keybindings-with-prefix "s-M R")))) ; REVIEW temporary binding

      (when stateless?
        (doom-stateless-service
         name
         #:state '(((#:path . ("cider-repl-history" #:doom-base #:cache))
                    (#:storage . #:persist)))))))

   (doom-xml+csv)
   (doom-dash)))
#+end_src
**** Datomic
#+begin_src scheme
(define (datomic-prog)
  (list
   (simple-service
    'datomic-add-packages
    home-profile-service-type
    (list datomic-cli-tools))))
#+end_src
***** Datomic CLI tools :package:version:upstream:
#+begin_src scheme :tangle (meta-in-dir "packages/datomic.scm")
(define-module (phrenetic packages datomic)
  #:use-module (guix build-system copy)
  #:use-module (guix download)
  #:use-module (guix gexp)
  #:use-module (guix packages)
  #:use-module ((gnu packages compression) #:select (unzip))
  #:use-module ((nonguix licenses) #:prefix license:))

(define-public datomic-cli-tools
  (package
    (name "datomic-cli-tools")
    (version "1.0.91")
    (source
     (origin
       (method url-fetch)
       (uri (string-append "https://datomic-releases-1fc2183a.s3.amazonaws.com/tools/datomic-cli/datomic-cli-" version ".zip"))
       (sha256
        (base32
         "1xicmbsig8f1p5r9rxkhndi0f9l9w421zf49rbx44yc6v0db523b"))))
    (build-system copy-build-system)
    (arguments
     `(#:install-plan
       '(("." "bin" #:include-regexp ("^\\./datomic")) ; Files that start with "datomic" are the scripts. Restrict to this subset to automatically pick up any added in the future without being too inclusive about what we add to bin.
         ("README.txt" "share/doc/datomic/"))
       #:phases
       ,#~(modify-phases %standard-phases
            (add-after 'install 'make-scripts-executable
              (lambda _
                (for-each (lambda (f) (chmod f #o555))
                          (find-files (string-append #$output "/bin"))))))))
    (native-inputs
     (list unzip))
    (home-page "https://docs.datomic.com/cloud/index.html")
    (synopsis "CLI tools for Datomic")
    (description synopsis)
    (license (license:nonfree "https://www.datomic.com/cloud-eula.html"))))
#+end_src
**** Doom calendar
#+begin_src scheme
(define* (doom-calendar-prog #:key
                             stateless?
                             org?)
  (append
   (list
    (doom-service
     'calendar
     #:modules '((#:app
                  calendar))))

   (if org?
       (doom-org-gcal #:stateless? stateless?) '())))

(define* (doom-org-gcal #:key stateless?)
  (append
   (let ((name 'org-gcal))
     (list
      (doom-service
       name
       #:modules '((#:app
                    calendar))
       #:config
       '((after! org-gcal
                 (setq org-gcal-client-id "446729771716-pp79934q99aro2h8v3iki1fejcodbdoo.apps.googleusercontent.com"
                       org-gcal-client-secret (-> (auth-source-search :host org-gcal-client-id) car (plist-get :secret) funcall)
                       org-gcal-recurring-events-mode 'nested))))

      (when stateless?
        (doom-stateless-service
         name
         #:state '(((#:path . ("org-gcal/token.gpg" #:doom-base #:cache))
                    (#:storage . #:machine))
                   ((#:path . ("persist/org-gcal--sync-tokens" #:doom-base #:data))
                    (#:storage . #:machine)))))))

   (doom-dash)))

;; TODO
;; - This comonent no longers depens on doom-user so don't rely on user-mail-address?
;; - nb: also it uses `org-directory'
;; '((after! org-gcal
;;           (setq ;; TODO `elisp-serialize' doesn't like the unquotes.
;;                 ;; org-gcal-fetch-file-alist (let ((cal-dir concat org-directory "/cal"))
;;                 ;;                             `((user-mail-address . ,(concat cal-dir "/" user-mail-address ".org"))
;;                 ;;                               ("addressbook%23contacts@group.v.calendar.google.com" . ,(concat cal-dir "/contacts.org"))
;;                 ;;                               ("en.usa%23holiday@group.v.calendar.google.com" . ,(concat cal-dir "/holidays.org"))))
;;                 )))
#+end_src
**** Doom org :bindings:
#+begin_src scheme
(define* (doom-org-prog #:key
                        (org-dir "org")
                        stateless?
                        evil?)
  (append
   (doom-org #:stateless? stateless?
             #:evil? evil?
             #:org-dir org-dir)

   (list
    (when stateless?
      (home-stateless-service
       'org
       #:state `(((#:path . ,(string-append org-dir "/"))
                  (#:storage . #:persist))))))))

(define* (doom-org #:key
                   stateless?
                   evil?
                   org-dir)
  (append
   (let ((name 'org)
         (pretty? #t))
     (list
      (doom-service
       name
       #:modules '((#:lang
                    (org +journal)))
       #:packages
       (if pretty?
           '((package! org-modern :pin "ed9d67d00f26148019acd67b4aac0e26360a33b1")
             (package! org-appear :pin "60ba267c5da336e75e603f8c7ab3f44e6f4e4dac"))
           '())

       #:config
       (append
        `((use-package! org
                        :defer t
                        :init
                        (setq org-directory ,(string-append "~/" org-dir))
                        :config
                        (setq org-log-done 'time
                              org-priority-lowest ?E
                              org-priority-default ?C
                              org-priority-faces
                              (-map (-lambda ((priority color))
                                             (cons priority (doom-color color)))
                                    '((?A red)
                                      (?B orange)
                                      (?C blue)
                                      (?D yellow)
                                      (?E green)))))

          (after! ob
                  (setq org-babel-noweb-error-all-langs t)))

        (if evil?
            '((after! evil-org
                      (map! :map evil-org-mode-map
                            :nv "C-j" #'outline-forward-same-level
                            :nv "C-k" #'outline-backward-same-level)))
            '())

        (if pretty?
            '((after! org
                      (setq org-hide-emphasis-markers t
                            org-pretty-entities t
                            ;; org-ellipsis "…"

                            org-modern-hide-stars nil ; You still can't see them because `org-hide-leading-stars' is true but this way the "indentation" is retained.
                            ;; Disable source block frings. Getting it to look good would require:
                            ;; - disabling line numbers
                            ;; - disabling `org-startup-indented'
                            ;; - setting some `internal-border-width'
                            org-modern-block-fringe nil
                            ;; org-modern-priority nil ; Different faces for priorities aren't supported so disable this. Maybe use `org-fancy-priorities'.
                            org-modern-todo-faces
                            (-map (-lambda ((kw . face))
                                           `(,kw :inverse-video t :inherit ,face))
                                  org-todo-keyword-faces))

                      (when (not line-spacing)
                        (setq org-modern-label-border 0.3)) ; Chosen arbitrarily. Looks good.

                      (global-org-modern-mode)
                      (add-hook! 'org-mode-hook #'org-appear-mode)))
            '())))

      (when stateless?
        (doom-stateless-service
         name
         #:state '(((#:path . ("org-clock-save.el" #:doom-base #:data))
                    (#:storage . #:persist))
                   ((#:path . ("org/persist/" #:doom-base #:cache))
                    (#:storage . #:machine)))))))

   (doom-dash)))
#+end_src
**** Direnv
#+begin_src scheme
(define* (direnv-prog #:key
                      doom?
                      shells)
  (append
   (list
    (simple-service
     'direnv-add-packages
     home-profile-service-type
     (list direnv))

    (simple-service
     'direnv-rc
     home-xdg-configuration-files-service-type
     `(("direnv/direnvrc" ,(local-file "direnvrc")))))

   (map (lambda (shell)
          (let ((direnv-hook
                 (lambda (shell-name)
                   (let ((direnv-bin (file-append direnv "/bin/direnv")))
                     (mixed-text-file
                      "direnv-hook"
                      "command -v " direnv-bin " > /dev/null && eval \"$(" direnv-bin " hook " shell-name ")\"")))))
            (case shell
              ;; ((#:shell/bash) (simple-service
              ;;                  'direnv-bash-hook
              ;;                  home-bash-service-type
              ;;                  (home-bash-extension
              ;;                   (bashrc
              ;;                    (list (direnv-hook "bash"))))))
              ((#:shell/zsh) (simple-service
                              'direnv-zsh-hook
                              home-zsh-service-type
                              (home-zsh-extension
                               (zshrc
                                (list (direnv-hook "zsh")))))))))
        shells)

   (list
    (when doom?
      (doom-service
       'direnv
       #:modules '((#:tools
                    direnv)))))))
#+end_src
***** Direnvrc
#+begin_src sh :tangle (meta-in-dir "direnvrc")
use_guixs() {
	LOCK_FILE=channels-lock

	if [ -f $LOCK_FILE ]; then
		eval "$(guix time-machine --channels=$LOCK_FILE -- shell --search-paths "$@")"
	else
		eval "$(guix shell --search-paths "$@")"
	fi
}
#+end_src
***** Whitelist service
#+begin_src scheme
(define direnv-whitelist-service-type
  (service-type
   (name 'direnv-whitelist)
   (extensions
    (list (service-extension home-xdg-configuration-files-service-type
                             (lambda (whitelist-entries)
                               `(("direnv/direnv.toml"
                                  ,(toml-file
                                    "direnv-config"
                                    (if (null? whitelist-entries)
                                        '()
                                        `((whitelist ((exact . ,(serialize-toml-array whitelist-entries)))))))))))))
   (compose concatenate)
   (extend (lambda (_ whitelist-entries)
             whitelist-entries))
   (default-value #f)
   (description "Whitelist for Direnv.")))
#+end_src
****** TOML serialization
#+begin_src scheme
(define (toml-file name config)
  (ini-file name config))

(define (serialize-toml-array elements)
  (as-> elements $
        (map (lambda (element)
               (string-append "\"" element "\""))
             $)
        (string-join $ ", ")
        (string-append "[ " $ " ]")
        (string->symbol $)))
#+end_src
**** Node
#+begin_src scheme
(define* (node-prog #:key
                    stateless?
                    doom?
                    doom-tree-sitter?)
  (append
   (list
    (simple-service
     'node-add-packages
     home-profile-service-type
     (list node))

    ;; (when stateless?
    ;;   (home-stateless-service
    ;;    'node
    ;;    #:state '(((#:path . ".npm/")
    ;;               (#:storage . #:machine)))))
    )

   (if doom?
       (doom-javascript #:tree-sitter? doom-tree-sitter?) '())))
#+end_src
**** Proton VPN
#+begin_src scheme
(define* (protonvpn-prog #:key stateless?)
  (list
   (simple-service
    'protonvpn-add-packages
    home-profile-service-type
    (list protonvpn-cli))

   (when stateless?
     (home-stateless-service
      'protonvpn
      #:state '(((#:path . ".pvpn-cli/")
                 (#:storage . #:machine)))))))
#+end_src
**** SSH
#+begin_src scheme
(define (ssh-prog)
  (list
   (service home-openssh-service-type)))
#+end_src
**** File managers
***** Doom dired
#+begin_src scheme
(define* (doom-dired-prog #:key
                          stateless?
                          icons?
                          desktop?
                          emacs-handler)
  (let ((name 'dired)
        (dirvish? #t))
    (append
     (list
      (doom-service
       name
       #:modules `((#:emacs
                    (dired ,@(if icons? '(+icons) '())
                           ,@(if dirvish? '(+dirvish) '())))))

      (when (and stateless? dirvish?)
        (doom-stateless-service
         name
         #:state '(((#:path . ("dirvish/" #:doom-base #:cache))
                    (#:storage . #:machine))))))

     (if dirvish?
         (doom-transient) '())

     (if desktop?
         (list
          (emacs-xdg-service name
                             "file"
                             (emacs-handler
                              "dired"
                              '((dired (car args))))
                             #:default-for '(inode/directory)))
         '()))))
#+end_src
**** Text editors
***** Nano
The Guix skeleton =nanorc= points to the system installed nano, it should be changed to =~/.guix-home= or the used Nano package directly with a gexp.
#+begin_src scheme
;; (define (nano-prog)
;;   (list
;;    (simple-service
;;     'nano-add-packages
;;     home-profile-service-type
;;     (list nano))

;;    (simple-service
;;     'nano-add-config
;;     home-xdg-configuration-files-service-type
;;     `(("nano/nanorc"
;;        ,(skeleton-file ".nanorc"))))))
#+end_src
**** Trash
***** Doom trash
#+begin_src scheme
(define (doom-trash-prog)
  (list
   (doom-service
    'trash
    #:packages
    '((package! trashed :pin "ddf5830730544435a068f2dc9ac75a81ea69df1d")))))
#+end_src
**** Version control
***** Git
#+begin_src scheme
(define* (git-prog #:key
                   stateless?
                   doom?
                   email
                   sign-commits? ; TODO make this (sign-commits? #t) once I have my gpg stuff set up and I'm passing a gpg-sign-key.
                   gpg-sign-key
                   ;; git-send-email?
                   extra-config)
  (append
   (list
    ;; (when git-send-email?
    ;;   (simple-service
    ;;    'git-send-email-package
    ;;    home-profile-service-type
    ;;    (list (list git "send-email"))))
    (service
     home-git-service-type
     (home-git-configuration
      (config
       `((user
          ((email . ,email)
           ,@(if sign-commits?
                 `((signingkey . ,gpg-sign-key)) '())))
         ;; TODO stuff from feature-git, figure it out later
         ;; (merge
         ;;  ;; diff3 makes it easier to solve conflicts with smerge, zdiff3
         ;;  ;; should make a conflict scope smaller, but guile-git fails if
         ;;  ;; this option is set.
         ;;  ((conflictStyle . diff3)))
         ;; (diff
         ;;  ;; histogram should be smarter about diff generation.
         ;;  ((algorithm . histogram)))
         (commit
          (,@(if sign-commits?
                 '((gpgsign . #t)) '())))
         ;; (sendemail
         ;;  ((annotate . #t)))
         ;;  TODO these two (http and gpg) sections were in the RDE example home environment (but notably not in the rde feature-git). Figure out what they're for after I do gpg.
         ;; (http "https://weak.example.com"
         ;;       ((ssl-verify . #f)))
         ;; (gpg
         ;;  ((program . ,(file-append gnupg "/bin/gpg"))))
         ,@(or extra-config '()))))))

   (if doom?
       (doom-git #:stateless? stateless?) '())))
#+end_src
****** Doom Git
#+begin_src scheme
(define* (doom-git #:key stateless?)
  (append
   (doom-version-control)

   (list
    (doom-service
     'git
     #:modules '((#:tools
                  (magit +forge)))
     #:config
     '((after! magit
               (setq git-commit-style-convention-checks '(non-empty-second-line))
               (setq magit-revision-show-gravatars '("^Author:     " . "^Commit:     "))))))

   (doom-transient #:stateless? stateless?)))
#+end_src
******* Doom version control
#+begin_src scheme
(define (doom-version-control)
  (list
   (doom-service
    'version-control
    #:modules '((#:emacs
                 vc)
                (#:ui
                 (vc-gutter +pretty)))))) ; I tried `+diff-hl' but it was kind of buggy so wait on this. See https://github.com/doomemacs/doomemacs/commit/27a448b0.
#+end_src
**** Miscellaneous programs
#+begin_src scheme
(define (misc-progs)
  (list
   (simple-service
    'misc-progs-add-packages
    home-profile-service-type
    (list curl
          zip
          unzip))))
#+end_src
**** Apps
***** Audio
****** PulseAudio Volume Control
#+begin_src scheme
(define* (pavucontrol-app #:key
                          stateless?
                          gtk-services)
  (append
   (list
    (simple-service
     'pavucontrol-add-packages
     home-profile-service-type
     (list pavucontrol))

    (when stateless?
      (home-stateless-service
       'pavucontrol
       #:ignore '(((#:path . ("pavucontrol.ini" #:xdg-base "XDG_CONFIG_HOME"))))))) ; Pavucontrol overwrites the current file (or a symlink) so we can't store this. Let's just ignore it.

   (or gtk-services '())))
#+end_src
***** Menus
****** Doom menu
#+begin_src scheme
;; Emacs already "has a menu" in the form of `completing-read', all we need is something to serve the role of application launcher.
(define (doom-menu-app)
  (list
   (doom-service
    'menu
    #:packages
    '((package! app-launcher
                :recipe (:host github
                         :repo "SebastienWae/app-launcher")
                :pin "d5015e394b0a666a8c7c4d4bdf786266e773b145")))))

(define (doom-menu emacs-handler)
  `((#:menu/menu . ,(list
                     (emacs-handler
                      "menu"
                      '((completing-read (concat (car args) ": ") (split-string input "\n") nil t))
                      #:assistant? #t
                      #:assistant-title "Menu"
                      #:minibuffer? #t
                      #:input? #t)))
    (#:menu/app-launcher . ,(list
                             (emacs-handler
                              "app-launcher"
                              '((app-launcher-run-app))
                              #:assistant? #t
                              #:assistant-title "App Launcher"
                              #:minibuffer? #t)))))
#+end_src
****** Rofi
#+begin_src scheme
(define* (rofi-app #:key
                   stateless?
                   wayland?
                   colors
                   font)
  (list
   (service
    home-rofi-service-type
    (home-rofi-configuration
     (rofi (get-rofi-package wayland?))
     (config-rasi
      ;; Using Andrew Tropin's / RDE's confguration for now, revisit later.
      `((configuration
         ((modi . "run,ssh,drun")
          (drun-show-actions . #t)
          (show-icons . #t)
          (font . ,(font-specification font))

          (kb-row-tab . "")
          (kb-row-select . "Tab")
          (kb-secondary-paste . "Control+y")
          (kb-remove-word-forward . "Alt+d")
          (kb-remove-word-back . "Control+w,Control+BackSpace")
          (kb-clear-line . "Control+slash")
          (kb-page-next . "Control+v")
          (kb-page-prev . "Alt+v")))

        ;; Not done yet: configure Rofi to look pretty and use `colors' argument.
        ;; ,#~"@theme \"paper-float\""
        ;; ,@(let ((clr (lambda* (color #:optional alpha)
        ;;                (as-> color $
        ;;                      (assoc-ref colors $)
        ;;                      (string-append $ (or alpha ""))))))
        ;;     `((*
        ;;        (;; (white . ,(clr #:color/fg))
        ;;         ;; (black . ,(clr #:color/bg))
        ;;         ;; (grey . ,(clr #:color/...))
        ;;         ;; (blue . ,(clr #:color/blue))
        ;;         (background . "#000000BF")))))
        ;; (window
        ;;  ((transparency . "real")))
        ))))

   (when stateless?
     (home-stateless-service
      'rofi
      #:state '(((#:path . ("rofi3.druncache" #:xdg-base "XDG_CACHE_HOME"))
                 (#:storage . #:machine)))))))

(define* (rofi-menu #:key wayland?)
  (let ((rofi (file-append (get-rofi-package wayland?) "/bin/rofi")))
    `((#:menu/menu . ,(list rofi "-dmenu" "-p"))
      (#:menu/app-launcher . ,(list rofi "-show" "drun")))))

(define (get-rofi-package wayland?)
  (if wayland? rofi-wayland rofi))
#+end_src
***** Messaging
****** Zoom
Doesn't work for me at the moment. As of this writing the package is brand new so wait a while and see if there any developments/updates/fixes (though I suspect the issue(s) lie with me, I was getting errors, possibly similar ones, when I tried to install Zoom through Nix).
#+begin_src scheme
(define* (zoom-app #:key
                   stateless?
                   qt-services)
  (append
   (list
    (simple-service
     'zoom-add-packages
     home-profile-service-type
     (list zoom))

    ;; (when stateless?
    ;;   (home-stateless-service
    ;;    'zoom
    ;;    #:state '(((#:path . ("zoom/" #:xdg-base "XDG_CONFIG_HOME"))
    ;;               (#:storage . #:machine))
    ;;              ((#:path . ("zoom/" #:xdg-base "XDG_DATA_HOME"))
    ;;               (#:storage . #:machine)))))
    )

   (or qt-services '())))
#+end_src
***** Image processing
****** GIMP
#+begin_src scheme
(define* (gimp-app #:key
                   stateless?
                   gtk-services)
  (append
   (list
    (simple-service
     'gimp-add-packages
     home-profile-service-type
     (list gimp))

    (when stateless?
      (home-stateless-service
       'gimp
       #:state '(((#:path . ("gimp/" #:xdg-base "XDG_CACHE_HOME"))
                  (#:storage . #:machine))
                 ((#:path . ("GIMP/" #:xdg-base "XDG_CONFIG_HOME"))
                  (#:storage . #:machine))))))

   (or gtk-services '())))
#+end_src
***** Terminals
****** Alacritty
#+begin_src scheme
(define* (alacritty-app #:key
                        colors
                        font)
  (list
   (service
    home-alacritty-service-type
    (home-alacritty-configuration
     (config
      `((window . ((padding . ((x . 5)
                               (y . 5)))))
        (background_opacity . 0.75) ; Change this to window.opacity when Guix updates Alacritty version (to 1.10.0 or above).
        ,@(if font
              `((font . ((normal . ,(append
                                     `((family . ,(assoc-ref font #:font/name)))
                                     (if-let ((weight (assoc-ref font #:font/weight)))
                                             `((style . ,(font-weight->style weight))) '())))
                         (size . ,(- (assoc-ref font #:font/size) 1)))))
              '())
        ,@(let ((clr (lambda (color)
                       (assoc-ref colors color))))
            `((colors . ((primary . ((background . ,(clr #:color/bg))
                                     (foreground . ,(clr #:color/fg))))
                         (normal . ((black . ,(clr #:color/base0))
                                    (white . ,(clr #:color/base8))
                                    (red . ,(clr #:color/red))
                                    (green . ,(clr #:color/green))
                                    (yellow . ,(clr #:color/yellow))
                                    (blue . ,(clr #:color/blue))
                                    (magenta . ,(clr #:color/magenta))
                                    (cyan . ,(clr #:color/cyan))))))))))))))

(define (font-weight->style weight)
  (->> weight
       symbol->string
       (string-delete #\-)
       string-capitalize))

(define (alacritty-terminal)
  (list
   (file-append alacritty "/bin/alacritty")))
#+end_src
****** Doom vterm
Does this belong in [[*Apps][Apps]]?
#+begin_src scheme
(define* (doom-vterm-app #:key setup-zsh?)
  (list
   (doom-service
    'vterm
    #:modules '((#:term
                 vterm)))

   (when setup-zsh?
     (simple-service
      'doom-vterm-zsh
      home-zsh-service-type
      (home-zsh-extension
       (zshrc
        (list (local-file "zsh-vterm"))))))))

(define (doom-vterm-terminal emacs-handler)
  (list
   (emacs-handler
    "vterm"
    '((+vterm/here nil)))))
#+end_src
******* Configure zsh for vterm
- TODO Changed the org source block type to "org" from "sh" because there's a fontification error. Maybe use zsh as the babel language instead of sh/bash, if it exists?
#+begin_src org :tangle (meta-in-dir "zsh-vterm")
vterm_printf(){
    if [ -n "$TMUX" ] && ([ "${TERM%%-*}" = "tmux" ] || [ "${TERM%%-*}" = "screen" ] ); then
        # Tell tmux to pass the escape sequences through
        printf "\ePtmux;\e\e]%s\007\e\\" "$1"
    elif [ "${TERM%%-*}" = "screen" ]; then
        # GNU screen (screen, screen-256color, screen-256color-bce)
        printf "\eP\e]%s\007\e\\" "$1"
    elif ([ "${TERM%%-*}" = "eterm" ] || [ "${TERM%%-*}" = "dumb" ]); then
        # Do nothing for Emacs' term and ansi-term, and other dumb terminals.
    else
        printf "\e]%s\e\\" "$1"
    fi
}

vterm_prompt_end() {
    # USERNAME=$(whoami)
    # HOSTNAME=$(hostname)
    vterm_printf "51;A$USER@$HOST:$(pwd)";
}
setopt PROMPT_SUBST
PROMPT=$PROMPT'%{$(vterm_prompt_end)%}'
#+end_src
***** Web browsers
****** Chromium
#+begin_src scheme
(define* (chromium-app #:key
                       stateless?
                       wayland?
                       pipewire?
                       theme
                       gtk-services
                       (flavors '(#:google-chrome)))
  (append
   (list
    (simple-service
     'chromium-add-packages
     home-profile-service-type
     (let ((wrapper (lambda (package)
                      (chromium-wrapper package wayland? pipewire? theme))))
       (append
        (if (chromium? flavors)
            (append
             (if (member #:ungoogled-chromium flavors)
                 (list (wrapper ungoogled-chromium)) '())
             (if (member #:chromium flavors)
                 (list (wrapper chromium+drm)) '())
             (list ublock-origin/chromium))
            '())
        (if (chrome? flavors)
            (list (wrapper google-chrome-stable)) '()))))

    (when stateless?
      (home-stateless-service
       'chromium
       #:state (append
                (if (chromium? flavors)
                    '(((#:path . ("chromium/" #:xdg-base "XDG_CACHE_HOME"))
                       (#:storage . #:machine)
                       (#:mode . #o700))
                      ((#:path . ("chromium/" #:xdg-base "XDG_CONFIG_HOME"))
                       (#:storage . #:machine)
                       (#:mode . #o700)))
                    '())
                (if (chrome? flavors)
                    '(((#:path . ("google-chrome/" #:xdg-base "XDG_CACHE_HOME"))
                       (#:storage . #:machine)
                       (#:mode . #o700))
                      ((#:path . ("google-chrome/" #:xdg-base "XDG_CONFIG_HOME"))
                       (#:storage . #:machine)
                       (#:mode . #o700)))
                    '())
                '(((#:path . ".pki/nssdb/")
                   (#:storage . #:machine)
                   (#:mode . #o700)
                   (#:parent-dir-perms . ((#:mode . #o700))))))
       #:ignore (if (chrome? flavors)
                    ;; Weird that Chrome creates this, it's not even in one of the recognized locations (https://wiki.archlinux.org/title/XDG_MIME_Applications#mimeapps.list). Also it's perpetually empty. Whatever, ignore it.
                    '(((#:path . ("mimeapps.list" #:xdg-base "XDG_DATA_HOME"))
                       (#:preds . ((#:empty-file)))))
                    #f))))

   (or gtk-services '())))

(define (chromium-wrapper package wayland? pipewire? theme)
  ;; (let ((flags (append
  ;;               (if wayland?
  ;;                   '((#:switches . '("--ozone-platform-hint=auto"))) '())
  ;;               (if pipewire?
  ;;                   '((#:features . '("WebRTCPipeWireCapturer"))) '())
  ;;               ;; Currently Chromium doesn't detect the light/dark-ness of the GTK theme for the `prefers-color-scheme' media query: https://bugs.chromium.org/p/chromium/issues/detail?id=998903
  ;;               (if (equal? theme #:theme/dark)
  ;;                   '((#:switches . '("--force-dark-mode"))
  ;;                     (#:features . '("WebUIDarkMode")))
  ;;                   '()))))
  ;;   (as-> flags $
  ;;         (apply merge-with append $)
  ;;         (let ((switches-args
  ;;                (apply append (assoc-ref $ #:switches)))
  ;;               (features-arg
  ;;                (let ((features (assoc-ref $ #:features)))
  ;;                  (when features
  ;;                    (string-append "--enable-features="
  ;;                                   (string-join features ","))))))
  ;;           (append switches-args
  ;;                   (or (list features-arg) '())))
  ;;         (string-join $)
  ;;         ;; Not done yet. This is where I'd add the command line args to a package wrapper like e.g. `ungoogled-chromium/wayland' does.
  ;;         ))
  package)

(define (chromium? flavors)
  (or (member #:ungoogled-chromium flavors)
      (member #:chromium flavors)))

(define (chrome? flavors)
  (member #:google-chrome flavors))
#+end_src
******* Setup instructions
It might be possible to configure some of these in a file (perhaps =master-preferences.json=, changing which would require modifying and thus rebuilding the chromium package). Ungoogled Chromium -specific features might not be configurable the same way as Chromium ones, if at all.
******** Chromium
- Settings > Appearance > Use GTK+ theme
- Settings > On startup, check "Continue where you left off"
- Right-click on the Bookmarks bar and uncheck "Show bookarks bar"
********* Ungoogled Chromium
- Settings > Manage search engines, make google the default
  It might not appear under "Other Search Engines" until you search something on google.com
- chrome://settings/cookies > uncheck "Clear cookies and site data when you close all windows"
******** uBlock extension
chrome://extensions > uBlock Origin > Details > Allow in Incognito
****** Firefox
It might be possible to statically configure Firefox (or one of its relatives), check out the Icecat profiles in RDE =gnu/home-services/web-browsers.scm=.
#+begin_src scheme
(define* (firefox-app #:key
                      stateless?
                      wayland?
                      gtk-services)
  (append
   (list
    (simple-service
     'firefox-add-packages
     home-profile-service-type
     (list (if wayland?
               firefox/wayland
               firefox)))

    (when stateless?
      (home-stateless-service
       'firefox
       #:state '(((#:path . ("mozilla/firefox/" #:xdg-base "XDG_CACHE_HOME"))
                  (#:storage . #:machine)
                  (#:mode . #o700)
                  (#:parent-dir-perms . ((#:mode . #o700))))
                 ((#:path . ".mozilla/firefox")
                  (#:storage . #:machine)
                  (#:mode . #o700)
                  (#:parent-dir-perms . ((#:mode . #o700))))
                 ((#:path . ".mozilla/extensions")
                  (#:storage . #:machine)
                  (#:mode . #o700)
                  (#:parent-dir-perms . ((#:mode . #o700))))))))

   (or gtk-services '())))
#+end_src
****** Nyxt
- TODO Add ~gtk-services~ param if Nyxt uses gtk settings (font, light/dark theme).
#+begin_src scheme
(define* (nyxt-app #:key
                   stateless?
                   doom?)
  (list
   (simple-service
    'nyxt-add-packages
    home-profile-service-type
    (list nyxt
          ;; gst-libav
          ;; gst-plugins-bad
          ;; gst-plugins-base
          ;; gst-plugins-good
          ;; gst-plugins-ugly
          ))

   ;; (when stateless?
   ;;   (home-stateless-service
   ;;    'nyxt
   ;;    #:state '(((#:path . ("nyxt/" #:xdg-base "XDG_CACHE_HOME"))
   ;;               (#:storage . #:machine))
   ;;              ((#:path . ("webkitgtk/" #:xdg-base "XDG_DATA_HOME"))
   ;;               (#:storage . #:machine)))))

   (when doom?
     (doom-service
      'nyxt
      #:modules '((#:lang
                   common-lisp))))))
#+end_src
****** Tor browser
Not available in Guix, install through Nix.
- TODO Add ~gtk-services~ param if Tor browser uses gtk settings (font, light/dark theme). Note that (the Nix package) seems to use use a fake Home directory under =~/.local/share/tor-browser=, notably there's a =.config/glib-2.0=, so it might not be possible (or even just advisable?) to use the global gtk settings. Screw it if so.
#+begin_src scheme
(define* (tor-browser-app #:key stateless?)
  (list
   (when stateless?
     (home-stateless-service
      'tor-browser
      #:state '(((#:path . ("tor-browser/" #:xdg-base "XDG_DATA_HOME"))
                 (#:storage . #:machine)))))))
#+end_src
***** Video
****** VLC
#+begin_src scheme
(define* (vlc-app #:key
                  stateless?
                  qt-services)
  (append
   (list
    (simple-service
     'vlc-add-packages
     home-profile-service-type
     (list vlc))

    (when stateless?
      (home-stateless-service
       'vlc
       #:state '(((#:path . ("vlc/" #:xdg-base "XDG_CONFIG_HOME"))
                  (#:storage . #:machine))
                 ((#:path . ("vlc/" #:xdg-base "XDG_DATA_HOME"))
                  (#:storage . #:machine))))))

   (or qt-services '())))
#+end_src
***** Graphical toolkits
****** GTK
It's not totally clear what parts of this are Wayland-specific or if it's necessary to put e.g. ~gtk-theme-name~ in =settings.ini= for non-Wayland (see [[https://github.com/swaywm/sway/wiki/GTK-3-settings-on-Wayland][GTK 3 settings on Wayland · swaywm/sway Wiki · GitHub]].
#+begin_src scheme
(define* (gtk-services #:key
                       stateless?
                       theme
                       font
                       font-monospace)
  (list
   (simple-service
    'gtk-add-packages
    home-profile-service-type
    (list arc-theme
          ;; I copied the following from Andrew Tropin's config. I'm not sure why I'd need or want all of them (perhaps as fallbacks and in the case of `gnome-themes-extra' as a fallback GTK 2 theme?). I might get rid of some of them later but for now I'll try having more than less.
          hicolor-icon-theme ; Andrew Tropin indicates (in abcdw/rde@3a8ea85f) that this is needed for network manager applet icons.
          adwaita-icon-theme
          ;; papirus-icon-theme ; TODO Remove for now, it massively increases guix build time. Why?
          gnome-themes-extra))

   (simple-service
    'gtk-settings-and-dconf
    home-multi-xdg-configuration-files-service-type
    `(("gtk-3.0/settings.ini"
       ,(ini-file
         "gtk-3.0-settings.ini"
         `((Settings ((gtk-application-prefer-dark-theme . ,(equal? theme #:theme/dark)))))))
      ("dconf/user"
       ,(dconf-db
         "dconf-user"
         `((org/gnome/desktop/interface
            ((gtk-theme . ,(quoted-symbol
                            (case theme
                              ((#:theme/light) "Arc")
                              ((#:theme/dark) "Arc-Dark"))))
             (font-name . ,(quoted-symbol
                            (font-specification font)))
             (monospace-font-name . ,(quoted-symbol
                                      (font-specification font-monospace))))))))))

   (when stateless?
     (home-stateless-service
      'gtk
      #:state '(((#:path . ("recently-used.xbel" #:xdg-base "XDG_DATA_HOME"))
                 (#:storage . #:machine)))))))

(define (dconf-db name settings)
  (computed-file
   name
   (with-imported-modules '((guix build utils))
     #~(begin
         (use-modules ((guix build utils) #:select (invoke)))
         (invoke
          #$(file-append dconf "/bin/dconf")
          "compile"
          #$output
          #$(file-union ; Target of `compile` must be a directory.
             "dconf-keyfiledir"
             `(("dconf-keyfile"
                ,(ini-file
                  "dconf-keyfile"
                  settings)))))))))

(define (quoted-symbol s)
  (string->symbol (string-append "'" s "'")))
#+end_src
****** Qt
#+begin_src scheme
(define* (qt-services #:key stateless?)
  (list
   (when stateless?
     (home-stateless-service
      'qt
      #:state '(((#:path . ("QtProject.conf" #:xdg-base "XDG_CONFIG_HOME"))
                 (#:storage . #:machine)))))))
#+end_src
***** Flatpak
I might need to run apps specially for Wayland, see [[https://github.com/swaywm/sway/wiki/Running-programs-natively-under-Wayland#flatpak][Running programs natively under Wayland · swaywm/sway Wiki · GitHub (Flatpak)]]
#+begin_src scheme
(define* (flatpak-apps #:key
                       stateless?
                       portal-services)
  (append
   (list
    (simple-service
     'flatpak-add-packages
     home-profile-service-type
     (list flatpak))

    (simple-service
     'flatpak-exports
     home-environment-variables-service-type
     `(("XDG_DATA_DIRS" . "$XDG_DATA_DIRS${XDG_DATA_DIRS:+:}$XDG_DATA_HOME/flatpak/exports/share")))

    (when stateless?
      (home-stateless-service
       'flatpak
       #:state '(((#:path . ("flatpak/" #:xdg-base "XDG_DATA_HOME"))
                  (#:storage . #:machine)
                  (#:mode . #o700))))))

   (or portal-services '())))
#+end_src
****** Setup instructions
#+begin_src sh :tangle no
flatpak remote-add --user --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo
# flatpak remote-add --user --if-not-exists flathub-beta https://flathub.org/beta-repo/flathub-beta.flatpakrepo

# flatpak install --user flathub com.discordapp.Discord
# flatpak install --user flathub-beta com.obsproject.Studio
# ...
#+end_src
*** Work
#+begin_src scheme
(define* (work #:key
               stateless?
               (work-dir "work")
               projects)
  (append
   (if projects
       (append-map
        (match-lambda
          ((dir . opts)
           (let* ((dir* (string-append "/.persist/home/pharcosyle" "/" "work_for_now" "/" dir))
                  ;; (dir* (string-append (getenv "HOME") "/" work-dir "/" dir))
                  (proj-file (string-append dir* "/project.scm")))
             (if (file-exists? proj-file)
                 ;; TODO figure out the "add declarative" warning. Maybe rewrite to use `add-to-load-path'.
                 (apply (load proj-file) (->> opts
                                              (acons #:dir dir*)
                                              alist->list))
                 '()))))
        projects)
       '())

   (list
    (when stateless?
      (home-stateless-service
       'projects
       #:state `(((#:path . ,(string-append work-dir "/"))
                  (#:storage . #:persist))))))))
#+end_src
**** Project helpers
#+begin_src scheme
(define (services-only-packages svcs)
  (services-packages filter svcs))

(define (services-sans-packages svcs)
  (services-packages remove svcs))

(define (services-packages f svcs)
  (f (lambda (s)
       (and (service? s)
            (equal? (service-kind s) home-profile-service-type)))
     svcs))
#+end_src
*** Shared
#+begin_src scheme
(define* (skeleton-file file)
  (-> (default-skeletons)
      (assoc-ref file)
      car))

(define home-multi-xdg-configuration-files-service-type
  (service-type
   (inherit home-xdg-configuration-files-service-type)
   (compose
    (lambda (exts)
      (as-> exts $
            (delete-duplicates $ (lambda (a b)
                                   (equal? (car a) (car b))))
            (apply append $))))))

(define (home-shepherd-service-log-file file)
  #~(string-append
     (or (getenv "XDG_LOG_HOME")
         (string-append (getenv "HOME") "/.local/var/log"))
     "/" #$file))

(define very-big-history 1000000)
#+end_src
** Composite components
*** OS features
- TODO rename this "System features"?
#+begin_src scheme
(define* (os-features #:key
                      stateless?
                      stateless-storage-paths
                      login-shell
                      doom?
                      doom-flags
                      guix?
                      nix?
                      console?
                      kmonad?
                      desktop?
                      pipewire?
                      login-manager
                      desktop-tty-start-cmds
                      sessions
                      sway-environment
                      virtualization?)
  (append
   (if stateless?
       (stateless #:storage-paths stateless-storage-paths) '())
   (if guix?
       (guix-pm #:stateless? stateless?
                #:doom? doom?)
       '())
   (if nix?
       (nix-pm #:stateless? stateless?
               #:doom? doom?
               #:doom-tree-sitter? (assoc-ref doom-flags #:doom/tree-sitter?)
               #:login-shell login-shell)
       '())
   (if console?
       (if kmonad?
           (kmonad-tool #:doom? doom?) '())
       '())
   (if desktop?
       (let ((dbus? (not login-manager)))
         (append
          (if pipewire?
              (pipewire-multimedia #:stateless? stateless?
                                   #:dbus? dbus?)
              '())
          (if dbus?
              (dbus-ipc) '())
          (if login-manager
              (case login-manager
                ((#:lm/gdm) (gdm #:stateless? stateless?)))
              (desktop-tty #:sessions sessions
                           #:start-cmds desktop-tty-start-cmds))
          (if (member #:session/gnome (or sessions '()))
              (gnome-desktop #:stateless? stateless?) '())
          (if (member #:session/sway (or sessions '()))
              sway-environment '())))
       '())
   (if virtualization?
       (virtualization) '())))
#+end_src
*** Sway environment
#+begin_src scheme
(define* (sway-environment #:key
                           pipewire?
                           connection-manager
                           doom?
                           portal-services
                           colors
                           (wallpaper (assoc-ref %wallpapers #:wallpaper/alucard))
                           fonts
                           font-variable-pitch
                           (date-format %date-format)
                           (time-format %time-format)
                           emacs-editor
                           (screen-locker (swaylock-screen-locker))
                           (menu (if doom?
                                     (doom-menu (assoc-ref emacs-editor #:emacs/handler))
                                     (rofi-menu #:wayland? #t))))
  (let ((session #:session/sway))
    (append
     (sway-wm #:pipewire? pipewire?
              #:doom? doom?
              #:portal-services portal-services
              #:bg-image wallpaper
              #:kb-layout ((@ (gnu system keyboard) keyboard-layout) "us" #:model "macbook78") ; TODO
              #:idle-manager (swayidle-idle-manager)
              #:screen-locker (assoc-ref screen-locker #:screen-locker/lock-immediately)
              #:notifier (mako-notifier (assoc-ref menu #:menu/menu))
              #:status-bar (waybar-status-bar)
              #:applets (list
                         (case connection-manager
                           ((#:cm/network-manager) (network-manager-applet)))
                         ;; (gammastep-applet)
                         (udiskie-applet))
              #:app-launcher (assoc-ref menu #:menu/app-launcher)
              #:terminal (if doom?
                             (doom-vterm-terminal (assoc-ref emacs-editor #:emacs/handler))
                             (alacritty-terminal))
              #:backup-terminal (if doom?
                                    (list
                                     (file-append (@ (gnu packages terminals) foot) "/bin/foot"))
                                    ;; (alacritty-terminal)
                                    #f)
              #:emacs-editor emacs-editor)
     (swaylock-wm-piece #:colors colors
                        #:image wallpaper
                        #:font (assoc-ref fonts font-variable-pitch)
                        #:date-format date-format
                        #:time-format time-format)
     ;; (swayidle-wm-piece #:session session
     ;;                    #:screen-locker (assoc-ref screen-locker #:screen-locker/lock))
     (mako-wm-piece #:colors colors
                    #:font (assoc-ref fonts font-variable-pitch))
     (waybar-wm-piece #:colors colors
                      #:font (assoc-ref fonts font-variable-pitch)
                      #:modules (waybar-modules #:session session
                                                #:date-format date-format
                                                #:time-format time-format))
     ;; (kanshi-wm-piece)
     (case connection-manager
       ((#:cm/network-manager) (network-manager-wm-applet)))
     ;; (gammastep-wm-applet)
     (udiskie-wm-applet))))
#+end_src
*** Programs
#+begin_src scheme
(define* (programs #:key
                   stateless?
                   interactive-shells
                   doom?
                   doom-flags
                   email
                   desktop?
                   emacs-editor)
  (append
   (direnv-prog #:doom? doom?
                #:shells interactive-shells)
   (protonvpn-prog #:stateless? stateless?)
   ;; (ssh-prog)
   (git-prog #:stateless? stateless?
             #:doom? doom?
             #:email email)
   (if doom?
       (append
        (if (assoc-ref doom-flags #:doom/calendar?)
            (doom-calendar-prog #:stateless? stateless?
                                #:org? (assoc-ref doom-flags #:doom/org?))
            '())
        (if (assoc-ref doom-flags #:doom/org?)
            (doom-org-prog #:stateless? stateless?
                           #:evil? (assoc-ref doom-flags #:doom/evil?))
            '())
        (doom-dired-prog #:stateless? stateless?
                         #:icons? (assoc-ref doom-flags #:doom/icons?)
                         #:desktop? desktop?
                         #:emacs-handler (assoc-ref emacs-editor #:emacs/handler))
        (doom-trash-prog))
       '()) ; Maybe have some alternatives for non-Doom here: Some file manager, trash-cli...
   (misc-progs)))
#+end_src
*** Applications
#+begin_src scheme
(define* (applications #:key
                       stateless?
                       pipewire?
                       doom?
                       theme
                       colors
                       fonts
                       font-variable-pitch
                       wayland?)
  (let ((gtk (gtk-services #:stateless? stateless?
                           #:theme theme
                           #:font (assoc-ref fonts font-variable-pitch)
                           #:font-monospace (assoc-ref fonts #:fonts/mono)))
        ;; (qt (qt-services #:stateless? stateless?))
        )
    (append
     (pavucontrol-app #:stateless? stateless?
                      #:gtk-services gtk)
     (if doom?
         (doom-menu-app)
         (rofi-app #:stateless? stateless?
                   #:wayland? wayland?
                   #:colors colors
                   #:font (assoc-ref fonts font-variable-pitch)))
     ;; (zoom-app #:stateless? stateless?
     ;;           #:qt-services qt)
     ;; (gimp-app #:stateless? stateless?
     ;;           #:gtk-services gtk)
     (alacritty-app #:colors colors
                    #:font (assoc-ref fonts #:fonts/mono))
     (if doom?
         (doom-vterm-app #:setup-zsh? #t
                         ;; TODO
                         ;; #:setup-zsh? (member #:shell/zsh interactive-shells)
                         )
         '())
     (chromium-app #:stateless? stateless?
                   #:wayland? wayland?
                   #:pipewire? pipewire?
                   #:theme theme
                   #:gtk-services gtk)
     ;; (firefox-app #:stateless? stateless?
     ;;              #:wayland? wayland?
     ;;              #:gtk-services gtk)
     (nyxt-app #:stateless? stateless?
               #:doom? doom?)
     ;; (tor-browser-app #:stateless? stateless?)
     ;; (vlc-app #:stateless? stateless?
     ;;          #:qt-services qt)
     )))
#+end_src
*** Base
#+begin_src scheme
(define* (he-base #:key
                  stateless?
                  stateless-storage-paths
                  (interactive-shells '(#:shell/zsh))
                  doom?
                  doom-flags
                  guix?
                  nix?
                  console?
                  kmonad?
                  desktop?
                  pipewire?
                  connection-manager
                  login-manager
                  sessions
                  virtualization?
                  email
                  projects)
  (let* ((login-shell #:shell/bash)
         (emacs-package %emacs-package)
         (emacs-editor (emacs-editor #:emacs emacs-package))
         (doom-flags (acons #:doom/icons? #t doom-flags))
         (theme #:theme/dark)
         (light-colors %light-colors)
         (dark-colors %dark-colors)
         (colors dark-colors)
         (fonts %fonts)
         (font-variable-pitch #:fonts/sans)
         (wayland? #t)
         (portal-services (portal-services #:wayland? wayland?)))
    (append
     (os-features #:stateless? stateless?
                  #:stateless-storage-paths stateless-storage-paths
                  #:login-shell login-shell
                  #:doom? doom?
                  #:doom-flags doom-flags
                  #:guix? guix?
                  #:nix? nix?
                  #:console? console?
                  #:kmonad? kmonad?
                  #:desktop? desktop?
                  #:pipewire? pipewire?
                  #:login-manager login-manager
                  #:desktop-tty-start-cmds `((#:session/gnome . ,(gnome-start))
                                             (#:session/sway . ,(sway-start pipewire?)))
                  #:sessions sessions
                  #:sway-environment (sway-environment #:pipewire? pipewire?
                                                       #:connection-manager connection-manager
                                                       #:doom? doom?
                                                       #:portal-services portal-services
                                                       #:colors colors
                                                       #:fonts fonts
                                                       #:font-variable-pitch font-variable-pitch
                                                       #:emacs-editor emacs-editor)
                  #:virtualization? virtualization?)
     (shells #:stateless? stateless?
             #:doom? doom?
             #:doom-tree-sitter? (assoc-ref doom-flags #:doom/tree-sitter?)
             #:login-shell login-shell
             #:interactive-shells interactive-shells)
     (emacs #:emacs emacs-package)
     (if doom?
         (append
          (doom #:stateless? stateless?
                #:services (doom-core #:stateless? stateless?
                                      #:evil? (assoc-ref doom-flags #:doom/evil?)
                                      #:icons? (assoc-ref doom-flags #:doom/icons?)
                                      #:email email))
          (if desktop?
              (doom-desktop #:theme theme
                            #:light-colors light-colors
                            #:dark-colors dark-colors
                            #:font (assoc-ref fonts #:fonts/mono)
                            #:font-variable-pitch (assoc-ref fonts font-variable-pitch)
                            #:font-unicode (assoc-ref fonts #:fonts/unicode)
                            #:font-serif (assoc-ref fonts #:fonts/serif))
              '()))
         '())
     (programs #:stateless? stateless?
               #:interactive-shells interactive-shells
               #:doom? doom?
               #:doom-flags doom-flags
               #:email email
               #:desktop? desktop?
               #:emacs-editor emacs-editor)
     (if desktop?
         (append
          (font-library #:stateless? stateless?
                        #:packages (append
                                    (map (lambda (font)
                                           (assoc-ref font #:font/package))
                                         fonts)
                                    %font-packages-misc))
          (xdg #:stateless? stateless?)
          (mesa #:stateless? stateless?)
          (applications #:stateless? stateless?
                        #:pipewire? pipewire?
                        #:doom? doom?
                        #:theme theme
                        #:colors colors
                        #:fonts fonts
                        #:font-variable-pitch font-variable-pitch
                        #:wayland? wayland?)
          (flatpak-apps #:stateless? stateless?
                        #:portal-services portal-services))
         '())
     (work #:stateless? stateless?
           #:projects projects))))
#+end_src
* Common
:PROPERTIES:
:meta-dir+: /phrenetic
:END:
** Packages
:PROPERTIES:
:meta-dir+: /packages
:END:
*** KMonad :package:version:upstream:
#+begin_src scheme :tangle (meta-in-dir "haskell-apps.scm")
(define-module (phrenetic packages haskell-apps)
  #:use-module (guix gexp)
  #:use-module (guix packages)
  #:use-module ((guix utils) #:select (substitute-keyword-arguments))
  #:use-module ((gnu packages haskell-apps) #:select (kmonad) #:prefix haskell-apps:)
  #:use-module ((gnu packages haskell-check) #:select (ghc-hspec hspec-discover))
  #:use-module (phrenetic utils))

(define-public kmonad
  (let ((commit "cbdace2bb7b27e47c2397e662265a28a1030b7c7"))
    (with-git-commit
     (package
       (inherit haskell-apps:kmonad)
       (arguments
        (substitute-keyword-arguments (package-arguments haskell-apps:kmonad)
          ((#:phases phases '%standard-phases)
           #~(modify-phases #$phases
               (add-after 'unpack 'patch-git-revision
                 (lambda _
                   (substitute* "src/KMonad/Args/Cmd.hs"
                     (("\\$\\(gitHash\\)") (string-append "\"" #$commit "\"")))))))))
       (inputs
        (modify-inputs (package-inputs haskell-apps:kmonad)
          (prepend ghc-hspec
                   hspec-discover))))
     #:commit commit
     #:hash "1kgnf0yv7h8scfacwdj3l1lrmjibjri5ybbnyw5m8wn6sjxbpaab")))
#+end_src
** Stateless
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "stateless.scm")
:END:
#+begin_src scheme
(define-module (phrenetic stateless)
  #:use-module (guix gexp)
  #:use-module ((guix modules) #:select (source-module-closure))
  #:use-module (guix packages)
  #:use-module (gnu services)
  #:use-module (phrenetic utils)
  #:export (service-fn
            extend-proc
            tool-package))
#+end_src
*** Service
**** Service extension
#+begin_src scheme
(define (service-fn service-type)
  (lambda* (name #:key state ignore)
    (simple-service
     (symbol-append name '-stateless)
     service-type
     `((#:state . ,state)
       (#:ignore . ,ignore)))))
#+end_src
**** Extend procedure
#+begin_src scheme
(define (extend-proc config exts)
  (let ((exts* (apply merge-with append exts)))
    (->> (apply list->alist config)
         (acons #:state (assoc-ref exts* #:state))
         (acons #:ignore (assoc-ref exts* #:ignore)))))
#+end_src
*** Tool
#+begin_src scheme
(define* (tool-package bin-name #:rest opts)
  (package
    (inherit simple-package)
    (name "stateless")
    (source (tool-program opts))
    (arguments
     `(#:builder
       ,#~(begin
            (let ((bin (string-append #$output "/bin")))
              (mkdir #$output)
              (mkdir bin)
              (symlink #$source (string-append bin "/" #$bin-name))))))))

(define (tool-program opts)
  (program-file
   "stateless"
   (with-imported-modules '((guix build utils) (phrenetic build utils) (phrenetic build stateless))
     ;; (source-module-closure
     ;;  '((phrenetic build stateless))
     ;;  #:select? (const #t)
     ;;  ;; #:select? (lambda (name)
     ;;  ;;             (or ((@ (guix modules) guix-module-name?) name)
     ;;  ;;                 (eq? (car name) 'phrenetic)))
     ;;  )
     #~(begin
         (use-modules ((phrenetic build stateless) #:select (tool)))
         (apply tool '#$opts)))))
#+end_src
*** Build
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "build/stateless.scm")
:END:
#+begin_src scheme
(define-module (phrenetic build stateless)
  #:use-module ((guix build utils) #:select (copy-recursively delete-file-recursively find-files mkdir-p store-file-name? symbolic-link?))
  #:use-module (phrenetic build utils)
  #:use-module ((ice-9 ftw) #:select (file-system-fold))
  #:use-module ((srfi srfi-1) #:select (any))
  #:use-module ((ice-9 match) #:select (match-lambda))
  #:export (activate
            tool))
#+end_src
**** Activate
#+begin_src scheme
(define (activate state
                  backup-base-dir
                  storage-paths)
  (define (run)
    (for-each process-state-entry state))

  (define (process-state-entry i)
    (let* ((path (assoc-ref i #:path))
           (directory-target? (string-suffix? "/" path))
           (target (if directory-target?
                       (string-drop-right path 1) path))
           (storage-dir (assoc-ref storage-paths (assoc-ref i #:storage))))
      (let ((parent-dir (dirname path))
            (parent-dir-perms (assoc-ref i #:parent-dir-perms)))
        (mkdirp-perms (string-append storage-dir parent-dir) parent-dir-perms)
        (mkdirp-perms parent-dir parent-dir-perms))
      (let ((state-file (string-append storage-dir target)))
        (cleanup-and-migrate target state-file storage-dir)
        (when directory-target?
          (mkdirp-perms state-file i))
        (when (no-follow-file-exists? state-file)
          (symlink state-file target)))))

  (define (cleanup-and-migrate target state-file storage-dir)
    (let ((migrate-file
           (lambda (source dest)
             (copy-recursively source dest)
             (delete-file-recursively source)))
          (backup-file
           (lambda (file)
             (let* ((backup-dir (string-append
                                 storage-dir
                                 backup-base-dir
                                 "/stateless-backup-" (number->string timestamp)))
                    (backup-file (string-append
                                  backup-dir "/"
                                  (let* ((string-drop-prefix (lambda (s prefix)
                                                               (string-drop s (string-length prefix))))
                                         (without-storage-dir (lambda (file)
                                                                (string-drop-prefix file storage-dir)))
                                         (without-base-dir (lambda (file)
                                                             (string-drop-prefix file backup-base-dir))))
                                    ((compose without-base-dir
                                              without-storage-dir)
                                     file)))))
               (mkdir-p (dirname backup-file))
               (rename-file file backup-file)))))
      (when (no-follow-file-exists? target)
        (if ((symlink-to-storage? (map (match-lambda ((_ . dir) dir))
                                       storage-paths))
             target)
            (delete-file target)
            (begin
              (when (no-follow-file-exists? state-file)
                (if (nil? (find-files state-file)) ; TODO did I have `nil?` instead of `null?` for some reason or was it just an accident?
                    (delete-file-recursively state-file)
                    (backup-file state-file)))
              (migrate-file target state-file))))))

  (define (mkdirp-perms dir perms)
    (mkdir-p dir)
    (chown dir
           (let ((user (assoc-ref perms #:user)))
             (if user
                 (passwd:uid (getpwnam user)) -1))
           (let ((group (assoc-ref perms #:group)))
             (if group
                 (group:gid (getgrnam group)) -1)))
    (let ((mode (assoc-ref perms #:mode)))
      (when mode
        (chmod dir mode))))

  (define timestamp (current-time))

  (run))
#+end_src
**** Tool
#+begin_src scheme
;;;;;;;;;; TODO TEMPORRARY REMOVE ME
;; (define-module (phrenetic build stateless)
;;   #:use-module ((guix build utils) #:select (copy-recursively delete-file-recursively find-files mkdir-p store-file-name? symbolic-link?))
;;   #:use-module (phrenetic build utils)
;;   #:use-module ((ice-9 ftw) #:select (file-system-fold))
;;   #:use-module ((srfi srfi-1) #:select (any))
;;   #:export (activate
;;             tool))
;;;;;;;

(use-modules ;; ((guix build utils) #:select (find-files))
 ((srfi srfi-1) #:select (append-map every partition))
 ((srfi srfi-11) #:select (let-values))
 ((ice-9 ftw) #:select (scandir))
 ((ice-9 match) #:select (match match-lambda))
 ((ice-9 textual-ports) #:select (get-string-all)))


(define* (tool state
               ignore
               base-dir
               storage-paths)
  (let ((state* (normalize-entries state))
        (all-ignore (normalize-entries ignore)))
    (for-each
     (lambda (path)
       (display (string-append path "\n")))
     (case (run-mode)
       ((active) (diff-live state*
                            (filter (lambda (entry)
                                      (not (assoc-ref entry #:storage)))
                                    all-ignore)
                            base-dir
                            storage-paths))
       ((storage) (diff-storage (map (match-lambda ((_ . dir) dir))
                                     storage-paths)
                                state*
                                (filter (lambda (entry)
                                          (assoc-ref entry #:storage))
                                        all-ignore)
                                base-dir
                                storage-paths))))))

(define (run-mode)
  (string->symbol
   (or
    (false-if-exception (cadr (command-line)))
    ;; "active"
    "storage" ; TODO temporary for testing
    )))

(define (diff-live state
                   ignore
                   base-dir
                   storage-paths)
  (let-values (((ignore-files ignore-dirs) (files+dirs ignore)))
    (diff base-dir
          (append (state->known-symlinks state storage-paths)
                  (ignore->known ignore-files))
          (ignore->known ignore-dirs)
          #:omit-empty-dirs? #t)))

(define (normalize-entries entries)
  (map (lambda (entry)
         (let ((path (assoc-ref entry #:path)))
           (if (string-suffix? "/" path)
               (->> entry
                    (acons #:directory? #t)
                    (acons #:path (string-drop-right path 1)))
               entry)))
       entries))

;; TODO probably just do two filter statements instad of this.
(define (files+dirs entries)
  (partition (lambda (entry)
               (not (assoc-ref entry #:directory?)))
             entries))

(define (state->known-symlinks state storage-paths)
  (map (lambda (entry)
         (let ((path (assoc-ref entry #:path)))
           (cons path `((#:symlink-to ,(string-append
                                        (assoc-ref storage-paths (assoc-ref entry #:storage))
                                        path))))))
       state))

(define (ignore->known ignore)
  (map (lambda (entry)
         (cons (assoc-ref entry #:path)
               (or (assoc-ref entry #:preds)
                   '())))
       ignore))


;; (define (file-entries entries)
;;   (filter (lambda (entry)
;;                (not (assoc-ref entry #:directory?)))
;;              entries))

(define (storage-entries storage entries)
  (filter (lambda (entry)
            (equal? (assoc-ref entry #:storage) storage))
          entries))

(define (entries-with-storage-dir storage-dir entries)
  (map (lambda (entry)
         (acons #:path (string-append storage-dir (assoc-ref entry #:path)) entry))
       entries))

(define (diff-storage storages
                      state
                      ignore
                      base-dir
                      storage-paths)
  (let ((diff* ; TODO rename this
         (lambda (storage)
           (let ((storage-dir (assoc-ref storage-paths storage)))
             (let-values (((state-files state-dirs) (files+dirs state))
                          ((ignore-files ignore-dirs) (files+dirs ignore)))
               (diff (string-append storage-dir base-dir)
                     (append (->> state-files
                                  (storage-entries storage)
                                  (entries-with-storage-dir storage-dir)
                                  (map (lambda (entry)
                                         (cons (assoc-ref entry #:path) '()))))
                             (->> ignore-files
                                  (storage-entries storage)
                                  (entries-with-storage-dir storage-dir)
                                  ignore->known))
                     (append (->> state-dirs
                                  (storage-entries storage)
                                  (entries-with-storage-dir storage-dir)
                                  (map (lambda (entry)
                                         (cons (assoc-ref entry #:path) '()))))
                             (->> ignore-dirs
                                  (storage-entries storage)
                                  (entries-with-storage-dir storage-dir)
                                  ignore->known))))))))
    (append-map diff* storages)))

(define* (diff directory known-files known-dirs #:key omit-empty-dirs?)
  (as-> directory $
        (let* ((test (lambda (path known)
                       (let ((cand (assoc path known)))
                         (and cand
                              (every (match-lambda
                                       ((pred-name args ...)
                                        (apply (assoc-ref predicates pred-name) (cons path args))))
                                     (match cand ((_ . preds) preds))))))))
          (file-system-fold
           (let ((known-paths (map (match-lambda ((path . _) path))
                                   (append known-files known-dirs)))
                 (known-dir-paths (map (match-lambda ((path . _) path))
                                       known-dirs)))
             (fn (lambda (dir _ _*)
                   (and (not (member dir known-dir-paths))
                        (any (lambda (known-path)
                               (string-prefix? dir known-path))
                             known-paths)))))
           (fn (lambda (file _ res)
                 (if (test file known-files)
                     res
                     (cons file res))))
           (fn (lambda (_ _* res)
                 res))
           (fn (lambda (_ _* res)
                 res))
           (fn (lambda (dir _ res)
                 (if (or (test dir known-dirs)
                         (and omit-empty-dirs?
                              (null? (scandir-no-implied dir))))
                     res
                     (cons (string-append dir "/") res))))
           (lambda (path _ errno res) ; TODO use `fn' for this.
             (format (current-error-port) "~a: ~a~%" path (strerror errno))
             res)
           '()
           $))
        (sort $ string<?)))

(define (fn f)
  (lambda (path _ res)
    (let ((asdf (if (string-prefix? "//" path)
                    (string-drop path 1)
                    path)))
      (f asdf _ res))))

(define (scandir-no-implied dir)
  (scandir dir (negate dot-or-dot-dot?)))

(define (dot-or-dot-dot? file)
  (member file '("." "..")))

(define predicates
  `((#:symlink-to . ,(lambda (path to)
                       (and (symbolic-link? path)
                            (equal? (readlink path) to))))
    (#:symlink-to-store . ,(lambda (path)
                             (and (symbolic-link? path)
                                  (store-file-name? (readlink path)))))
    (#:empty-file . ,(lambda (path)
                       (zero? (-> path stat stat:size))))
    (#:empty-dir . ,(lambda (path)
                      (null? (scandir-no-implied path))))
    (#:file-content . ,(lambda (path content)
                         (let ((cont (false-if-exception
                                      (call-with-input-file path
                                        get-string-all))))
                           (and cont
                                (equal? cont content)))))))

(define test-state '(((#:path . "/etc/NetworkManager/system-connections/")
                      (#:storage . #:machine))
                     ((#:path . "/var/lib/NetworkManager/")
                      (#:storage . #:machine)
                      (#:mode . 448))
                     ((#:path . "/etc/machine-id")
                      (#:storage . #:machine))
                     ((#:path . "/var/lib/upower/")
                      (#:storage . #:machine))
                     ((#:path . "/root/.cache/nix/")
                      (#:storage . #:machine))
                     ((#:path . "/etc/guix/signing-key.pub")
                      (#:storage . #:machine)
                      (#:parent-dir-perms
                       (#:mode . 73)))
                     ((#:path . "/etc/guix/signing-key.sec")
                      (#:storage . #:machine)
                      (#:parent-dir-perms
                       (#:mode . 73)))
                     ((#:path . "/root/.cache/guix/")
                      (#:storage . #:machine))
                     ((#:path . "/var/lib/random-seed")
                      (#:storage . #:machine))
                     ((#:path . "/var/db/nscd/")
                      (#:storage . #:machine))
                     ((#:path . "/.lastweek")
                      (#:storage . #:machine))))
(define test-ignore '(((#:path . "nix/")
                       (#:storage . #:machine))
                      ((#:path . "/.machine/.swap")
                       (#:storage . #:machine))
                      ((#:path . "/nix/store/"))
                      ((#:path . "/nix/var/nix/"))
                      ((#:path . "/nix/var/log/nix/"))
                      ((#:path . "/var/guix/"))
                      ((#:path . "/etc/guix/acl")
                       (#:preds
                        (#:symlink-to-store)))
                      ((#:path . "/etc/resolv.conf"))
                      ((#:path . "/etc/resolv.conf.bak"))
                      ((#:path . "/bin/sh")
                       (#:preds
                        (#:symlink-to-store)))
                      ((#:path . "/usr/bin/env")
                       (#:preds
                        (#:symlink-to-store)))
                      ((#:path . "/dev/"))
                      ((#:path . "/proc/"))
                      ((#:path . "/run/"))
                      ((#:path . "/sys/"))
                      ((#:path . "/tmp/"))
                      ((#:path . "/var/lock/"))
                      ((#:path . "/var/run/"))
                      ((#:path . "/etc/group"))
                      ((#:path . "/etc/passwd"))
                      ((#:path . "/etc/shadow"))
                      ((#:path . "/etc/.pwd.lock"))
                      ((#:path . "/etc/mtab")
                       (#:preds
                        (#:symlink-to "/proc/self/mounts")))
                      ((#:path . "/etc/ssl")
                       (#:preds
                        (#:symlink-to "/run/current-system/profile/etc/ssl")))
                      ((#:path . "/etc/static")
                       (#:preds
                        (#:symlink-to-store)))))
(define (test)
  (tool test-state
        test-ignore
        "/"
        `((#:machine . "/.machine")
          (#:persist . "/.persist"))))
;; (test)
#+end_src
**** Shared
#+begin_src scheme
;; TODO Just used in `activate` now
(define (symlink-to-storage? storage-dirs)
  (lambda (file)
    (and (symbolic-link? file)
         (any (lambda (storage-dir)
                (string-prefix? storage-dir (readlink file)))
              storage-dirs))))
#+end_src
* Utils
:PROPERTIES:
:meta-dir+: /phrenetic
:END:
** Host
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "utils.scm")
:END:
#+begin_src scheme
(define-module (phrenetic utils)
  #:use-module (guix build-system trivial)
  #:use-module (guix git-download)
  #:use-module (guix packages)
  #:use-module (phrenetic build utils)
  #:export (simple-package
            with-git-version
            with-git-commit
            with-git-url)
  #:re-export (when-let
               if-let
               when-not
               if-not
               ->
               ->>
               as->
               list->alist
               alist->list
               merge-with
               update-keys
               update-vals
               KiB
               MiB
               GiB))

(define simple-package
  (package
    (name #f)
    (version "0")
    (source #f)
    (build-system trivial-build-system)
    (synopsis #f)
    (description #f)
    (home-page #f)
    (license #f)))
#+end_src
**** Git
#+begin_src scheme
(define (with-git-url pkg url)
  (package
    (inherit pkg)
    (source
     (origin
       (inherit (package-source pkg))
       (uri (git-reference
             (inherit (-> pkg package-source origin-uri))
             (url url)))))))

(define* (with-git-version pkg #:key version commit hash)
  (with-git pkg
            #:upstream-version version
            #:commit commit
            #:hash hash))

(define* (with-git-commit pkg
                          #:key
                          (upstream-version (package-version pkg))
                          (revision "0")
                          commit
                          hash)
  (with-git pkg
            #:upstream-version upstream-version
            #:revision revision
            #:commit commit
            #:hash hash))

(define* (with-git pkg
                   #:key
                   upstream-version
                   revision
                   commit
                   hash)
  (package
    (inherit pkg)
    (version (if revision
                 (git-version upstream-version revision commit)
                 upstream-version))
    (source
     (origin
       (inherit (package-source pkg))
       (uri (git-reference
             (inherit (-> pkg package-source origin-uri))
             (commit commit)))
       (sha256
        (base32
         hash))
       (file-name (git-file-name (package-name pkg) version))))))
#+end_src
** Common and build
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "build/utils.scm")
:END:
#+begin_src scheme
(define-module (phrenetic build utils)
  ;; Common
  #:use-module ((ice-9 match) #:select (match-lambda))
  #:use-module ((srfi srfi-1) #:select (append-map fold take drop))
  #:export (when-let
            if-let
            when-not
            if-not
            ->
            ->>
            as->
            list->alist
            alist->list
            merge-with
            update-keys
            update-vals
            KiB
            MiB
            GiB)
  ;; Build
  #:export (no-follow-file-exists?))
#+end_src
*** Common
**** Branching
#+begin_src scheme
(define-syntax when-let
  (syntax-rules ()
    ((_ ((var expr)) body ...)
     (let ((var expr))
       (when var body ...)))))

(define-syntax if-let
  (syntax-rules ()
    ((_ ((var expr)) then else)
     (let ((var expr))
       (if var then else)))))

(define-syntax when-not
  (syntax-rules ()
    ((_ test body ...)
     (when (not test) body ...))))

(define-syntax if-not
  (syntax-rules ()
    ((_ test then else)
     (if (not test) then else))))
#+end_src
**** Threading
#+begin_src scheme
(define-syntax ->
  (syntax-rules ()
    ((_ x) x)
    ((_ x (f args ...) expr ...) (-> (f x args ...) expr ...))
    ((_ x f expr ...) (-> (f x) expr ...))))

(define-syntax ->>
  (syntax-rules ()
    ((_ x) x)
    ((_ x (f args ...) expr ...) (->> (f args ... x) expr ...))
    ((_ x f expr ...) (->> (f x) expr ...))))

(define-syntax as->
  (lambda (x)
    (syntax-case x ()
      ((_ exp name) #'exp)
      ((_ exp name form form* ...)
       (with-syntax ((x (datum->syntax #'form (syntax->datum #'name))))
         #'(let ((x exp))
             (as-> form name form* ...)))))))
#+end_src
**** Alists
#+begin_src scheme
(define* (list->alist #:rest kvs)
  (let loop ((res '())
             (more kvs))
    (if (null? more)
        res
        (loop (cons (as-> more $
                          (take $ 2)
                          (apply cons $))
                    res)
              (drop more 2)))))

(define (alist->list alist)
  (append-map
   (match-lambda
     ((k . v)
      (list k v)))
   alist))

(define* (merge-with f #:rest alists)
  (fold
   (lambda (a res)
     (map
      (lambda (k)
        (cons k
              (let ((res-v (assoc-ref res k))
                    (v (assoc-ref a k)))
                (if (and res-v v)
                    (f res-v v)
                    (or res-v v)))))
      (let ((keys (lambda (alist)
                    (map car alist))))
        (append (keys res)
                (filter (lambda (k)
                          (not (member k (keys res))))
                        (keys a))))))
   '()
   alists))

(define (update-keys alist f)
  (map (match-lambda
         ((k . v)
          (cons (f k) v)))
       alist))

(define (update-vals alist f)
  (map (match-lambda
         ((k . v)
          (cons k (f v))))
       alist))
#+end_src
**** Byte suffixes
#+begin_src scheme
(define KiB (expt 2 10))
(define MiB (expt 2 20))
(define GiB (expt 2 30))
#+end_src
*** Build
#+begin_src scheme
(define (no-follow-file-exists? f)
  (false-if-exception (lstat f)))
#+end_src
* Configurations
:PROPERTIES:
:meta-dir+: /phrenetic/configs
:END:
** Frostfire
*** Config
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "frostfire.scm")
:END:
#+begin_src scheme
(define-module (phrenetic configs frostfire)
  #:use-module ((phrenetic home) #:prefix he:)
  #:use-module (phrenetic install)
  #:use-module ((phrenetic system) #:prefix os:)
  #:use-module (phrenetic utils)
  #:use-module ((ice-9 match) #:select (match-lambda))
  #:use-module ((srfi srfi-1) #:select (delete-duplicates))
  #:export (system
            installer
            primary-he
            aux-he
            guest-he))

(define stateless? #t)
(define stateless-storage-paths os:%stateless-storage-paths)
#+end_src
**** System
#+begin_src scheme
(define (system)
  (let ((primary-name "pharcosyle")
        (aux-name "pcoulson")
        (guest-name "mellon")
        (bluetooth? #t)
        (stateless-machine-dir (assoc-ref stateless-storage-paths #:machine)))
    (as-> (os-base #:users-info `(((#:name . ,primary-name)
                                   (#:comment . "Krzysztof Baranowski")
                                   (#:admin? . #t))
                                  ((#:name . ,aux-name)
                                   (#:comment . "Phil Coulson")
                                   (#:admin? . #t))
                                  ((#:name . ,guest-name)
                                   (#:comment . "Mellon")))
                   #:kmonad? #t
                   #:kmonad-users (feature-users `((,primary-name . ,primary-he-kmonad?)
                                                   (,aux-name . ,aux-he-kmonad?)
                                                   (,guest-name . ,guest-he-kmonad?)))
                   ;; #:bluetooth? bluetooth?
                   ;; #:bluetooth-users (list primary-name
                   ;;                         aux-name
                   ;;                         guest-name)
                   ;; #:auto-login? disk-encryption?
                   ;; #:auto-login-user primary-name
                   #:sessions (->> (list primary-he-sessions
                                         aux-he-sessions
                                         guest-he-sessions)
                                   (apply append)
                                   delete-duplicates)
                   #:stateless? stateless?
                   #:stateless-machine-dir stateless-machine-dir) $
      (os:host-info $ #:host-name "frostfire"
                    #:timezone "America/Los_Angeles")
      (case filesystem
        ;; ((#:filesystem/ext4)
        ;;  (os:ext4 $ #:label root-label))
        ((#:filesystem/btrfs)
         (os:btrfs $ #:label root-label
                   #:subvols mountables
                   #:flags btrfs-mount-flags
                   #:options btrfs-mount-options)))
      (if disk-encryption?
          (os:disk-encryption $ #:device-uuid luks-uuid
                              #:mount-points (case filesystem
                                               ;; ((#:filesystem/ext4)
                                               ;;  ...)
                                               ((#:filesystem/btrfs)
                                                (map (match-lambda ((_ . mount-point) mount-point))
                                                     mountables))))
          $)
      (os:swap $ #:file-size swap-size
               #:file-no-cow? (equal? filesystem #:filesystem/btrfs)
               #:stateless? stateless?
               #:stateless-machine-dir stateless-machine-dir)
      (if stateless?
          (os:stateless $ #:storage-paths stateless-storage-paths
                        #:hes `((,primary-name . ,(primary-he))
                                (,aux-name . ,(aux-he))
                                (,guest-name . ,(guest-he)))
                        #:state-users (feature-users `((,primary-name . ,primary-he-stateless?)
                                                       (,aux-name . ,aux-he-stateless?)
                                                       (,guest-name . ,guest-he-stateless?)))
                        #:password-users (list primary-name
                                               aux-name)
                        #:root-size (let ((virtual-memory (+ physical-memory swap-size)))
                                      (/ virtual-memory 2)))
          $)
      (os:with-macbook-hardware $ #:boot-target boot-target
                                #:efi-label efi-label
                                #:virtualization-kvm-users (feature-users `((,primary-name . ,primary-he-virtualization?)
                                                                            (,aux-name . ,aux-he-virtualization?)
                                                                            (,guest-name . ,guest-he-virtualization?)))
                                ;; #:virtualization-binfmt-platforms '("aarch64")
                                #:bluetooth? bluetooth?
                                #:stateless? stateless?))))

(define physical-memory (* 16 GiB))
(define swap-size (* 32 GiB))

(define (feature-users flags)
  (->> flags
       (filter (match-lambda ((_ . enable?) enable?)))
       (map (match-lambda ((user . _) user)))))
#+end_src
***** OS
#+begin_src scheme
(define* (os-base #:key
                  users-info
                  kmonad?
                  kmonad-users
                  bluetooth?
                  bluetooth-users
                  auto-login?
                  auto-login-user
                  sessions
                  stateless?
                  stateless-machine-dir)
  (apply
   os:os-base
   os:blank-os
   ;; #:source? #t
   ;; #:source-path "/.persist/home/pharcosyle/work_for_now/phrenetic"
   #:users-info users-info
   #:kmonad? kmonad?
   #:kmonad-users kmonad-users
   #:bluetooth? bluetooth?
   #:bluetooth-users bluetooth-users
   #:auto-login? auto-login?
   #:auto-login-user auto-login-user
   #:sessions sessions
   #:stateless? stateless?
   #:stateless-machine-dir stateless-machine-dir
   (os+he-shared-opts)))
#+end_src
***** HEs
****** Primary
#+begin_src scheme
(define (primary-he)
  (he:create-he
   (apply
    he:he-base
    #:stateless? primary-he-stateless?
    #:email "pharcosyle@gmail.com"
    #:kmonad? primary-he-kmonad?
    #:sessions primary-he-sessions
    #:virtualization? primary-he-virtualization?
    #:projects `(("phrenetic" . ((#:doom? . ,doom?)))
                 ("Krush/hyperdrive" . ((#:stateless? . ,primary-he-stateless?)
                                        (#:doom? . ,doom?)
                                        (#:doom-org? . ,(assoc-ref doom-flags #:doom/org?))
                                        (#:doom-tree-sitter? . ,(assoc-ref doom-flags #:doom/tree-sitter?)))))
    (he-shared-opts))))

(define primary-he-stateless? stateless?)
(define primary-he-kmonad? #t)
(define primary-he-sessions '(#:session/sway))
(define primary-he-virtualization? #t)
#+end_src
****** Aux
#+begin_src scheme
(define (aux-he)
  (he:create-he
   (apply
    he:he-base
    #:stateless? aux-he-stateless?
    #:email "pharcosyle@gmail.com"
    #:kmonad? aux-he-kmonad?
    #:sessions aux-he-sessions
    #:virtualization? aux-he-virtualization?
    (he-shared-opts))))

(define aux-he-stateless? #f)
(define aux-he-kmonad? #f)
(define aux-he-sessions primary-he-sessions)
(define aux-he-virtualization? primary-he-virtualization?)
#+end_src
****** Guest
#+begin_src scheme
(define (guest-he)
  (he:create-he
   (apply
    he:he-base
    #:stateless? guest-he-stateless?
    #:kmonad? guest-he-kmonad?
    #:sessions guest-he-sessions
    #:virtualization? guest-he-virtualization?
    (he-shared-opts))))

(define guest-he-stateless? #f)
(define guest-he-kmonad? #f)
(define guest-he-sessions '(;; #:session/gnome
                            #:session/sway))
(define guest-he-virtualization? #f)
#+end_src
****** HE shared opts
#+begin_src scheme
(define doom? #t)
(define doom-flags '((#:doom/calendar? . #t)
                     (#:doom/org? . #t)
                     (#:doom/evil? . #t)
                     (#:doom/tree-sitter? . #t)))

(define (he-shared-opts)
  (append
   (os+he-shared-opts)
   `(#:stateless-storage-paths ,stateless-storage-paths
     #:doom? ,doom?
     #:doom-flags ,doom-flags)))
#+end_src
***** OS+HE shared opts
#+begin_src scheme
(define (os+he-shared-opts)
  '(#:guix? #t
    #:nix? #t
    #:console? #t
    #:desktop? #t
    #:pipewire? #t
    #:connection-manager #:cm/network-manager
    ;; #:login-manager #:lm/gdm
    ))
#+end_src
**** Installer
#+begin_src scheme
(define (installer)
  #f
  ;; (installer-package
  ;;  #:os-name "frostfire"
  ;;  #:boot-target boot-target
  ;;  #:efi-label efi-label
  ;;  #:root-label root-label
  ;;  #:disk-encryption? disk-encryption?
  ;;  #:luks-uuid luks-uuid
  ;;  #:filesystem filesystem
  ;;  #:mountables mountables
  ;;  #:btrfs-mount-flags btrfs-mount-flags
  ;;  #:btrfs-mount-options btrfs-mount-options)
  )
#+end_src
**** System+installer shared opts
#+begin_src scheme
(define boot-target os:%efi-boot-target)
(define efi-label os:%efi-label)
(define filesystem #:filesystem/btrfs)
(define root-label os:%root-label)
(define mountables (if stateless?
                       os:%stateless-mountables
                       ;; ...
                       ))
(define btrfs-mount-flags os:%btrfs-mount-flags)
(define btrfs-mount-options os:%btrfs-mount-options)
(define disk-encryption? #t)
(define luks-uuid os:%luks-uuid)
#+end_src
**** Module
***** Exports
#+begin_src scheme
(define system (system))
(define installer (installer))
(define primary-he (primary-he))
(define aux-he (aux-he))
(define guest-he (guest-he))
#+end_src
***** File-evaluates-to
#+begin_src scheme
system
#+end_src
*** Channels
#+begin_src scheme :tangle (meta-in-dir "frostfire-channels")
(cons* (channel
        (name 'rde)
        (url "https://git.sr.ht/~abcdw/rde")
        (introduction
         (make-channel-introduction
          "257cebd587b66e4d865b3537a9a88cccd7107c95"
          (openpgp-fingerprint
           "2841 9AC6 5038 7440 C7E9  2FFA 2208 D209 58C1 DEB0"))))
       (channel
        (name 'nonguix)
        (url "https://gitlab.com/nonguix/nonguix")
        (introduction
         (make-channel-introduction
          "897c1a470da759236cc11798f4e0a5f7d4d59fbc"
          (openpgp-fingerprint
           "2A39 3FFF 68F4 EF7A 3D29  12AF 6F51 20A0 22FB B2D5"))))
       (channel
        (name 'guix-chromium)
        (url "https://gitlab.com/mbakke/guix-chromium"))
       %default-channels)
#+end_src
**** COMMENT From project channel
#+begin_src scheme :tangle (meta-in-dir "frostfire-channels")
(cons* (channel
        (name 'phrenetic)
        (url "https://github.com/pharcosyle/phrenetic")
        (branch "tangled"))
       %default-channels)
#+end_src
**** COMMENT From project channel (local)
#+begin_src scheme :tangle (meta-in-dir "frostfire-channels")
(cons* (channel
        (name 'phrenetic)
        (url "file:///home/pharcosyle/work/phrenetic")
        (branch "tangled"))
       %default-channels)
#+end_src
*** Channels lock :version:
#+begin_src scheme :tangle (meta-in-dir "frostfire-channels-lock")
(list (channel
       (name 'guix)
       (url "https://git.savannah.gnu.org/git/guix.git")
       (branch "master")
       (commit
        "1ee2d117d8fa9e2e0d4ec46cc5555497bb5e6337")
       (introduction
        (make-channel-introduction
         "9edb3f66fd807b096b48283debdcddccfea34bad"
         (openpgp-fingerprint
          "BBB0 2DDF 2CEA F6A8 0D1D  E643 A2A0 6DF2 A33A 54FA"))))
      (channel
       (name 'rde)
       (url "https://git.sr.ht/~abcdw/rde")
       (branch "master")
       (commit
        "77bf57ba4f977af437fbaabff5e14bc09fb2eccd")
       (introduction
        (make-channel-introduction
         "257cebd587b66e4d865b3537a9a88cccd7107c95"
         (openpgp-fingerprint
          "2841 9AC6 5038 7440 C7E9  2FFA 2208 D209 58C1 DEB0"))))
      (channel
       (name 'nonguix)
       (url "https://gitlab.com/nonguix/nonguix")
       (branch "master")
       (commit
        "5a76529aff40107fbc03f293a0a332c839059815")
       (introduction
        (make-channel-introduction
         "897c1a470da759236cc11798f4e0a5f7d4d59fbc"
         (openpgp-fingerprint
          "2A39 3FFF 68F4 EF7A 3D29  12AF 6F51 20A0 22FB B2D5"))))
      (channel
       (name 'guix-chromium)
       (url "https://gitlab.com/mbakke/guix-chromium")
       (branch "master")
       (commit
        "3bc21255be98efb7a0e4b8de060c27bf60ae44f7")))
#+end_src
* Guix channel
#+begin_src scheme :tangle (meta-in-dir ".guix-channel")
(channel
 (version 0)
 (dependencies
  (channel
   (name rde)
   (url "https://git.sr.ht/~abcdw/rde")
   (introduction
    (make-channel-introduction
     "257cebd587b66e4d865b3537a9a88cccd7107c95"
     (openpgp-fingerprint
      "2841 9AC6 5038 7440 C7E9  2FFA 2208 D209 58C1 DEB0"))))
  (channel
   (name nonguix)
   (url "https://gitlab.com/nonguix/nonguix")
   (introduction
    (make-channel-introduction
     "897c1a470da759236cc11798f4e0a5f7d4d59fbc"
     (openpgp-fingerprint
      "2A39 3FFF 68F4 EF7A 3D29  12AF 6F51 20A0 22FB B2D5"))))
  (channel
   (name 'guix-chromium)
   (url "https://gitlab.com/mbakke/guix-chromium"))))
#+end_src
* Github
** Readme
#+begin_src org :tangle (meta-in-dir "README.org")
,* Phrenetic
A configuration framework and collection of useful packages/services for [[https://guix.gnu.org/][GNU Guix]].

It's decent.
,* [[file:phrenetic.org][Browse the full source]]
,* Usage
Install as a [[https://guix.gnu.org/manual/devel/en/guix.html#Channels][Guix channel]] with the following declaration:
,#+begin_src scheme
(channel
 (name 'phrenetic)
 (url "https://github.com/pharcosyle/phrenetic")
 (branch "tangled"))
,#+end_src
,* Noteworthy features
Some stuff I haven't seen elsewhere folks might be interested in:
- Stateless service :: Configure your Guix to run with an ephemeral, in-memory root directory. Kind of like [[https://grahamc.com/blog/erase-your-darlings][Erase your darlings: immutable infrastructure for mutable systems]] but using Guix/Btrfs instead of NixOS/ZFS.
- Doom package and module :: [[https://github.com/doomemacs/doomemacs][Doom Emacs]] packaged for Guix and with patches to better organize Emacs state, a service to set up symlinks, etc.
- Guix integration for [[https://github.com/radian-software/straight.el][Straight.el]] :: Your Straight or Doom-based Emacs configuration can use Guix Emacs packages under hood (but with the revisions you, or Doom, specify). Get the best of both worlds! Still WIP.
- Miscellaneous packages :: Guix packages for stuff not upstream yet: Datomic CLI tools, the AWS CLI v2, etc.
,* A word about literate programming
I use Emacs' =org-mode= to structure my code as a single file that I can export ("tangle") into numerous source files. This allows me to annotate and organize related code in potentially different languages with different output paths together in a way that easy for humans to read and reason about. This does necessitate maintaining a separate =tangled= branch (set as the Github default) so others can use it easily, though.
,* Contributing
Pull requests welcome! Targeting =master= is ideal but if you aren't familiar with literate programming / Emacs / =org=mode= then making your changes on the =tangled= branch is also fine (I'll reverse-tangle it for you).
,* Acknowledgements
This project incorporates code from Andrew Tropin's excellent [[https://github.com/abcdw/rde][RDE]], many thanks to him.
#+end_src
** License
:PROPERTIES:
:VISIBILITY: folded
:END:
#+begin_src fundamental :tangle (meta-in-dir "LICENSE")
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.
#+end_src
* Dev
** Git ignore
#+begin_src gitignore :tangle (meta-in-dir ".gitignore")
/*

!/meta.el

!/phrenetic/
/phrenetic/*
!/phrenetic/wallpapers/
/phrenetic/wallpapers/*
!phrenetic/wallpapers/alucard.png
#+end_src
