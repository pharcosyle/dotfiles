#+TITLE: Phrenetic
#+PROPERTY: header-args :mkdirp yes
#+PROPERTY: header-args:elisp :lexical t

* Meta
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "meta.el")
:END:
- REVIEW depending on how I do per-project literate config, I may want/need to pull out this code for use in other projects
  - ideally capture file-wide properties as well
    ~mkdirp~ and ~lexical~ at the time of this writing
  - a name for the project: "illiterate"
#+begin_src elisp
;;; -*- lexical-binding: t; -*-

(require 'dash)
;; FIXME
;; (require 'donnager-org)

(setq meta--base-dir ".")
#+end_src
** Path hierarchy
#+begin_src elisp
(defun meta-get-dir ()
  (concat meta--base-dir
          (when-let ((dirs (org-entry-get (point) "meta-dir" 'inherit)))
            (-> dirs (split-string " /") (string-join "/")))))

(defun meta-in-dir (sub-path)
  (concat (meta-get-dir) "/" sub-path))
#+end_src
** DB
#+begin_src elisp
(setq meta--table-refs
      '("db/schema-common"
        "db/systems-common"
        "db/feature-linux-nonfree"
        "db/feature-macbook"
        "db/systems-frostfire"
        "db/schema-whatever"
        "db/users-common"
        "db/users-system"
        "db/users-home"
        "db/palette"))

;; FIXME
;; (setq meta--database
;;       (db--load meta--table-refs))
#+end_src
** Dev
*** Git ignore
#+begin_src gitignore :tangle (meta-in-dir ".gitignore")
/meta.el
#+end_src
* Guix system/home
:PROPERTIES:
:meta-dir+: /ebullient
:END:
#+name: db/schema-common
| =:db/id=             | =:db/valueType=  | =:db/cardinality=    |
|----------------------+------------------+----------------------|
| :entity/channel-deps | :db.type/keyword | :db.cardinality/many |
| :system/features     | :db.type/keyword | :db.cardinality/many |
| :user/login-shell    | :db.type/keyword |                      |
| :user/sessions       | :db.type/keyword | :db.cardinality/many |

#+begin_src scheme :tangle (meta-in-dir "ebullient.scm")
(define-module (ebullient))

(define-public default-login-shell #:shell/bash)
#+end_src
** Common
*** Channels
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "ebullient/channels.scm")
:END:
#+begin_src scheme
(define-module (ebullient channels)
  #:use-module (guix channels)
  #:use-module ((srfi srfi-1) #:select (remove))
  #:use-module (mendicant utils)
  #:export (get-channels
            guix
            nonguix
            channel-map))

(define* (get-channels #:rest cs)
  (append
   cs
   (remove (lambda (c)
             (member (channel-name c)
                     (map channel-name cs)))
           %default-channels)))
#+end_src
**** Definitions
#+begin_src scheme
(define guix %default-guix-channel)

(define nonguix
  (channel
   (name 'nonguix)
   (url "https://gitlab.com/nonguix/nonguix")
   (introduction
    (make-channel-introduction
     "897c1a470da759236cc11798f4e0a5f7d4d59fbc"
     (openpgp-fingerprint
      "2A39 3FFF 68F4 EF7A 3D29  12AF 6F51 20A0 22FB B2D5")))))

(define channel-map
  (kvm #:channel/guix guix
       #:channel/nonguix nonguix))
#+end_src
** Installation WIP
*** Create bootable USB
Download (or create) a Guix installation ISO
- I'm using the [[https://github.com/SystemCrafters/guix-installer/releases/latest][System Crafters Guix Installer]] since it's kept up-to-date which should speed things up a bit.
- Run ~lsblk~ to find the usb device.
#+begin_src sh
iso_file=guix-system-install-1.3.0.x86_64-linux.iso
usb_device=/dev/sdc
dd if=$iso_file of=$usb_device status=progress bs=4M
sync
#+end_src
*** Install
Boot from the installation medium, select your language and country, and select "Install using the shell based process" when prompted.
**** Keyboard layout
This messed up the keyboard when I tried it on mac, not doing ~loadkeys~ at all was fine.
#+begin_src sh
# keysfile=mac-us
# loadkeys $keysfile
#+end_src
**** Networking
#+begin_src sh
# List network interfaces and find one to use.
ifconfig -a

# Is this necessary if the interface is already activated?
interface=usb0
ifconfig $interface up

dhclient -v $interface

# Test that networking is up and working.
ping -c 3 gnu.org
#+end_src
**** Partitioning
#+begin_src sh
# Check out the current block devices and partitions if you want.
lsblk

device=/dev/sda

# Make two partitions, partition types should be "EFI system partition" and "Linux x86-64 root (/)". For EFI I'm gonna do 1GB to be on the safe side, second should be remainder of free space.
cfdisk $device
parted $device set 1 esp on

efi_system_partition="$device"1
efi_label=genesis

mkfs.fat -F32 -n $efi_label $efi_system_partition

root_partition="$device"2
root_label=firmament
crypt_name=ciphered
crypt_mapping=/dev/mapper/$crypt_name

cryptsetup luksFormat $root_partition
cryptsetup open --type luks $root_partition $crypt_name

mkfs.btrfs -L $root_label $crypt_mapping
#+end_src
**** Set up subvolumes
#+begin_src sh
# I don't know if the type argument is necessary but that's how Andrew Tropin had it.
mount -t btrfs LABEL=$root_label /mnt

btrfs subvolume create /mnt/root
btrfs subvolume create /mnt/boot
btrfs subvolume create /mnt/guix-store
btrfs subvolume create /mnt/guix-var
btrfs subvolume create /mnt/log
btrfs subvolume create /mnt/home
btrfs subvolume create /mnt/persist
btrfs subvolume create /mnt/nix

# Take an empty readonly snapshot of the root subvolume (might be useful later for rolling back or comparison)
btrfs subvolume snapshot -r /mnt/root /mnt/root-blank

umount /mnt
#+end_src
**** Mount
NB: ~$crypt_mapping~ can/"should" be ~LABEL=$root_label~
#+begin_src sh
mount -o subvol=root,compress=zstd,autodefrag $crypt_mapping /mnt

mkdir /mnt/boot
mount -o subvol=boot,compress=zstd,autodefrag $crypt_mapping /mnt/boot
mkdir -p /mnt/gnu/store
mount -o subvol=guix-store,compress=zstd,autodefrag,noatime $crypt_mapping /mnt/gnu/store
mkdir -p /mnt/var/guix
mount -o subvol=guix-var,compress=zstd,autodefrag $crypt_mapping /mnt/var/guix
mkdir -p /mnt/var/log
mount -o subvol=log,compress=zstd,autodefrag $crypt_mapping /mnt/var/log
mkdir /mnt/home
mount -o subvol=home,compress=zstd,autodefrag $crypt_mapping /mnt/home
mkdir /mnt/.persist
mount -o subvol=persist,compress=zstd,autodefrag $crypt_mapping /mnt/.persist

mkdir -p /mnt/boot/efi
mount LABEL=$efi_label /mnt/boot/efi
#+end_src
**** Proceeding with installation
#+begin_src sh
herd start cow-store /mnt
#+end_src
**** System configuration
#+begin_src sh
# Grab my dotfiles, from github if I put them up at some point or maybe from a USB or another computer with `woof`, into the current directory (the one I'm already in, not `/mnt`).
# git clone https://github.com/pharcosyle/phrenetic
# guix environment --ad-hoc woof -- woof -U
# Important: `woof` didn't work for me over the local network, I had to have my other computer offer it over the public internet with localtunnel.

mkdir -p ~/.config/guix
cp ~/projects/phrenetic/exuberant/exuberant/he/solitude/solitude-channels-lock ~/.config/guix
guix pull
hash guix

# Find the LUKS UUID to update it in the system config. Make sure to update in the dotfiles upstream later.
cryptsetup luksUUID $root_partition

cd ~/projects/phrenetic
guix system --load-path=. init exuberant/exuberant/os/frostfire.scm /mnt
#+end_src
**** Post-installation
#+begin_src sh
# Reboot the system, take out the installation medium, and login as root when faced with a login prompt.

# Set the password for the root account.
passwd
# Set the password for my user.
my_user=pharcosyle
passwd $my_user

# Log out and log in to my user account.

# Grab my dotfiles again.

# Ensure my channels file is in `~/.config/guix` and update my channels.
guix pull

# Run a system reconfigure, home reconfigure, install manifests, and deploy `home-state.git`. Copy over all my old data.
#+end_src
** System
:PROPERTIES:
:meta-dir+: /ebullient/system
:END:
#+name: db/schema-whatever
| =:db/id=     | =:db/valueType=  |
|--------------+------------------|
| :user/admin? | :db.type/boolean |

*** Channels
#+begin_src scheme :tangle (meta-in-dir "channels.scm")
(define-module (ebullient system channels)
  #:use-module ((donnager client) #:prefix d:)
  #:use-module (ebullient channels)
  #:use-module (mendicant utils)
  #:export (get-system-channels
            system-channel-deps))

(define (get-system-channels cs)
  (apply get-channels cs))

(define (system-channel-deps system)
  (as-> system $
        (d:q $ '(#:system/features #:entity/channel-deps))
        (map (partial get system-channel-map) $)))

(define system-channel-map channel-map)
#+end_src
*** Components
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "components.scm")
:END:
#+begin_src scheme
(define-module (ebullient system components)
  #:use-module ((guix modules) #:select (source-module-closure))
  #:use-module (guix gexp)
  #:use-module ((guix store) #:select (%default-substitute-urls))
  #:use-module (gnu bootloader)
  #:use-module (gnu bootloader grub)
  ;; #:use-module ((gnu packages bash) #:select (bash))
  #:use-module ((gnu packages certs) #:select (nss-certs))
  #:use-module ((gnu packages fonts) #:select (font-terminus))
  #:use-module ((gnu packages gnupg) #:select (guile-gcrypt))
  #:use-module ((gnu packages linux) #:select (brightnessctl pipewire-0.3))
  ;; #:use-module ((gnu packages shells) #:select (zsh))
  #:use-module ((gnu packages wm) #:select (sway swaylock))
  #:use-module (gnu services)
  #:use-module (gnu services base)
  #:use-module (gnu services desktop)
  #:use-module (gnu services nix)
  #:use-module (gnu services sound)
  #:use-module (gnu services xorg)
  #:use-module (gnu system)
  #:use-module (gnu system accounts)
  #:use-module (gnu system file-systems)
  #:use-module (gnu system keyboard)
  #:use-module (gnu system mapped-devices)
  #:use-module ((nongnu packages linux) #:select (linux linux-firmware broadcom-sta broadcom-bt-firmware))
  #:use-module ((nongnu system linux-initrd) #:select (microcode-initrd))
  #:use-module ((ice-9 match) #:select (match-lambda))
  #:use-module ((ice-9 rdelim) #:select (read-string))
  #:use-module ((srfi srfi-1) #:select (any remove iota))
  #:use-module (ebullient)
  #:use-module (mendicant utils)
  #:export (barebones-os
            host-info
            grub-efi
            base-services
            nss
            linux-nonfree
            disk-encryption
            stateless
            btrfs
            users
            nonguix-substitutes
            nix
            console-keyboard-layouts
            hidpi-console-font
            desktop-services
            gdm
            gnome-desktop
            wm
            sway-wm
            macbook-wireless
            macbook-kbl))
#+end_src
#+begin_src scheme
(define-syntax-rule (system-comp os field ...)
  (operating-system
    (inherit os)
    field ...))

(define-syntax define-system-comp
  (lambda (x)
    (syntax-case x ()
      ((_ (name arg ...) field ...)
       (with-syntax ((os (datum->syntax x 'os)))
         #'(define* (name os arg ...)
             (system-comp os field ...)))))))
#+end_src
**** Barebones OS
#+begin_src scheme
(define barebones-os
  (operating-system
    (host-name #f)
    (timezone #f)
    (bootloader #f)
    (services '())
    (file-systems %base-file-systems)))
#+end_src
**** Host info
#+begin_src scheme
(define-system-comp (host-info #:key host-name timezone locale)
  (host-name host-name)
  (timezone timezone)
  (locale locale))
#+end_src
**** Boot
***** Grub
...
***** Grub EFI
#+begin_src scheme
(define-system-comp (grub-efi #:key label target)
  (bootloader (bootloader-configuration
               (bootloader grub-efi-bootloader)
               (targets (list target))
               (timeout 1)))
  (file-systems
   (cons* (file-system
            (device (file-system-label label))
            (mount-point target)
            (type "vfat"))
          (operating-system-file-systems os))))
#+end_src
**** Base services
#+begin_src scheme
(define-system-comp (base-services)
  (services
   (append %base-services
           (operating-system-user-services os))))
#+end_src
**** NSS
#+begin_src scheme
(define-system-comp (nss)
  (packages
   (cons* nss-certs
          (operating-system-packages os))))
#+end_src
**** Linux nonfree
#+name: db/feature-linux-nonfree
| =:db/id=               | =:entity/channel-deps= |
|------------------------+------------------------|
| :feature/linux-nonfree | :channel/nonguix       |

#+begin_src scheme
(define-system-comp (linux-nonfree)
  (kernel linux)
  (initrd microcode-initrd)
  (firmware (cons* linux-firmware
                   (operating-system-firmware os))))
#+end_src
**** Disk encryption
#+begin_src scheme
(define* (disk-encryption os #:key source-uuid target encrypted-mount-points)
  (let ((encrypted-device (mapped-device
                           (source (uuid source-uuid))
                           (targets (list target))
                           (type luks-device-mapping))))
    (system-comp
     os
     (mapped-devices
      (cons* encrypted-device
             (operating-system-mapped-devices os)))
     (file-systems
      (map (lambda (fs)
             (if (member (file-system-mount-point fs) encrypted-mount-points)
                 (file-system
                   (inherit fs)
                   (dependencies (cons* encrypted-device
                                        (file-system-dependencies fs))))
                 fs))
           (operating-system-file-systems os))))))
#+end_src
**** Stateless
The stateless service should come after base/desktop services (potentially others as well) so its state gets installed before theirs during activation. To this end the ~stateless-service-type~ is appended, not prepended, to operating system services. It also modifies file systems so users of this component should include it at the end of their component chain.
#+begin_src scheme
(define-system-comp (stateless #:key persist-dir bluetooth?)
  (initrd (lambda (file-systems . rest)
            (apply (operating-system-initrd os) file-systems
                   #:volatile-root? #t
                   rest)))
  (file-systems
   (map (lambda (fs)
          (if (member (file-system-mount-point fs)
                      `("/var/guix"
                        "/var/log"
                        ,persist-dir))
              (file-system
                (inherit fs)
                (needed-for-boot? #t))
              fs))
        (operating-system-file-systems os)))
  (services
   (append
    (operating-system-user-services os)
    (list
     (service stateless-service-type
              `(#:persist-dir ,persist-dir
                #:paths ,(append
                          '("/etc/machine-id"
                            "/var/lib/random-seed"
                            "/etc/NetworkManager/system-connections"
                            "/var/lib/NetworkManager/secret_key"
                            "/etc/guix/signing-key.pub"
                            "/etc/guix/signing-key.sec")
                          (if bluetooth?
                              (list "/var/lib/bluetooth") '()))))))))
#+end_src
***** Service
#+begin_src scheme
(define save-or-restore-users+groups
  #~(lambda (persist-dir save-or-restore)
      (for-each (lambda (path)
                  (let ((files (list path (string-append persist-dir path))))
                    (apply copy-file (case save-or-restore
                                       ((#:restore) (reverse files))
                                       ((#:save) files)))))
                '("/etc/group"
                  "/etc/passwd"
                  "/etc/shadow"))))

(define (populate-gexp config)
  (with-extensions (list guile-gcrypt)
    (with-imported-modules (source-module-closure
                            '((gnu build install)))
      #~(begin
          (use-modules ((gnu build install) #:select (populate-root-file-system)))

          (define* (populate #:key persist-dir #:allow-other-keys)
            (let* ((system-path "/var/guix/profiles/system")
                   (system-1-path "/var/guix/profiles/system-1-link")
                   (system-1-exists? (file-exists? system-1-path))
                   (system-link (readlink system-path))
                   (system-1-link (if system-1-exists?
                                      (readlink system-1-path)
                                      system-link)))
              (populate-root-file-system system-1-link ""
                                         #:extras `((,system-path -> ,system-link)))
              (unless system-1-exists?
                (delete-file system-1-path)))
            (#$save-or-restore-users+groups persist-dir #:restore))

          (apply populate '#$config)))))

(define (activate-state-gexp config)
  #~(begin
      (use-modules ((ice-9 match) #:select (match)))

      (define* (activate-state #:key persist-dir paths)

        (define (install path)
          (let loop ((components (string-tokenize path (char-set-complement (char-set #\/))))
                     (base persist-dir)
                     (target-base ""))
            (match components
              ((head tail ...)
               (let* ((path (string-append base "/" head))
                      (target-path (string-append target-base "/" head)))
                 (if (null? tail)
                     ;; The Guix code makes a point of doing stuff like this atomically. I don't really know why but I will too.
                     (let ((pivot (string-append target-path ".new")))
                       (symlink path pivot)
                       (rename-file pivot target-path))
                     (begin
                       (catch 'system-error
                         (lambda ()
                           (mkdir target-path))
                         (lambda args
                           (unless (= EEXIST (system-error-errno args))
                             (apply throw args))))
                       (let ((st (lstat path)))
                         (chown target-path (stat:uid st) (stat:gid st))
                         (chmod target-path (stat:perms st)))
                       (loop tail path target-path))))))))

        (for-each install paths)
        (#$save-or-restore-users+groups persist-dir #:save))

      (apply activate-state '#$config)))

(define stateless-service-type
  (service-type
   (name 'stateless)
   (extensions
    (list (service-extension boot-service-type
                             populate-gexp)
          (service-extension activation-service-type
                             activate-state-gexp)))))
#+end_src
**** File systems
***** Ext4
...
***** Btrfs
#+begin_src scheme
(define-system-comp (btrfs #:key label subvols)
  (file-systems
   (append
    (map (match-lambda
           ((subvol mount-point)
            (file-system
              (device (file-system-label label))
              (mount-point mount-point)
              (type "btrfs")
              (options (string-append "subvol=" subvol ",compress=zstd,autodefrag")))))
         subvols)
    (operating-system-file-systems os))))
#+end_src
**** Users
#+begin_src scheme
(define* (account #:key name comment shell admin? password salt bluetooth?)
  (user-account
   (name name)
   (comment (or comment ""))
   (group "users")
   (supplementary-groups (append '("netdev" "audio" "video")
                                 (if admin? '("wheel") '())
                                 (if bluetooth? '("lp") '())))
   (shell (if (eq? shell default-login-shell)
              (default-shell)
              ;; (case shell
              ;;   ((#:shell/bash) (file-append bash "/bin/bash"))
              ;;   ((#:shell/zsh) (file-append zsh "/bin/zsh")))
              ))
   (password (if password
                 (crypt password salt)
                 #f))))

(define-system-comp (users #:key who bluetooth?)
  (users
   (append (map (lambda (user)
                  (apply account (-> user
                                     (massoc user #:bluetooth? bluetooth?)
                                     keyvals)))
                who)
           (operating-system-users os))))
#+end_src
**** Nonguix substitutes
- TODO probably use the new [[https://github.com/guix-mirror/guix/commit/fcad6226486b52e5d45531f60811d35eac34fa67][guix-extension]] (not important, just for cleanliness)
#+begin_src scheme
(define-system-comp (nonguix-substitutes)
  (services
   (update-services
    (operating-system-user-services os)
    guix-service-type
    (lambda (config)
      (guix-configuration
       (inherit config)
       (substitute-urls
        (append (guix-configuration-substitute-urls config)
                (list "https://substitutes.nonguix.org")))
       (authorized-keys
        (append (guix-configuration-authorized-keys config)
                (list (local-file "substitutes.nonguix.org.pub")))))))))
#+end_src
***** Signing key
#+begin_src scheme :tangle (meta-in-dir "substitutes.nonguix.org.pub")
(public-key
 (ecc
  (curve Ed25519)
  (q #C1FD53E5D4CE971933EC50C9F307AE2171A2D3B52C804642A7A35F84F3A4EA98#)))
#+end_src
**** Nix
#+begin_src scheme
(define-system-comp (nix)
  (services
   (cons* (service nix-service-type)
          (operating-system-user-services os))))
#+end_src
**** Console
***** Console keyboard layouts
#+begin_src scheme
(define-system-comp (console-keyboard-layouts #:key keyboard-layout)
  (keyboard-layout keyboard-layout)
  (bootloader (bootloader-configuration
               (inherit (operating-system-bootloader os))
               (keyboard-layout keyboard-layout))))
#+end_src
***** HiDPI console font
#+begin_src scheme
(define-system-comp (hidpi-console-font)
  (services
   (update-services
    (operating-system-user-services os)
    console-font-service-type
    (lambda (config)
      (map (lambda (tty-and-font)
             (cons (car tty-and-font)
                   (file-append font-terminus "/share/consolefonts/ter-132n")))
           config)))))
#+end_src
**** Desktop
***** Desktop services
#+begin_src scheme
(define-system-comp (desktop-services #:key pipewire? bluetooth?)
  (services
   (as-> (operating-system-user-services os) $
     (append selective-desktop-services $)
     (if pipewire?
         (with-pipewire $) $)
     ;; (if bluetooth?
     ;;     (cons* (bluetooth-service #:auto-enable? #t) $))
     )))
#+end_src
****** Pipewire
#+begin_src scheme
(define (with-pipewire services)
  (as-> services $
    (remove-services $ (list pulseaudio-service-type
                             alsa-service-type))
    (cons* (udev-rules-service 'pipewire-add-udev-rules
                               pipewire-0.3)
           $)))
#+end_src
****** \
#+begin_src scheme
(define (remove-services services kinds)
  (remove (lambda (s)
            (member (service-kind s) kinds))
          services))

(define selective-desktop-services
  (remove-services %desktop-services
                   (append (map service-kind %base-services)
                           (list gdm-service-type
                                 screen-locker-service-type))))
#+end_src
***** Display managers
****** GDM
#+begin_src scheme
(define-system-comp (gdm #:key wayland? auto-login)
  (services
   (cons* (service gdm-service-type
                   (gdm-configuration
                    (auto-login? (if auto-login #t #f))
                    (default-user auto-login)
                    (wayland? wayland?)))
          (operating-system-user-services os))))
#+end_src
***** Desktop environments
****** Gnome
#+begin_src scheme
(define-system-comp (gnome-desktop)
  (services
   (cons* (service gnome-desktop-service-type)
          (operating-system-user-services os))))
#+end_src
***** Window managers
#+begin_src scheme
(define-system-comp (wm #:key package services)
  (packages
   (cons* package
          (operating-system-packages os)))
  (services
   (append services
           (operating-system-user-services os))))
#+end_src
****** Sway
#+begin_src scheme
(define* (sway-wm os #:key laptop?)
  (wm os
      #:package sway
      #:services (cons* swaylock-service
                        (if laptop?
                            (list brightnessctl-udev-rules) '()))))
#+end_src
***** Screen lockers
****** Swaylock
#+begin_src scheme
(define swaylock-service
  (screen-locker-service swaylock))
#+end_src
***** Backlight
****** Brightnessctl
#+begin_src scheme
(define brightnessctl-udev-rules
  (udev-rules-service 'brightnessctl-add-udev-rules brightnessctl))
#+end_src
**** Macbook
***** Wireless
I'm not sure if this requires the nonfree linux kernel and/or if the blacklist refers to kernel modules not present in linux-libre.

#+name: db/feature-macbook
| =:db/id=         | =:entity/channel-deps= |
|------------------+------------------------|
| :feature/macbook | :channel/nonguix       |

#+begin_src scheme
(define-system-comp (macbook-wireless #:key bluetooth?)
  (kernel-arguments (with-blacklist (operating-system-user-kernel-arguments os)
                                    "b43,b43legacy,ssb,bcm43xx,brcm80211,brcmfmac,brcmsmac,bcma"))
  (kernel-loadable-modules (cons* broadcom-sta
                                  (operating-system-kernel-loadable-modules os)))
  (firmware (append
             (if bluetooth? (list broadcom-bt-firmware) '())
             (operating-system-firmware os))))

(define (with-blacklist kernel-args new)

  (define blacklist-param "modprobe.blacklist")
  (define (blacklist? ka)
    (string-prefix? blacklist-param ka))

  (if (any blacklist? kernel-args)
      (update-list kernel-args blacklist? (lambda (blacklist)
                                            (string-append blacklist "," new)))
      (cons* (string-append blacklist-param "=" new) kernel-args)))
#+end_src
***** Keyboard layout
#+begin_src scheme
(define macbook-kbl
  (keyboard-layout "us" #:model "macbook78"))
#+end_src
*** Base OS
#+begin_src scheme :tangle (meta-in-dir "base-os.scm")
(define-module (ebullient system base-os)
  #:use-module ((donnager client) #:prefix d:)
  #:use-module (ebullient system components)
  #:use-module (ebullient)
  #:use-module (mendicant utils)
  #:export (base-os))

(define* (base-os #:key
                  system
                  host-name
                  timezone
                  (locale "en_US.utf8")
                  accounts
                  luks-uuid
                  auto-login-account
                  kbl
                  console?
                  laptop?
                  bluetooth?)
  (let* ((feature?
          (let ((features (get (d:pull '(#:system/features) system) #:system/features)))
            (lambda (feat)
              (member feat features))))
         (linux-nonfree? (feature? #:feature/linux-nonfree))
         (disk-encryption? (feature? #:feature/disk-encryption))
         (stateless? (feature? #:feature/stateless))
         (nix? (feature? #:feature/nix))
         (desktop? (feature? #:feature/desktop))
         (laptop? (and desktop? laptop?))
         (macbook? (and laptop? (feature? #:feature/macbook)))
         (pipewire? (and desktop? (feature? #:feature/pipewire)))
         (bluetooth? (and desktop? bluetooth?))
         (kbl (or kbl
                  (if macbook?
                      macbook-kbl #f)))
         (auto-login (if disk-encryption?
                         (get (d:pull '(#:user/username) auto-login-account) #:user/username) #f))
         (who
          (->> accounts
               (apply d:pull-many '(*))
               (map (lambda (user)
                      (merge
                       (kvm #:name (get user #:user/username)
                            #:comment (get user #:user/full-name)
                            #:shell (let ((shell (get user #:user/login-shell)))
                                      (if (equal? shell #:shell/default)
                                          default-login-shell shell))
                            #:admin? (get user #:user/admin?))
                       (let ((admin? (get user #:user/admin?))
                             (password (get user #:user/password)))
                         (if (and password (not admin?))
                             (kvm #:password password
                                  #:salt "toosimple")
                             (kvm))))))))
         (nonguix-substitutes?
          (let ((channel-deps (append
                               (d:q $ '(#:system/features #:entity/channel-deps) system)
                               (d:q-many $ '(#:entity/channel-deps) accounts))))
            (member #:channel/nonguix channel-deps)))
         (session?
          (let ((sessions
                 (->> accounts
                      (map (rpartial get #:user/sessions) (d:pull-many '(#:user/sessions)))
                      (apply append))))
            (lambda (s)
              (member s sessions))))
         gnome? (session? #:session/gnome)
         sway? (session? #:session/sway))
    (-> barebones-os
        (host-info #:host-name host-name
                   #:timezone timezone
                   #:locale locale)
        (grub-efi #:label "genesis"
                  #:target "/boot/efi")
        base-services
        nss
        (users #:who who
               #:bluetooth? bluetooth?)
        (as-> $
          (if nonguix-substitutes?
              (nonguix-substitutes $) $)
          (if linux-nonfree?
              (linux-nonfree $) $)
          (if nix?
              (nix $) $)
          (if console?
              (-> $
                  (console-keyboard-layouts #:keyboard-layout kbl)
                  hidpi-console-font)
              $)
          (if desktop?
              (-> $
                  (desktop-services #:pipewire? pipewire?
                                    #:bluetooth? bluetooth?)
                  (gdm #:wayland? #t
                       #:auto-login auto-login)
                  (as-> $
                    (if gnome?
                        (gnome-desktop $) $)
                    (if sway?
                        (sway-wm $ #:laptop? laptop?) $)))
              $)
          (if macbook?
              (macbook-wireless $ #:bluetooth? bluetooth?) $)
          (let* ((persist-dir "/.persist")
                 (subvols
                  (append
                   `(("root-blank" "/")
                     ("boot" "/boot")
                     ("guix-store" "/gnu/store")
                     ("guix-var" "/var/guix")
                     ("log" "/var/log")
                     ("home" "/home")
                     ("persist" ,persist-dir))
                   (if nix? '(("nix" "/nix")) '()))))
            (-> $
                (btrfs #:label "firmament"
                       #:subvols subvols)
                (as-> $
                  (if disk-encryption?
                      (disk-encryption $ #:source-uuid luks-uuid
                                       #:target "ciphered"
                                       #:encrypted-mount-points (map cadr subvols))
                      $))
                (as-> $
                  (if stateless?
                      (stateless #:persist-dir persist-dir
                                 #:bluetooth? bluetooth?)
                      $))))))))
#+end_src
*** \
- TODO expression shouldn't reference "exhuberant"
#+begin_src sh :var os_name="" os_dir=(meta-get-dir)
sudo guix time-machine \
	--channels="$os_dir"/$os_name-channels-lock \
	-- \
	system \
	--load-path=. \
	--expression="(@ (exuberant os $os_name) os)" \
	reconfigure
#+end_src
** Home
:PROPERTIES:
:meta-dir+: /ebullient/home
:END:
#+name: guix-extra-profiles-path
#+begin_src sh
~/.guix-extra-profiles
#+end_src
*** Channels
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "channels.scm")
:END:
#+begin_src scheme
(define-module (ebullient home channels)
  #:use-module (guix channels)
  #:use-module ((donnager client) #:prefix d:)
  #:use-module (ebullient channels)
  #:use-module (mendicant utils)
  #:export (get-home-channels
            user-channel-deps
            rde
            flat)
  #:re-export (guix
               nonguix))

(define (get-home-channels cs)
  (apply get-channels (if (member rde cs)
                          cs (cons rde cs))))

(define (user-channel-deps user)
  (as-> user $
        (get (d:pull '(#:entity/channel-deps) $) #:entity/channel-deps)
        (map (partial get home-channel-map) $)))
#+end_src
**** Definitions
#+begin_src scheme
(define rde
  (channel
   (name 'rde)
   (url "https://git.sr.ht/~abcdw/rde")
   (introduction
    (make-channel-introduction
     "257cebd587b66e4d865b3537a9a88cccd7107c95"
     (openpgp-fingerprint
      "2841 9AC6 5038 7440 C7E9  2FFA 2208 D209 58C1 DEB0")))))

(define flat
  (channel
   (name 'flat)
   (url "https://github.com/flatwhatson/guix-channel.git")
   (introduction
    (make-channel-introduction
     "33f86a4b48205c0dc19d7c036c85393f0766f806"
     (openpgp-fingerprint
      "736A C00E 1254 378B A982  7AF6 9DBE 8265 81B6 4490")))))
#+end_src
**** \
#+begin_src scheme
(define home-channel-map
  (merge channel-map
         (kvm #:channel/rde rde
              #:channel/flat flat)))
#+end_src
*** Components
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "components.scm")
:END:
#+begin_src scheme
(define-module (ebullient home components)
  #:use-module (guix gexp)
  #:use-module (gnu home services)
  #:use-module (gnu home services mcron)
  #:use-module (gnu home services shells)
  #:use-module (gnu home services shepherd)
  #:use-module (gnu home services xdg)
  #:use-module (gnu home-services ssh)
  #:use-module (gnu home-services version-control)
  ;; #:use-module ((gnu packages bash) #:select (bash))
  #:use-module ((gnu packages emacs) #:select (emacs))
  #:use-module ((gnu packages fonts) #:select (font-fira-code))
  #:use-module ((gnu packages freedesktop) #:select (udiskie xdg-desktop-portal xdg-desktop-portal-wlr))
  #:use-module ((gnu packages gnome) #:select (network-manager-applet))
  #:use-module ((gnu packages linux) #:select (pipewire-0.3 wireplumber))
  #:use-module ((gnu packages package-management) #:select (flatpak))
  #:use-module ((gnu packages shells) #:select (zsh))
  #:use-module ((gnu packages shellutils) #:select (direnv))
  #:use-module ((gnu packages xdisorg) #:select (gammastep))
  #:use-module (gnu services)
  #:use-module (gnu services shepherd)
  #:use-module ((srfi srfi-1) #:select (append-map))
  #:use-module ((ebullient home doom-emacs) #:select (doom-emacs))
  #:use-module (mendicant utils)
  #:export (he-shells
            he-extra-profiles
            he-nix
            he-emacs
            he-doom
            he-direnv
            he-pipewire
            he-flatpak
            he-sway
            gammastep-service-type
            network-manager-service-type
            udiskie-service-type))
#+end_src
**** Shells
#+begin_src scheme
(define* (he-shells svcs #:key login-shell interactive-shell)
  (append
   (cons*
    (service (login-shell-service-type login-shell))
    (filter
     service?
     (let ((setup-shell? (lambda (shell)
                           (memq shell (list login-shell interactive shell)))))
       (list
        (when (setup-shell? #:shell/bash)
          (service home-bash-service-type
                   ;; (home-bash-configuration
                   ;;  (bash-profile
                   ;;   (list (local-file "bashrc"))))
                   ))
        (when (setup-shell? #:shell/zsh)
          (service home-zsh-service-type
                   (home-zsh-configuration
                    (zshrc
                     (list (local-file "zshrc"))))))
        (when-not (eq login-shell interactive-shell)
          (simple-service
           'set-shell
           home-environment-variables-service-type
           `(("SHELL" . ,(case interactive-shell
                           ;; ((#:shell/bash) (file-append bash "/bin/bash"))
                           ((#:shell/zsh) (file-append zsh "/bin/zsh")))))))))))
   svcs))
#+end_src
***** Login shell service
#+begin_src scheme
(define (he-login-shell-service-type shell)
  (service-type
   (name 'he-login-shell)
   (extensions
    (service-extension
     (case shell
       ((#:shell/bash) home-bash-service-type)
       ;; ((#:shell/zsh) home-zsh-service-type)
       )
     identity))
   (compose identity)
   (extend
    (lambda (initial extensions)
      (let* ((config (cons* initial extensions))
             (field (lambda (k)
                      (append-map (rpartial k) config))))
        (case shell
          ((#:shell/bash)
           (home-bash-extension
            (environment-variables (field #:environment-variables))
            (bash-profile (field #:profile))))
          ;; ((#:shell/zsh)
          ;;  (home-zsh-extension
          ;;   (environment-variables (field #:environment-variables))
          ;;   (zprofile (field #:profile))))
          ))))
   (default-value (kvm))))
#+end_src
***** Bash
****** Bashrc
...
***** Zsh
****** Zshrc
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "zshrc")
:END:
******* Andrew Tropin's zshrc
- TODO trying out Andrew Tropin's zsh configuration verbatim for now
#+begin_src sh
# Prevent freezing output on ^s, needed for various isearches
hash stty 2> /dev/null && stty -ixon

# Completions and other stuff
autoload -U compinit
compinit -d ${XDG_CACHE_HOME:-$HOME/.cache}/.zcompdump

# Enable bash completion, requires to source them from somewhere
# autoload -U bashcompinit && bashcompinit

zstyle ':completion:*' menu select
zstyle ':completion:*' insert-tab false

# Automatically update cache of binaries avaliable in $PATH
zstyle ':completion:*' rehash true # Can have a performance penalty

# Approximate completion
# zstyle ':completion:::::' completer _complete _approximate
# zstyle ':completion:*:approximate:*' max-errors 2

# Fuzzy completion
# https://superuser.com/questions/415650/does-a-fuzzy-matching-mode-exist-for-the-zsh-shell
zstyle ':completion:*' matcher-list '' \
  'm:{a-z\-}={A-Z\_}' \
  'r:[^[:alpha:]]||[[:alpha:]]=** r:|=* m:{a-z\-}={A-Z\_}' \
  'r:|?=** m:{a-z\-}={A-Z\_}'

# Make kill completion smart
zstyle ':completion:*:*:*:*:processes' command "ps -u $USER -o pid,user,args -w -w"

# Colored completion for files and dirs according to LS_COLORS

hash dircolors 2> /dev/null && eval $(dircolors --sh) && \
zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}

# Prompt theme setup
clear_fn() {
#  zle reset-prompt
  zle kill-buffer
}

prompt_rde_precmd() {
  # Prevent killing prompt on ^C
  trap 'clear_fn' SIGINT
}

prompt_rde_setup() {
  if [[ $UID -eq 0 ]]; then
    user_part='%F{red}>%f'
  else
    user_part='%F{green}>%f'
  fi
  if [ -n "$GUIX_ENVIRONMENT" ]; then
    genv_part='%F{blue}>%f'
  fi
  # exit_code_part='%(?..[%?])'

  PS1="$user_part$genv_part "
  # RPS1="$exit_code_part"

  # Fish-like C-c behavior
  # add-zsh-hook precmd prompt_rde_precmd
}

# Load promptinit and set rde theme
autoload -Uz promptinit && promptinit
prompt_themes+=( rde )
prompt rde

setopt printexitvalue # Instead of using RPS1 for status code

echo -en "\033[6 q" # Make a cursor to be a vertical bar

# Remove slashes and dashes from wordchars to make M-b, M-f work
# correctly
WORDCHARS=""

# Configure history
# HISTSIZE=5000
# SAVEHIST=$HISTSIZE
HISTFILE=${XDG_CACHE_HOME:-$HOME/.cache}/.zhistory

#setopt incappendhistory # Save history to shared file, but not read
setopt sharehistory     # Share history across shell sessions
setopt histignorespace  # Ignore commands that start with space

# Configuring help (M-h to call it on current command/function)
autoload -Uz run-help
(( ${+aliases[run-help]} )) && unalias run-help
autoload -Uz run-help-git

# Delete, home, end buttons
bindkey  "^[[3~"  delete-char
bindkey  "^[[H"   beginning-of-line
bindkey  "^[[F"   end-of-line

# Launch $VISUAL or $EDITOR, for emacsclient if there is no server
# avaliable $ALTERNATE_EDITOR will be used.
autoload -z edit-command-line
zle -N edit-command-line
bindkey "^X^E" edit-command-line

alias help=run-help
alias try='guix shell man-db coreutils'
alias ls='ls -p --color=auto'
alias ll='ls -l'
alias grep='grep --color=auto'
#+end_src
******* History
#+begin_src sh
HISTSIZE=1000000
SAVEHIST=$HISTSIZE
#+end_src
**** Extra profiles
***** login shell profile wip
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "profile")
:END:
****** Use Guix extra profiles
#+begin_src sh :noweb yes
gepp="<<guix-extra-profiles-path>>"
GUIX_EXTRA_PROFILES="${gepp/#\~/$HOME}"

for i in $GUIX_EXTRA_PROFILES/*; do
  profile=$i/$(basename "$i")
  if [ -f "$profile"/etc/profile ]; then
    GUIX_PROFILE="$profile"
    . "$GUIX_PROFILE"/etc/profile
  fi

  # Emulate guix-home setup-environment file (and thus `/etc/profile` as well). Regarding MANPATH and INFOPATH in particular, see https://guix.gnu.org/en/cookbook/en/guix-cookbook.html#Required-packages
  case $XDG_DATA_DIRS in
    ,*"$profile"/share*) ;;
    ,*) export XDG_DATA_DIRS="$profile"/share:$XDG_DATA_DIRS ;;
  esac
  case $MANPATH in
    ,*"$profile"/share/man*) ;;
    ,*) export MANPATH="$profile"/share/man:$MANPATH
  esac
  case $INFOPATH in
    ,*"$profile"/share/info*) ;;
    ,*) export INFOPATH="$profile"/share/info:$INFOPATH ;;
  esac
  case $XDG_CONFIG_DIRS in
    ,*"$profile"/etc/xdg*) ;;
    ,*) export XDG_CONFIG_DIRS="$profile"/etc/xdg:$XDG_CONFIG_DIRS ;;
  esac
  case $XCURSOR_PATH in
    ,*"$profile"/share/icons*) ;;
    ,*) export XCURSOR_PATH="$profile"/share/icons:$XCURSOR_PATH ;;
  esac

  unset profile
done
#+end_src
**** Nix
#+begin_src scheme
(define (he-nix svcs)
  (cons*
   (service
    (service-type
     (name 'he-nix)
     (extensions
      (list
       (service-extension
        home-files-service-type
        (const
         `((".nix-channels"
            ,(local-file "nix-channels")))))
       (service-extension
        home-xdg-configuration-files-service-type
        (const
         `(("nixpkgs/config.nix"
            ,(local-file "nixpkgs-config.nix")))))))
     (default-value #f)))
   svcs))
#+end_src
***** Load Nix environment
#+begin_src sh
if [ -f /run/current-system/profile/etc/profile.d/nix.sh ]; then
  . /run/current-system/profile/etc/profile.d/nix.sh
fi
#+end_src
***** Nix channels
#+begin_src conf :tangle (meta-in-dir "nix-channels")
https://nixos.org/channels/nixpkgs-unstable nixpkgs
#+end_src
***** Nixpkgs config
#+begin_src nix :tangle (meta-in-dir "nixpkgs-config.nix")
{ allowUnfree = true; }
#+end_src
***** Nix WIP
Commands and stuff (like manifests install and upgrade and guix channel pull) plus a packages "manifest"
****** Update channels
#+begin_src sh :results output silent :async
nix-channel --update
#+end_src
****** "Manifest"
- TODO might want to / see if I can make this a simple bulleted list I pass with :var to source block(s)
#+name: nix-packages
#+begin_src org
google-chrome zoom-us
#+end_src
****** Install packages
#+begin_src sh :results output silent :async :noweb yes
nix-env --install <<nix-packages>>
#+end_src
****** Upgrade packages
#+begin_src sh :results output silent :async
nix-env --upgrade
#+end_src
**** Emacs
#+begin_src scheme
(define* (he-emacs svcs #:key zsh-vterm? config)
  (cons*
   (service (he-emacs-service-type zsh-vterm? config))
   svcs))

(define (he-emacs-service-type zsh-vterm? config)
  (service-type
   (name 'he-emacs)
   (extensions
    (filter
     service-extension?
     (list
      (service-extension
       home-profile-service-type
       (lambda (config)
         (list (get config #:emacs))))
      (service-extension
       he-login-shell-service-type
       (lambda (config)
         (kvm #:environment-variables
              `(("VISUAL" . ,(file-append (get config #:emacs) "/bin/emacsclient"))
                ("EDITOR" . "$VISUAL")))))
      (when zsh-vterm?
        (service-extension
         home-zsh-service-type
         (const (home-zsh-extension
                 (zshrc
                  (local-file "zsh-vterm")))))))))
   (default-value
     (or config
         (kvm #:emacs emacs)))))
#+end_src
***** Configure zsh for vterm
#+begin_src sh :tangle (meta-in-dir "zsh-vterm")
vterm_printf(){
    if [ -n "$TMUX" ] && ([ "${TERM%%-*}" = "tmux" ] || [ "${TERM%%-*}" = "screen" ] ); then
        # Tell tmux to pass the escape sequences through
        printf "\ePtmux;\e\e]%s\007\e\\" "$1"
    elif [ "${TERM%%-*}" = "screen" ]; then
        # GNU screen (screen, screen-256color, screen-256color-bce)
        printf "\eP\e]%s\007\e\\" "$1"
    elif ([ "${TERM%%-*}" = "eterm" ] || [ "${TERM%%-*}" = "dumb" ]); then
        # Do nothing for Emacs' term and ansi-term, and other dumb terminals.
    else
        printf "\e]%s\e\\" "$1"
    fi
}

vterm_prompt_end() {
    vterm_printf "51;A$(whoami)@$(hostname):$(pwd)";
}
setopt PROMPT_SUBST
PROMPT=$PROMPT'%{$(vterm_prompt_end)%}
#+end_src
***** Emacs packages
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "emacs.scm")
:END:
#+begin_src scheme
(define-module (ebullient home emacs)
  #:use-module (guix gexp)
  #:use-module (guix git-download)
  #:use-module (guix packages)
  #:use-module ((guix utils) #:select (substitute-keyword-arguments))
  #:use-module ((gnu packages compression) #:select (zstd))
  #:use-module ((flat packages emacs) #:select (emacs-native-comp emacs-pgtk-native-comp))
  #:use-module (mendicant utils)
  #:export (emacs-fully-loaded))
#+end_src
****** Emacs fully loaded :package:
#+begin_src scheme
(define* (emacs-fully-loaded #:key pgtk?)
  (-> (if pgtk?
          (with-emacs-latest emacs-pgtk-native-comp)
          emacs-native-comp)
      with-findable-C-source
      with-zstd
      with-path-integration-improvements))
#+end_src
****** Emacs latest :version:
#+begin_src scheme
(define-public (with-emacs-latest emacs)
  (with-mirror
   (let ((commit "7865b516c8dbff0e7872c746c7afca968ee2348a")
         (revision "0"))
     (package
       (inherit emacs)
       (version (git-version "29.0.50" revision commit))
       (source
        (origin
          (inherit (package-source emacs))
          (uri (git-reference
                (inherit (-> emacs package-source origin-uri))
                (commit commit)))
          (sha256
           (base32
            "1kiiwdr8lgmnb1mbfn8v0zlpy20nyiqsdx6fixd2fyqwaynk9asv"))
          (file-name (git-file-name (package-name emacs) version))))))))
#+end_src
******* Mirror
The canonical repo (https://git.savannah.gnu.org/git/emacs.git) doesn't allow shallow fetches.
#+begin_src scheme
(define (with-git-url pkg url)
  (package
    (inherit pkg)
    (source
     (origin
       (inherit (package-source pkg))
       (uri (git-reference
             (inherit (-> pkg package-source origin-uri))
             (url url)))))))

(define (with-mirror emacs)
  (with-git-url emacs "https://github.com/emacs-mirror/emacs"))
#+end_src
****** Findable C source
#+begin_src scheme
(define-public (with-findable-C-source emacs)
  (package
    (inherit emacs)
    (arguments
     (substitute-keyword-arguments (package-arguments emacs)
       ((#:phases phases '%standard-phases)
        #~(modify-phases #$phases
            (add-after 'unpack 'patch-C-source-directory
              (lambda _
                (substitute* "lisp/emacs-lisp/find-func.el"
                  (("\\(expand-file-name \"src\" source-directory\\)")
                   (string-append "\"" #$(file-append (package-source emacs) "/src") "\"")))))))))))
#+end_src
****** =zstd=
#+begin_src scheme
(define-public (with-zstd emacs)
  (package
    (inherit emacs)
    (propagated-inputs
     (modify-inputs (package-propagated-inputs emacs)
       (prepend zstd)))))
#+end_src
******* TODO [#E] Add =zstd= to emacs program wrapper
i.e. by using ~wrap-program~ on the emacs executable instead of just adding it to the propagated inputs. It's a bit tricky (see the ~strip-double-wrap~ build phase in the emacs package definition) and I don't want to mess it up and introduce possibly subtle problems.
****** Path integration improvements
#+begin_src scheme
(define-public (with-path-integration-improvements emacs)
  (package
    (inherit emacs)
    (source
     (origin
       (inherit (package-source emacs))
       (snippet
        `(begin
           ,(origin-snippet (package-source emacs))
           (let ((wrap-in-quotes (lambda (s)
                                   (string-append "\"" s "\""))))
             (with-directory-excursion "lisp"
               (substitute* "net/tramp.el"
                 (("\\(tramp-default-remote-path" start-of-list)
                  (string-join
                   (cons start-of-list
                         (map wrap-in-quotes
                              (list "~/.config/guix/current/bin"
                                    "~/.guix-home/profile")))
                   " ")))
               (substitute* "man.el"
                 (("\"/usr/local/include\"" last-item)
                  (string-join
                   (list last-item
                         (wrap-in-quotes "~/.guix-home/profile/include"))
                   " ")))))))))))
#+end_src
***** Doom
#+begin_src scheme
(define (he-doom svcs)
  (cons*
   (service
    (service-type
     (name 'he-doom)
     (extensions
      (list
       (service-extension
        home-profile-service-type
        (const (list `(,doom-emacs "bin")
                     font-fira-code))) ; TODO maybe make this contributed by the doom /config/ specifically. Really what I want is to unquote a gexp for it inside the config like I'll be doing for e.g. the sway config. Even though my Doom private config is in elisp and not scheme, how might I do this as similarly to that as possible?
       (service-extension
        home-xdg-configuration-files-service-type
        (const `(("emacs"
                  ,#~#$doom-emacs)
                 ;; ("config/doom"
                 ;;  ,(local-file "doom-private" #:recursive? #t))
                 )))))
     (default-value #f)))
   svcs))
#+end_src
****** Doom Emacs :package:version:
#+begin_src scheme :tangle (meta-in-dir "doom-emacs.scm")
(define-module (ebullient home doom-emacs)
  #:use-module (guix build-system copy)
  #:use-module (guix gexp)
  #:use-module (guix git-download)
  #:use-module (guix packages)
  #:use-module ((guix licenses) #:prefix license:)
  ;; #:use-module ((gnu packages emacs) #:select (emacs))
  #:use-module ((gnu packages rust-apps) #:select (fd ripgrep))
  #:use-module ((gnu packages version-control) #:select (git))
  #:use-module ((ebullient home fonts) #:select (all-the-icons-fonts)))

(define-public doom-emacs
  (let ((commit "d7ad4daf32df749a468f97cdd94e6f9715204e8c")
        (revision "0"))
    (package
      (name "doom-emacs")
      (version (git-version "3.0.0-dev" revision commit))
      (source
       (origin
         (method git-fetch)
         (uri (git-reference
               (url "https://github.com/doomemacs/doomemacs")
               (commit commit)))
         (sha256
          (base32
           "1fmgwdrkny9i4sfm0pz6hmpk11pvbfvd6zvy3vg4xpyip674zalp"))
         (file-name (git-file-name name version))
         (patches
          (list (local-file "change-paths.patch")
                (local-file "ligatures.patch")))))
      (build-system copy-build-system) ; TOOD LICENSE file gets installed to a "share/" folder, not hurting anything but maybe remove. More generally perhaps check to see what other changes there might be between a simple checkout of the repo and post- copy-build-system
      (arguments
       (list
        ;; #:install-plan
        ;; '(("." "share/doom-emacs/"))
        ;; #:tests? #t
        ;; #:test-command '("./bin/doom" "test")
        #:phases
        #~(modify-phases %standard-phases
            (add-after 'install 'symlink-bin
              (lambda _
                (mkdir #$output:bin)
                (symlink (string-append #$output "/bin")
                         (string-append #$output:bin "/bin")))))))
      (propagated-inputs
       (list ;; emacs ; TODO uncomment and wrap usage(s) with `package-input-rewriting`
             git
             ripgrep
             fd
             all-the-icons-fonts))
      (outputs '("out" "bin"))
      (synopsis "An Emacs framework for the stubborn martian hacker")
      (description "Doom is a configuration framework for GNU Emacs tailored for
Emacs bankruptcy veterans who want less framework in their frameworks, a modicum
of stability (and reproducibility) from their package manager, and the
performance of a hand rolled config (or better).")
      (home-page "https://github.com/doomemacs/doomemacs")
      (license license:expat))))
#+end_src
******* WAIT Doom tests :wait_on_doom:
Nonfunctional at the moment ([[doom:core/core-cli.el::212][hlissner has them commented out]]) but once they're working determine if they make sense to run during packaging (if they can find places where my patches, substitutions, etc. can mess stuff up). I'm concerned they'll take too long to run or require network access (to download Straight dependencies). Make sure there aren't any side effect files that end up getting installed.
******* Emacs packages :package:version:
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "emacs-xyz.scm")
:END:
#+begin_src scheme
(define-module (ebullient home emacs-xyz)
  #:use-module (guix build-system copy)
  #:use-module (guix build-system emacs)
  #:use-module (guix download)
  #:use-module (guix gexp)
  #:use-module (guix git-download)
  #:use-module (guix packages)
  #:use-module ((guix licenses) #:prefix license:)
  #:use-module ((guix utils) #:select (substitute-keyword-arguments))
  #:use-module ((gnu packages emacs-xyz) #:select (emacs-tldr) #:prefix emacs-xyz:)
  #:use-module ((gnu packages compression) #:select (unzip)))
#+end_src
******** guix-contributing
#+begin_src scheme
(define-public emacs-guix-contributing
  (package
    (name "emacs-guix-contributing")
    (version "0")
    (source
     (local-file "guix-contributing.el"))
    (build-system emacs-build-system)
    (arguments
     '(#:phases
       (modify-phases %standard-phases
         (add-after 'unpack 'patch-guix-source-path
           (lambda* (#:key inputs #:allow-other-keys)
             (make-file-writable "guix-contributing.el")
             (emacs-substitute-variables "guix-contributing.el"
               ("guix-contributing-source-path" (search-input-directory inputs "share/guix-emacs-development"))))))))
    (inputs
     (list guix-emacs-development))
    (home-page #f)
    (synopsis "Some Emacs integration to assist in contributing to Guix")
    (description "See https://guix.gnu.org/manual/en/guix.html#The-Perfect-Setup")
    (license license:gpl3+)))
#+end_src
********* Source
#+begin_src elisp :tangle (meta-in-dir "guix-contributing.el")
(defvar guix-contributing-source-path "~/src/guix")

(with-eval-after-load 'yasnippet
  (add-to-list 'yas-snippet-dirs (concat guix-contributing-source-path "/etc/snippets")))

(load-file (concat guix-contributing-source-path "/etc/copyright.el"))

(when (and user-full-name
           user-mail-address)
  (setq copyright-names-regexp (format "%s <%s>" user-full-name user-mail-address)))

(provide 'guix-contributing)
#+end_src
********* Guix's Emacs development code
#+begin_src scheme
(define guix-emacs-development
  (let ((commit "bf0389a3806509650b7a8425973ac5aac722901a")
        (revision "0"))
    (package
      (name "guix-emacs-development")
      (version (git-version "1.3.0" revision commit))
      (source
       (origin
         (method git-fetch)
         (uri (git-reference
               (url "https://github.com/guix-mirror/guix") ; https://git.savannah.gnu.org/git/guix.git is the canonical repo but it doesn't allow shallow fetches.
               (commit commit)))
         (sha256
          (base32
           "0x4mpw017q4l14aimlyzxxa68jz2rn6zb8m8l7s791fkkdn2paja"))))
      (build-system copy-build-system)
      (arguments
       `(#:install-plan
         '(("etc/copyright.el" "share/guix-emacs-development/etc/copyright.el")
           ("etc/snippets" "share/guix-emacs-development/etc/snippets"))))
      (home-page #f)
      (synopsis #f)
      (description #f)
      (license #f))))
#+end_src
******** tldr
#+begin_src scheme
(define-public emacs-tldr
  (package
    (inherit emacs-xyz:emacs-tldr)
    (arguments
     (substitute-keyword-arguments (package-arguments emacs-xyz:emacs-tldr)
       ((#:phases phases '%standard-phases)
        #~(modify-phases #$phases
            (add-after 'unpack 'patch-tldr-directory-path
              (lambda* (#:key inputs #:allow-other-keys)
                (emacs-substitute-variables "tldr.el"
                  ("tldr-directory-path" (search-input-directory inputs "share/tldr-pages")))))))))
    (inputs (modify-inputs (package-inputs emacs-xyz:emacs-tldr)
              (prepend tldr-pages)))))
#+end_src
********* tldr pages
#+begin_src scheme
(define tldr-pages
  (let ((commit "7ee7ed0f4afc90ef05b1dde87f6fec5b462a0394")
        (revision "0"))
    (package
      (name "tldr-pages")
      (version (git-version "1.5b" revision commit))
      (source
       (origin
         (method url-fetch/zipbomb)
         (uri (string-append "https://raw.githubusercontent.com/tldr-pages/tldr-pages.github.io/" commit "/assets/tldr.zip"))
         (sha256
          (base32
           "0a09ycfrxiaxv0hzjrkwi56l0ga5d7ydrlclmk4vd6ndb242vhgr"))))
      (build-system copy-build-system)
      (arguments
       `(#:install-plan
         '(("." "share/tldr-pages/"))))
      (home-page "https://tldr.sh")
      (synopsis "A collection of community-maintained help pages for command-line tools")
      (description synopsis)
      (license license:cc-by4.0))))
#+end_src
******* all-the-icons fonts :package:version:
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "fonts.scm")
:END:
#+begin_src scheme
(define-module (ebullient home fonts)
  #:use-module (guix build-system font)
  #:use-module (guix git-download)
  #:use-module (guix packages)
  #:use-module ((gnu packages emacs-xyz) #:select (emacs-all-the-icons))
  #:use-module ((gnu packages fonts) #:select (font-awesome font-google-material-design-icons) #:prefix fonts:)
  #:use-module (mendicant utils))

(define-public all-the-icons-fonts
  (let ((base-pkg emacs-all-the-icons)
        (commit "2c963ebb75f211d2f7ac3d2db5f4a9ee2f3e27da")
        (revision "0"))
    (package
      (name "all-the-icons-fonts")
      (version (git-version (package-version base-pkg) revision commit))
      (source
       (origin
         (method git-fetch)
         (uri (git-reference
               (url (-> base-pkg package-source origin-uri git-reference-url))
               (commit commit)))
         (sha256
          (base32
           "1gn5nyyhrvz8w1y5m8lg2khwfir0czjizmdzinr70gd7n8g1xqk9"))
         (file-name (git-file-name name version))))
      (build-system font-build-system)
      (arguments
       `(#:phases
         (modify-phases %standard-phases
           (add-before 'install 'remove-unbundled-fonts
             (lambda _
               (with-directory-excursion "fonts"
                 (for-each delete-file
                           (list "fontawesome.ttf"
                                 "material-design-icons.ttf"))))))))
      (propagated-inputs
       (list font-awesome
             fonts:font-google-material-design-icons))
      (home-page (package-home-page base-pkg))
      (synopsis (package-synopsis base-pkg))
      (description (package-description base-pkg))
      (license (package-license base-pkg)))))
#+end_src
******** Font Awesome :package:version:
#+begin_src scheme
(define-public font-awesome
  (let ((base-pkg fonts:font-awesome))
    (package (inherit base-pkg)
      (version "6.0.0")
      (source
       (origin
         (method git-fetch)
         (uri (git-reference
               (url (-> base-pkg package-source origin-uri git-reference-url))
               (commit version)))
         (file-name (git-file-name (package-name base-pkg) version))
         (sha256
          (base32
           "1zc4dzzcqg0xmykb4bbzcz4dxzr369k9lcx34s8yny0iakxg1xb8"))))
      (build-system font-build-system)
      (arguments '()))))
#+end_src
******* Patches
******** Change paths
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "change-paths.patch")
:END:
********* Core
#+begin_src diff
diff --git a/core/core.el b/core/core.el
index 493e9c0e6..344111bde 100644
--- a/core/core.el
+++ b/core/core.el
@@ -76,7 +76,9 @@ envvar will enable this at startup.")
 (defconst doom-local-dir
   (if-let (localdir (getenv-internal "DOOMLOCALDIR"))
       (expand-file-name (file-name-as-directory localdir))
-    (concat doom-emacs-dir ".local/"))
+    (expand-file-name "doom-local/"
+                      (or (getenv-internal "XDG_STATE_HOME")
+                          "~/.local/state")))
   "Root directory for local storage.
 
 Use this as a storage location for this system's installation of Doom Emacs.
@@ -84,13 +86,20 @@ Use this as a storage location for this system's installation of Doom Emacs.
 These files should not be shared across systems. By default, it is used by
 `doom-etc-dir' and `doom-cache-dir'. Must end with a slash.")
 
-(defconst doom-etc-dir (concat doom-local-dir "etc/")
+(defconst doom-state-dir
+  (if-let (localdir (getenv-internal "DOOMLOCALDIR"))
+      (concat (expand-file-name (file-name-as-directory localdir)) "state/")
+    (expand-file-name "doom/"
+                      (or (getenv-internal "XDG_STATE_HOME")
+                          "~/.local/state"))))
+
+(defconst doom-etc-dir (concat doom-state-dir "etc/")
   "Directory for non-volatile local storage.
 
 Use this for files that don't change much, like server binaries, external
 dependencies or long-term shared data. Must end with a slash.")
 
-(defconst doom-cache-dir (concat doom-local-dir "cache/")
+(defconst doom-cache-dir (concat doom-state-dir "cache/")
   "Directory for volatile local storage.
 
 Use this for files that change often, like cache files. Must end with a slash.")
@@ -167,7 +176,7 @@ users).")
 (when NATIVECOMP
   ;; Don't store eln files in ~/.emacs.d/eln-cache (they are likely to be purged
   ;; when upgrading Doom).
-  (add-to-list 'native-comp-eln-load-path (concat doom-cache-dir "eln/"))
+  (add-to-list 'native-comp-eln-load-path (concat doom-local-dir "eln/"))
 
   (with-eval-after-load 'comp
     ;; HACK Disable native-compilation for some troublesome packages
@@ -183,7 +192,7 @@ users).")
 
 ;; We avoid `no-littering' because it's a mote too opinionated for our needs.
 (setq async-byte-compile-log-file  (concat doom-etc-dir "async-bytecomp.log")
-      custom-file                  (concat doom-private-dir "custom.el")
+      custom-file                  (concat doom-state-dir "custom.el")
       desktop-dirname              (concat doom-etc-dir "desktop")
       desktop-base-file-name       "autosave"
       desktop-base-lock-name       "autosave-lock"
#+end_src
********* RSS module
#+begin_src diff
diff --git a/modules/app/rss/config.el b/modules/app/rss/config.el
index a8078d18f..075a5c8a7 100644
--- a/modules/app/rss/config.el
+++ b/modules/app/rss/config.el
@@ -20,8 +20,8 @@ easier to scroll through.")
 (use-package! elfeed
   :commands elfeed
   :init
-  (setq elfeed-db-directory (concat doom-local-dir "elfeed/db/")
-        elfeed-enclosure-default-dir (concat doom-local-dir "elfeed/enclosures/"))
+  (setq elfeed-db-directory (concat doom-cache-dir "elfeed/db/")
+        elfeed-enclosure-default-dir (concat doom-cache-dir "elfeed/enclosures/"))
   :config
   (setq elfeed-search-filter "@2-week-ago "
         elfeed-show-entry-switch #'pop-to-buffer
#+end_src
******** Ligatures
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "ligatures.patch")
:END:
Taken from this as-yet unmerged pull request: [[https://github.com/doomemacs/doomemacs/pull/5082][doomemacs/doomemacs#5082 feat(:ui ligatures): use ligature.el for Emacs28+ by...]]
********* README
#+begin_src diff
diff --git a/modules/ui/ligatures/README.org b/modules/ui/ligatures/README.org
index 66d969ff1..ed486dbf6 100644
--- a/modules/ui/ligatures/README.org
+++ b/modules/ui/ligatures/README.org
@@ -16,8 +16,10 @@
   - [[#mathematical-symbols-replacement][Mathematical symbols replacement]]
   - [[#coding-ligatures][Coding ligatures]]
 - [[#configuration][Configuration]]
-  - [[#setting-ligatures][Setting ligatures]]
-  - [[#changing-ligatures][Changing ligatures]]
+  - [[#setting-symbol-replacements][Setting symbol replacements]]
+  - [[#changing-symbol-replacements][Changing symbol replacements]]
+  - [[#setting-ligatures-for-specific-font-or-major-mode][Setting ligatures for specific font or major mode]]
+    - [[#overwriting-all-default-ligatures][Overwriting all default ligatures]]
 - [[#troubleshooting][Troubleshooting]]
 
 ,* Description
@@ -53,7 +55,7 @@ Harfbuzz support (which can compose ligatures natively), or b) Mitsuharu's
 ,#+end_quote
 
 ,** Plugins
-This module installs no packages.
+- [[https://github.com/mickeynp/ligature.el][ligature.el]] (on Emacs 28+ with Harfbuzz)
 
 ,* Prerequisites
 This module requires one of three setups for ligatures to work:
@@ -103,9 +105,9 @@ Even though harfbuzz has been included in emacs 27, there is currently a [[https
 emacs 27.
 
 ,* Configuration
-** Setting ligatures
-If you want to set ligatures for modules that don't have them by default you can
-use the ~set-ligatures!~ macro in your config el file
+** Setting symbol replacements
+If you want to set symbol replacements for modules that don't have them by
+default you can use the ~set-ligatures!~ macro in your config el file
 ,#+BEGIN_SRC emacs-lisp
 (after! PACKAGE
   (set-ligatures! 'MAJOR-MODE
@@ -167,7 +169,7 @@ If you have multiple versions of the same keyword you can set the symbol twice
   :null "none"
   :null "None")
 ,#+END_SRC
-** Changing ligatures
+** Changing symbol replacements
 if you don't like the symbols chosen you can change them by using...
 
 ,#+BEGIN_SRC emacs-lisp
@@ -212,5 +214,53 @@ if you don't like the symbols chosen you can change them by using...
   :dot           "•")  ;; you could also add your own if you want
 ,#+END_SRC
 
+** Setting ligatures for specific font or major mode
+#+begin_quote
+You need Emacs 28+ with (MacOS or Harfbuzz) for EmacsLisp in this section to work.
+#+end_quote
+
+As the [[https://github.com/mickeynp/ligature.el][README]] for ligature.el states, you can manipulate the ligatures that you
+want to enable, specific for your font, or specific for the major modes that you
+want to use.
+
+#+begin_src elisp
+(after! ligature
+  (ligature-set-ligatures '(haskell-mode clojure-mode) '(">>=")))
+
+;; Alternatively
+(set-ligatures! '(haskell-mode clojure-mode)
+  :font-ligatures '(">>="))
+#+end_src
+
+This call will:
+- overwrite all preceding calls to =ligature-set-ligatures= or =set-ligatures!=
+  for =haskell-mode= and =clojure-mode= specifically, but
+- keep the inheritance to ligatures set for all modes, or parent modes like =prog-mode=
+
+*** Overwriting all default ligatures
+If you want to "start from scratch" and get control over all ligatures that
+happen in all modes, you can use
+
+#+begin_src elisp
+;; Set all your custom ligatures for all prog-modes here
+;; This section is *out of* the after! block
+;; Example: only get ligatures for "==" and "===" in programming modes
+;; by default, and get only "www" in all buffers by default.
+(setq +ligatures-prog-mode-list '("==" "===")
+      +ligatures-all-modes-list '("www"))
+;; Set any of those variables to nil to wipe all defaults.
+
+;; All mode specific configuration go in the `after!' block
+(after! ligature
+  ;; Set all your additional custom ligatures for other major modes here.
+  ;; Example: enable traditional ligature support in eww-mode, if the
+  ;; `variable-pitch' face supports it
+  (ligature-set-ligatures 'eww-mode '("ff" "fi" "ffi")))
+
+;; Alternatively
+(set-ligatures! 'eww-mode
+  :font-ligatures '("ff" "fi" "ffi"))
+#+end_src
+
 ,* TODO Troubleshooting
  If you have any problems with this module, do get in touch!
#+end_src
********* Autoload
#+begin_src diff
diff --git a/modules/ui/ligatures/autoload/ligatures.el b/modules/ui/ligatures/autoload/ligatures.el
index 7856ff7c1..06486a4ec 100644
--- a/modules/ui/ligatures/autoload/ligatures.el
+++ b/modules/ui/ligatures/autoload/ligatures.el
@@ -9,17 +9,24 @@
   "Associates string patterns with icons in certain major-modes.
 
   MODES is a major mode symbol or a list of them.
-  PLIST is a property list whose keys must match keys in
-`+ligatures-extra-symbols', and whose values are strings representing the text
-to be replaced with that symbol. If the car of PLIST is nil, then unset any
-pretty symbols previously defined for MODES.
+  PLIST is a property list whose keys must either:
 
-This function accepts one special property:
+  - match keys in
+`+ligatures-extra-symbols', and whose values are strings representing the text
+to be replaced with that symbol, or
+ - be one of two special properties:
 
   :alist ALIST
     Appends ALIST to `prettify-symbols-alist' literally, without mapping text to
     `+ligatures-extra-symbols'.
 
+  :font-ligatures LIST
+    Sets the list of strings that should get transformed by the font into ligatures,
+    like \"==\" or \"-->\". LIST is a list of strings.
+
+If the car of PLIST is nil, then unset any
+pretty symbols and ligatures previously defined for MODES.
+
 For example, the rule for emacs-lisp-mode is very simple:
 
   (set-ligatures! 'emacs-lisp-mode
@@ -30,18 +37,32 @@ assicated with :lambda in `+ligatures-extra-symbols'.
 
 Pretty symbols can be unset for emacs-lisp-mode with:
 
-  (set-ligatures! 'emacs-lisp-mode nil)"
+  (set-ligatures! 'emacs-lisp-mode nil)
+
+Note that this will keep all ligatures in `+ligatures-prog-mode-list' active, as
+`emacs-lisp-mode' is derived from `prog-mode'."
   (declare (indent defun))
   (if (null (car-safe plist))
       (dolist (mode (doom-enlist modes))
-        (delq! mode +ligatures-extra-alist 'assq))
-    (let (results)
+        (delq! mode +ligatures-extra-alist 'assq)
+        (add-to-list 'ligature-ignored-major-modes mode))
+    (let ((results)
+          (font-ligatures))
       (while plist
         (let ((key (pop plist)))
-          (if (eq key :alist)
-              (prependq! results (pop plist))
+          (cond
+           ((eq key :alist)
+            (prependq! results (pop plist)))
+           ((eq key :font-ligatures)
+            (setq font-ligatures (pop plist)))
+           (t
             (when-let (char (plist-get +ligatures-extra-symbols key))
-              (push (cons (pop plist) char) results)))))
+              (push (cons (pop plist) char) results))))))
+      (when font-ligatures
+        (with-eval-after-load 'ligature
+          (dolist (mode (doom-enlist modes))
+            (setq ligature-ignored-major-modes (delete mode ligature-ignored-major-modes)))
+          (ligature-set-ligatures (doom-enlist modes) font-ligatures)))
       (dolist (mode (doom-enlist modes))
         (setf (alist-get mode +ligatures-extra-alist)
               (if-let (old-results (alist-get mode +ligatures-extra-alist))
#+end_src
********* Config
#+begin_src diff
diff --git a/modules/ui/ligatures/config.el b/modules/ui/ligatures/config.el
index 484945ceb..3958aefbd 100644
--- a/modules/ui/ligatures/config.el
+++ b/modules/ui/ligatures/config.el
@@ -47,44 +47,25 @@ font.")
 (defvar +ligatures-extra-alist '((t))
   "A map of major modes to symbol lists (for `prettify-symbols-alist').")
 
-(defvar +ligatures-composition-alist
-  '((?!  . "\\(?:!\\(?:==\\|[!=]\\)\\)")                                      ; (regexp-opt '("!!" "!=" "!=="))
-    (?#  . "\\(?:#\\(?:###?\\|_(\\|[#(:=?[_{]\\)\\)")                         ; (regexp-opt '("##" "###" "####" "#(" "#:" "#=" "#?" "#[" "#_" "#_(" "#{"))
-    (?$  . "\\(?:\\$>>?\\)")                                                  ; (regexp-opt '("$>" "$>>"))
-    (?%  . "\\(?:%%%?\\)")                                                    ; (regexp-opt '("%%" "%%%"))
-    (?&  . "\\(?:&&&?\\)")                                                    ; (regexp-opt '("&&" "&&&"))
-    (?*  . "\\(?:\\*\\(?:\\*[*/]\\|[)*/>]\\)?\\)")                            ; (regexp-opt '("*" "**" "***" "**/" "*/" "*>" "*)"))
-    (?+  . "\\(?:\\+\\(?:\\+\\+\\|[+:>]\\)?\\)")                              ; (regexp-opt '("+" "++" "+++" "+>" "+:"))
-    (?-  . "\\(?:-\\(?:-\\(?:->\\|[>-]\\)\\|<[<-]\\|>[>-]\\|[:<>|}~-]\\)\\)") ; (regexp-opt '("--" "---" "-->" "--->" "->-" "-<" "-<-" "-<<" "->" "->>" "-}" "-~" "-:" "-|"))
-    (?.  . "\\(?:\\.\\(?:\\.[.<]\\|[.=>-]\\)\\)")                             ; (regexp-opt '(".-" ".." "..." "..<" ".=" ".>"))
-    (?/  . "\\(?:/\\(?:\\*\\*\\|//\\|==\\|[*/=>]\\)\\)")                      ; (regexp-opt '("/*" "/**" "//" "///" "/=" "/==" "/>"))
-    (?:  . "\\(?::\\(?:::\\|[+:<=>]\\)?\\)")                                  ; (regexp-opt '(":" "::" ":::" ":=" ":<" ":=" ":>" ":+"))
-    (?\; . ";;")                                                              ; (regexp-opt '(";;"))
-    (?0  . "0\\(?:\\(x[a-fA-F0-9]\\).?\\)") ; Tries to match the x in 0xDEADBEEF
-    ;; (?x . "x") ; Also tries to match the x in 0xDEADBEEF
-    ;; (regexp-opt '("<!--" "<$" "<$>" "<*" "<*>" "<**>" "<+" "<+>" "<-" "<--" "<---" "<->" "<-->" "<--->" "</" "</>" "<<" "<<-" "<<<" "<<=" "<=" "<=<" "<==" "<=>" "<===>" "<>" "<|" "<|>" "<~" "<~~" "<." "<.>" "<..>"))
-    (?<  . "\\(?:<\\(?:!--\\|\\$>\\|\\*\\(?:\\*?>\\)\\|\\+>\\|-\\(?:-\\(?:->\\|[>-]\\)\\|[>-]\\)\\|\\.\\(?:\\.?>\\)\\|/>\\|<[<=-]\\|=\\(?:==>\\|[<=>]\\)\\||>\\|~~\\|[$*+./<=>|~-]\\)\\)")
-    (?=  . "\\(?:=\\(?:/=\\|:=\\|<[<=]\\|=[=>]\\|>[=>]\\|[=>]\\)\\)")         ; (regexp-opt '("=/=" "=:=" "=<<" "==" "===" "==>" "=>" "=>>" "=>=" "=<="))
-    (?>  . "\\(?:>\\(?:->\\|=>\\|>[=>-]\\|[:=>-]\\)\\)")                      ; (regexp-opt '(">-" ">->" ">:" ">=" ">=>" ">>" ">>-" ">>=" ">>>"))
-    (??  . "\\(?:\\?[.:=?]\\)")                                               ; (regexp-opt '("??" "?." "?:" "?="))
-    (?\[ . "\\(?:\\[\\(?:|]\\|[]|]\\)\\)")                                    ; (regexp-opt '("[]" "[|]" "[|"))
-    (?\\ . "\\(?:\\\\\\\\[\\n]?\\)")                                          ; (regexp-opt '("\\\\" "\\\\\\" "\\\\n"))
-    (?^  . "\\(?:\\^==?\\)")                                                  ; (regexp-opt '("^=" "^=="))
-    (?w  . "\\(?:wwww?\\)")                                                   ; (regexp-opt '("www" "wwww"))
-    (?{  . "\\(?:{\\(?:|\\(?:|}\\|[|}]\\)\\|[|-]\\)\\)")                      ; (regexp-opt '("{-" "{|" "{||" "{|}" "{||}"))
-    (?|  . "\\(?:|\\(?:->\\|=>\\||=\\|[]=>|}-]\\)\\)")                        ; (regexp-opt '("|=" "|>" "||" "||=" "|->" "|=>" "|]" "|}" "|-"))
-    (?_  . "\\(?:_\\(?:|?_\\)\\)")                                            ; (regexp-opt '("_|_" "__"))
-    (?\( . "\\(?:(\\*\\)")                                                    ; (regexp-opt '("(*"))
-    (?~  . "\\(?:~\\(?:~>\\|[=>@~-]\\)\\)"))                                  ; (regexp-opt '("~-" "~=" "~>" "~@" "~~" "~~>"))
-  "An alist of all ligatures used by `+ligatures-extras-in-modes'.
-
-The car is the character ASCII number, cdr is a regex which will call
-`font-shape-gstring' when matched.
-
-Because of the underlying code in :ui ligatures module, the regex should match a
-string starting with the character contained in car.
-
-This variable is used only if you built Emacs with Harfbuzz on a version >= 28")
+(defvar +ligatures-prog-mode-list
+  '("|||>" "<|||" "<==>" "<!--" "####" "~~>" "***" "||=" "||>"
+    ":::" "::=" "=:=" "===" "==>" "=!=" "=>>" "=<<" "=/=" "!=="
+    "!!." ">=>" ">>=" ">>>" ">>-" ">->" "->>" "-->" "---" "-<<"
+    "<~~" "<~>" "<*>" "<||" "<|>" "<$>" "<==" "<=>" "<=<" "<->"
+    "<--" "<-<" "<<=" "<<-" "<<<" "<+>" "</>" "###" "#_(" "..<"
+    "..." "+++" "/==" "///" "_|_" "www" "&&" "^=" "~~" "~@" "~="
+    "~>" "~-" "**" "*>" "*/" "||" "|}" "|]" "|=" "|>" "|-" "{|"
+    "[|" "]#" "::" ":=" ":>" ":<" "$>" "==" "=>" "!=" "!!" ">:"
+    ">=" ">>" ">-" "-~" "-|" "->" "--" "-<" "<~" "<*" "<|" "<:"
+    "<$" "<=" "<>" "<-" "<<" "<+" "</" "#{" "#[" "#:" "#=" "#!"
+    "##" "#(" "#?" "#_" "%%" ".=" ".-" ".." ".?" "+>" "++" "?:"
+    "?=" "?." "??" ";;" "/*" "/=" "/>" "//" "__" "~~" "(*" "*)"
+    "\\\\" "://")
+  "A list of ligatures to enable in all `prog-mode' buffers.")
+
+(defvar +ligatures-all-modes-list
+  '()
+  "A list of ligatures to enable in all buffers.")
 
 (defvar +ligatures-in-modes
   '(not special-mode comint-mode eshell-mode term-mode vterm-mode Info-mode
@@ -182,15 +163,19 @@ and cannot run in."
  ((and EMACS28+
        (or (featurep 'ns)
            (string-match-p "HARFBUZZ" system-configuration-features))
-       (featurep 'composite))  ; Emacs loads `composite' at startup
-  (defvar +ligature--composition-table (make-char-table nil))
+       (featurep 'composite))           ; Emacs loads `composite' at startup
+
+  (use-package! ligature
+    :config
+    ;; Enable all `+ligatures-prog-mode-list' ligatures in programming modes
+    (ligature-set-ligatures 'prog-mode +ligatures-prog-mode-list)
+    (ligature-set-ligatures 't +ligatures-all-modes-list))
+
   (add-hook! 'doom-init-ui-hook :append
-    (defun +ligature-init-composition-table-h ()
-      (dolist (char-regexp +ligatures-composition-alist)
-        (set-char-table-range
-         +ligature--composition-table
-         (car char-regexp) `([,(cdr char-regexp) 0 font-shape-gstring])))
-      (set-char-table-parent +ligature--composition-table composition-function-table))))
+    (defun +ligature-enable-globally-h ()
+      "Enables ligature checks globally in all buffers.
+You can also do it per mode with `ligature-mode'."
+      (global-ligature-mode t))))
 
  ;; Fallback ligature support for certain, patched fonts. Install them with
  ;; `+ligatures/install-patched-font'
#+end_src
********* Packages
#+begin_src diff :noweb yes
diff --git a/modules/ui/ligatures/packages.el b/modules/ui/ligatures/packages.el
new file mode 100644
index 000000000..c710f766c
--- /dev/null
+++ b/modules/ui/ligatures/packages.el
@@ -0,0 +1,<<ligature-package-num-lines(4)>> @@
+(when (and EMACS28+
+           (or (featurep 'ns)
+               (string-match-p "HARFBUZZ" system-configuration-features))
+           (featurep 'composite))
+  <<ligature-package>>)
#+end_src
********** ligature.el package :version:
:PROPERTIES:
:header-args+: :tangle no
:END:
#+name: ligature-package
#+begin_src elisp
(package! ligature
  :recipe (:host github
           :repo "mickeynp/ligature.el"
           :files ("*.el"))
  :pin "9357156a917a021a87b33ee391567a5d8e44794a")
#+end_src

#+name: ligature-package-num-lines
#+begin_src elisp :var initial=""
(let ((num-lines
       (-> (-second-item (org-babel-lob--src-info "ligature-package"))
           (split-string (rx "\n"))
           length)))
  (+ initial num-lines))
#+end_src
******* \
- TODO write a command that shows me the git diff like doom-upgrade does and use it in my eventual dotfiles upgrade script
  https://github.com/doomemacs/doomemacs/compare/fca8bd7f3fa697a91774c2ddedcd1a47cd7da01a...849672691dd5d1214d6c72167ae84c03e8d9c8e3
******* packaging doom WIP
Extremely WIP, basically just a scratchpad
******** first attempts
#+begin_src scheme :tangle (meta-in-dir "packaging-doom-wip-1.scm")
(define-module (ebullient home packaging-doom-wip)
  #:use-module (guix build-system trivial)
  #:use-module (guix gexp)
  #:use-module (guix git-download)
  #:use-module (guix packages)
  #:use-module ((guix licenses) #:prefix license:)
  ;; #:use-module ((gnu packages emacs) #:select (emacs))
  #:use-module ((gnu packages version-control) #:select (git))
  #:use-module (ebullient home emacs)
  #:use-module (ebullient home doom-emacs)
  )

;; (define doom-inputs
;;   (computed-file
;;    "doom-inputs"
;;    (with-imported-modules '((guix build utils))
;;      #~(begin
;;          (use-modules (guix build utils))
;;          (invoke (string-append #+doom-emacs:bin "/bin/doom") "help")
;;          (copy-file #$(local-file "nixpkgs-config.nix") #$output)
;;          ;; `emacs-substitute-sexps' might be useful here if my needs get more sophisticated.
;;          ;; (substitute* #$output
;;          ;;   (("(dunstctl|dunst)" all) (case (string->symbol all)
;;          ;;                               ((dunst) (string-append #$(file-append dunst "/bin/dunst")
;;          ;;                                                       " -config " #$(local-file "dunstrc")))
;;          ;;                               ((dunstctl) #$(file-append dunst "/bin/dunstctl"))))
;;          ;;   (("nm-applet") #$(file-append network-manager-applet "/bin/nm-applet"))
;;          ;;   (("pasystray") #$(file-append pasystray "/bin/pasystray"))
;;          ;;   (("redshift-gtk") (string-append #$redshift:gtk "/bin/redshift-gtk"))
;;          ;;   (("udiskie") #$(file-append udiskie "/bin/udiskie")))
;;          ))))


(define-public temp-doom-emacs
  (package
    (name "doom-emacs")
    (version "0")
    (source
     (local-file "/home/pharcosyle/projects/dotfiles/doom-emacs" #:recursive? #t))
    (build-system (@ (guix build-system copy) copy-build-system))
    (synopsis "")
    (description "")
    (home-page "")
    (license #f)))

(define-public doom-inputs
  (package
    (name "doom-inputs")
    (version "0")
    (source #f)
    (inputs
     (list emacs-29-pgtk+native-comp
           ;; doom-emacs
           temp-doom-emacs
           ;; (local-file "doom-private" #:recursive? #t)
           git
           ;; (local-file "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/straight.el" #:recursive? #t)
           ;; (local-file "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/use-package" #:recursive? #t)
           ))
    (build-system trivial-build-system)
    (arguments
     `(#:modules ((guix build utils))
       #:builder
       ,#~(begin
            (use-modules (guix build utils))
            (let ((doom-private #$(local-file "doom-private" #:recursive? #t))
                  (doom-local-dir (string-append #$output "/doom-local")))
              (mkdir-p doom-local-dir)

              ;; (mkdir-p (string-append #$output "/asdf"))
              ;; (with-output-to-file (string-append #$output "/asdf/asdf.txt")
              ;;   (lambda _
              ;;     (display "asdffffffffffff")))

              (setenv "PATH" (string-append (getenv "PATH")
                                            ":" (assoc-ref %build-inputs "emacs-29-pgtk+native-comp") "/bin"
                                            ":" (assoc-ref %build-inputs "git") "/bin"
                                            ))
              ;; (setenv "DOOMDIR" (assoc-ref %build-inputs "doom-private"))
              (setenv "DOOMDIR" doom-private)
              (setenv "DOOMLOCALDIR" doom-local-dir)

              ;; (chdir #$output)
              ;; (invoke "git" "clone" "https://github.com/dracula/gtk")

              ;; (display "hi!")
              ;; (display doom-private)
              ;; (display straight-el)

              (let ((repos-dir (string-append doom-local-dir "/straight/repos")))
                (mkdir-p repos-dir)
                (symlink #$(local-file "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/straight.el" #:recursive? #t)
                         (string-append repos-dir "/straight.el"))
                (symlink #$(local-file "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/use-package" #:recursive? #t)
                         (string-append repos-dir "/use-package"))
                (symlink #$(local-file "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/melpa" #:recursive? #t)
                         (string-append repos-dir "/melpa"))
                (symlink #$(local-file "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/gnu-elpa-mirror" #:recursive? #t)
                         (string-append repos-dir "/gnu-elpa-mirror"))
                (symlink #$(local-file "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/el-get" #:recursive? #t)
                         (string-append repos-dir "/el-get"))
                (symlink #$(local-file "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/emacsmirror-mirror" #:recursive? #t)
                         (string-append repos-dir "/emacsmirror-mirror")))

              (setenv "HOME" "/tmp/asdfasdf")
              (mkdir-p "/tmp/asdfasdf")

              ;; (symlink #$(local-file "/home/pharcosyle/projects/dotfiles/doom-emacs" #:recursive? #t)
              ;;            (string-append #$output "/temp-doom-emacs"))
              (let ((doom
                     ;; #$(local-file "/home/pharcosyle/projects/dotfiles/doom-emacs" #:recursive? #t)
                     (assoc-ref %build-inputs "doom-emacs")
                     ;; (string-append #$output "/temp-doom-emacs")
                     ))
                ;; (invoke (string-append #$(@ (gnu packages base) coreutils) "/bin/echo") "asdfasdfsdf")
                ;; (invoke (string-append doom "/bin/doom") "help")
                (invoke (string-append doom "/bin/doom") "install" "--no-config" "--no-env" "--no-fonts" "--no-hooks")
                )

              ;; (copy-file #$(local-file "nixpkgs-config.nix") #$output)
              )


            #t)))

    ;; (arguments
    ;;  `(;; #:install-plan
    ;;    ;; '(("." "share/doom-emacs/"))
    ;;    ;; #:tests? #t
    ;;    ;; #:test-command '("./bin/doom" "test")
    ;;    #:phases
    ;;    ,#~(modify-phases %standard-phases
    ;;         (add-after 'install 'symlink-bin
    ;;           (lambda _
    ;;             (mkdir #$output:bin)
    ;;             (symlink (string-append #$output "/bin")
    ;;                      (string-append #$output:bin "/bin")))))))

    (synopsis "")
    (description "")
    (home-page "")
    (license #f)))





(use-modules ((guix packages) #:select (content-hash content-hash-algorithm content-hash-value)))

(define doom-build
  (computed-file
   "doom-build"
   (with-imported-modules '((guix build utils))
     #~(begin
         (use-modules (guix build utils))

         ;; (mkdir-p #$output)

         (setenv "GIT_SSL_NO_VERIFY" "true") ; do ssl if it's easy. Also if I'm using `(guix build git) git-fetch' consider if it setting this variable leaks out.

         ;; (invoke (string-append #+doom-emacs:bin "/bin/doom") "help")
         ;; (copy-file #$(local-file "nixpkgs-config.nix") #$output)
         ;; (invoke (string-append #$(@ (gnu packages wget) wget) "/bin/wget") "--no-check-certificate" "https://xkcd.com/")
         ;; (copy-file "index.html" #$output)

         ;; TODO Consider making e.g. emacs, git not ungexped in a let but instead everywhere they're used (and move this let outside of the gexp). Then I could use file-append instead of string-append in places I guess. Which is better practice?
         (let ((doom-private #+(file-union "doom-private"
                                           `(("init.el" ,(file-append (local-file "/home/pharcosyle/projects/dotfiles/doom-emacs" #:recursive? #t)
                                                                      "/init.example.el"))
                                             ("config.el" ,(file-append (local-file "/home/pharcosyle/projects/dotfiles/doom-emacs" #:recursive? #t)
                                                                        "/core/templates/config.example.el"))
                                             ("packages.el" ,(file-append (local-file "/home/pharcosyle/projects/dotfiles/doom-emacs" #:recursive? #t)
                                                                          "/core/templates/packages.example.el")))))
               ;; (doom-private #$(local-file "doom-private" #:recursive? #t))
               (doom-local-dir (string-append #$output "/doom-local"))
               (emacs #+emacs-29-pgtk+native-comp)
               (git #+git)
               ;; (emacs (assoc-ref %build-inputs "emacs-29-pgtk+native-comp"))
               ;; (git (assoc-ref %build-inputs "git"))
               (doom-emacs #+temp-doom-emacs)
               ;; (doom-emacs #+doom-emacs)
               ;; (doom-emacs (assoc-ref %build-inputs "doom-emacs"))
               ;; (doom-emacs #$(local-file "/home/pharcosyle/projects/dotfiles/doom-emacs" #:recursive? #t))
               )
           (mkdir-p doom-local-dir)

           (setenv "PATH" (string-append (getenv "PATH")
                                         ":" emacs "/bin"
                                         ":" git "/bin"
                                         ":" #+(@ (gnu packages base) coreutils) "/bin" ; donno if this is necessary
                                         ":" #+(@ (gnu packages base) sed) "/bin"
                                         ))
           ;; Is this a better/cleaner way to do path-setting? Consider also the comment (from git-download.scm), should I add more stuff to the path?
           ;;
           ;; The 'git submodule' commands expects Coreutils, sed,
           ;; grep, etc. to be in $PATH.
           ;; (set-path-environment-variable "PATH" '("bin")
           ;;                                (match '#+inputs
           ;;                                  (((names dirs outputs ...) ...)
           ;;                                   dirs)))

           (setenv "DOOMDIR" doom-private)
           (setenv "DOOMLOCALDIR" doom-local-dir)

           ;; (chdir #$output)
           ;; (invoke "git" "clone" "https://github.com/dracula/gtk")

           ;; donno if this is necessary
           (setenv "HOME" "/tmp/asdfasdf")
           (mkdir-p "/tmp/asdfasdf")

           ;; temporary straight.el experimentation
           ;; (mkdir-p "/tmp/asdfasdf/123456")
           (mkdir-p (string-append doom-local-dir "/straight/repos"))
           (symlink #+(local-file "/home/pharcosyle/projects/dotfiles/straight.el" #:recursive? #t)
                    (string-append doom-local-dir "/straight/repos/straight.el"))

           ;; (copy-file #$(local-file "nixpkgs-config.nix") (string-append doom-local-dir "/asdf.txt"))
           ;; (invoke (string-append doom-emacs "/bin/doom") "help")
           (invoke (string-append doom-emacs "/bin/doom") "install" "--no-config" "--no-env" "--no-fonts" "--no-hooks")
           ;; (invoke (string-append doom-emacs "/bin/doom") "upgrade")
           ;; (invoke (string-append doom-emacs "/bin/doom") "build")
           ;; (invoke (string-append doom-emacs "/bin/doom") "sync")

           ;; (invoke (string-append emacs "/bin/emacs") "--batch" "--eval=\"(progn (load user-init-file) (straight-freeze-versions))\"")
           ;; (invoke (string-append emacs "/bin/emacs") "--batch" "--eval='(progn (message \"hello!\"))'")
           ;; (invoke "emacs" "--batch" "--eval='(message \"hello!\")'")
           ;; (chdir #$output)
           ;; (invoke "emacs" "--batch" "--eval='(with-temp-file \"asdf.txt\" (insert \"asdfasdf\"))'")
           ;; (invoke "emacs" "--batch" "--eval='(message \"hello!\")'")
           ;; (invoke "emacs" "--help")
           ;; (invoke "echo" (string-append (string-append emacs "/bin/emacs") "--batch" (string-append "--load=" doom-emacs "/init.el") "--eval=(progn (message \"hi\") (message \"yo\"))"))
           ;; (invoke (string-append emacs "/bin/emacs") "--batch" (string-append "--load=" doom-emacs "/init.el") "--eval=(progn (message \"hi\") (straight-freeze-versions) (message \"yo\"))")
           ;; (invoke "echo" "asdf")

           )))
   #:options (let ((ch (content-hash "1zcpkabkizadc3j9jqnnpyqm4d71bnvxz2x6as53f6wjwn82ahd9")))
               (list #:hash (content-hash-value ch)
                     #:hash-algo (content-hash-algorithm ch)
                     #:recursive? #t
                     ;; #:substitutable? #f ; This isn't appropriate, right?
                     ))))

;; (define-public doom-build-pkg
;;   (package
;;     (name "doom-build-pkg")
;;     (version "0")
;;     (source doom-build)
;;     (build-system (@ (guix build-system copy) copy-build-system))
;;     (synopsis "")
;;     (description "")
;;     (home-page "")
;;     (license #f)))
#+end_src
******** second attempt
#+begin_src scheme :tangle (meta-in-dir "packaging-wip-2.scm") :comments link
(define-module (ebullient home packaging-wip)
  ;; #:use-module (guix build-system trivial)
  ;; #:use-module (guix gexp)
  ;; #:use-module (guix git-download)
  ;; #:use-module (guix packages)
  ;; #:use-module ((guix licenses) #:prefix license:)
  ;; ;; #:use-module ((gnu packages emacs) #:select (emacs))
  ;; #:use-module ((gnu packages version-control) #:select (git))
  ;; #:use-module (ebullient home emacs)
  ;; #:use-module (ebullient home doom-emacs)

  #:use-module ((guix packages) #:select (package-input-rewriting))
  #:use-module ((gnu packages emacs) #:select (emacs emacs-minimal emacs-no-x emacs-next emacs-next-pgtk emacs-xwidgets emacs-no-x-toolkit emacs-wide-int))

  )
(define emacs-variant (@ (ebullient home emacs) emacs-29-pgtk+native-comp))

;; TODO does this rewrite recursively?
;; package-input-rewriting/spec says it specifically does this while package-input-rewriting does not. And what about using `package-mapping'? I can check the final product for references to emacs/emacs-minimal but still read over the source code of each later. What about native-inputs, sometimes emacs(-minimal) is in there.
;; TODO do I need to specify all of the different emacs packages for rewriting?
;; Does it work without doing this already? Would package-input-rewriting/spec handle them somehow? Does `package/inherit' (in both the -spec and non-spec versions)?
(define with-emacs-variant
  (package-input-rewriting `((,emacs . ,emacs-variant)
                             (,emacs-minimal . ,emacs-variant)
                             (,emacs-no-x . ,emacs-variant)

                             ;; TODO maybe ths should be in a nested `package-input-rewriting' or having packages with themselves as input rewrites
                             ;; will cause problems, I donno. Putting this here for now.
                             (,(@ (gnu packages emacs-xyz) emacs-dash) . ,(@ (ebullient home emacs-xyz) emacs-dash)))))

;; (define-public test-reftex
;;   (with-emacs-variant (@ (gnu packages emacs-xyz) emacs-company-reftex)))
;; (define-public test-dash-existing
;;   (with-emacs-variant (@ (gnu packages emacs-xyz) emacs-dash)))
;; (define-public test-dash
;;   (with-emacs-variant (@ (ebullient home emacs-xyz) emacs-dash)))

;; (define orig-pkg (@ (gnu packages emacs-xyz) emacs-build-farm))
;; (define orig-pkg (@ (gnu packages emacs-xyz) emacs-cider))
(define orig-pkg (@ (gnu packages emacs-xyz) emacs-buttercup))

(define-public test-pkg
  (with-emacs-variant orig-pkg))





(use-modules (guix packages)
             (guix git-download))

(define (git-origin url commit hash recursive?)
  (origin
    (method git-fetch)
    (uri (git-reference
          (url url)
          (commit commit)
          (recursive? recursive?)))
    (sha256
     (base32
      hash))))



(use-modules (gnu packages)
             (guix profiles)
             ;; ((srfi srfi-1) #:select (remove))
             ;; (mendicant utils)
             )

;; (define (doom-ps)
;;   (->> (call-with-input-file "../doom-packaging/guix-doom-emacs-packages-from-straight-build-cache.txt" read)
;;        (remove
;;         (lambda (dpns)
;;           (member dpns (list "donnager"

;;                              "straight"

;;                              ;; TODO built-in, ignoring for now but handle this when grabbing from ~doom-packages~. It marks them as ~:ignored t~
;;                              ;; - but what about built-in 'prefer, this isn't marked specially
;;                              "hideshow"
;;                              "vc"
;;                              "vc-annotate"
;;                              "smerge-mode"
;;                              "elisp-mode"
;;                              "css-mode"

;;                              "org-elpa"
;;                              "melpa"
;;                              "gnu-elpa-mirror"
;;                              "el-get"
;;                              "emacsmirror-mirror"
;;                              ))))))

(define (emacs-ps)
  (map (lambda (x)
         (string-append "emacs-" x))
       (doom-ps)))

;; (display
;;  (map (lambda (x)
;;         (find-best-packages-by-name x #f))
;;       (emacs-ps)))

;; (display
;;  (->> (emacs-ps)
;;       (map (lambda (x)
;;              (let ((found (find-best-packages-by-name x #f)))
;;                (if (null? found)
;;                  x '()))))
;;       (remove null?)))

(use-modules (gnu packages emacs-xyz)
             (ebullient home emacs-xyz)
             ;; (ebullient home emacs-xyz-batch)
             )

(define (str->pkg x)
  (primitive-eval
   (string->symbol
    (if (equal? "emacs-git-modes" x)
        "git-modes"
        x))))

;; (let ((the-manifest
;;        (packages->manifest
;;         (map str->pkg (emacs-ps)))))
;;   ;; (display the-manifest)
;;   #f)






(use-modules ((guix base32) #:select (bytevector->nix-base32-string))
             ((guix build git) #:select (git-fetch) #:prefix other:)
             (guix build utils)
             ((guix hash) #:select (file-hash*)))

(define* (git-checkout-hash url commit #:key recursive?)
  (let ((dir (string-append "/tmp" "/8888")))
    (when (file-exists? dir)
      (delete-file-recursively dir))
    (if (other:git-fetch url commit dir
                         #:recursive? recursive?
                         ;; #:git-command (string-append #+git "/bin/git")
                         )
        (let ((hash (bytevector->nix-base32-string (file-hash* dir))))
          (delete-file-recursively dir)
          hash)
        #f)))


(define (test-get-hash)
  (display
   (git-checkout-hash
    "https://github.com/emacs-evil/evil-surround"
    "282a975bda83310d20a2c536ac3cf95d2bf188a5"
    #:recursive? #t)))

;; (test-get-hash)


(define* (find-hash doom-pkg p commit #:key recursive?)
  (let ((hasher (lambda (url)
                  (git-checkout-hash url commit #:recursive? recursive?))))
    (as-> hasher $
          ($ (if (eq? (-> p package-source origin-method) git-fetch)
                 (-> p
                     package-source
                     origin-uri
                     git-reference-url)
                 (string-append "https://github.com/emacs-straight/" doom-pkg)))
          (if $ $ "NONE_FOUND"))))

;; TODO later: maybe don't look for hashes if the requested commit is already in the Guix package
;; - and maybe if the hashes turn out to be the same after doing `git-checkout-hash', presumably
;; because the Guix package had a git tag or something but it ended up being the same as the
;; Doom-requested commit, don't save the hash? Meh.
;; TODO maybe don't write out the hashes file
;; Just cache the results somehow in the guix store so hash generation can be run as-needed
(define (hashes ps)
  (let ((commits (call-with-input-file "../doom-packaging/straight-commits.txt" read)))
    (map
     (lambda (doom-pkg)
       (let* ((p (str->pkg (string-append "emacs-" doom-pkg)))
              (commit (assoc-ref commits doom-pkg))
              (hash (find-hash doom-pkg p commit #:recursive? #t)))
         (kvm #:package doom-pkg
              #:commit commit
              #:hash hash)))
     ps)))

(define (spit f content)
  (call-with-output-file f
    (lambda (port)
      (write content port))))

;; (define write-hashes (partial spit "../doom-packaging/hashes.txt"))

;; (write-hashes
;;  (hashes (list "restart-emacs" "smartparens")))
;; (write-hashes (doom-ps))
#+end_src
******** third attempt
********* clojure part
********** clj file
#+begin_src clojure :tangle ebullient/src/protostar/hickeyland.clj :comments link
(ns protostar.hickeyland
  (:require [clojure.alpha.spec :as s]
            [clojure.edn :as edn]
            [clojure.java.io :as io]
            [clojure.string :as str]))

;; TODO At end: just maybe try doing this, slurp, any anything else impure as some sort of "coeffects"
(defn- file-exists? [f]
  (.exists (io/file f)))


(s/defop nospec [_]
  any?)



(s/def ::str->edn (s/conformer edn/read-string)) ; TODO donno if I want to use this or just do it in clojure code (is that more idiomatic then writing a spec/conformer for everything?)


(s/def :char/blank #{\space \tab})
;; (s/def :char/newline #{\newline}) ; TODO remvoe if not needed

(s/def ::text->lines (s/conformer str/split-lines)) ; TODO donno if I want to use this or just do it in clojure code (is that more idiomatic then writing a spec/conformer for everything?)

(s/def ::str->chars (s/conformer seq))
(s/def ::chars->str (s/conformer (partial apply str)))



;; TODO would this be better / more flexible if I made it check validity (`valid?`) and then did conforming in a separate step?
;; TODO s/defop works currently but might not be the idiomatic way to do this
(s/defop s-filter [spec]
  (s/conformer
   (fn [xs]
     (keep (fn [x]
             (let [conformed (s/conform spec x)]
               (when-not (s/invalid? conformed)
                 conformed)))
           xs))))


(s/def :elisp/form any?)
(s/def :elisp/t #{t})
(s/def :elisp/list->car (s/conformer first)) ; TODO remove if not needed
(s/def :elisp/list->cdr (s/conformer next)) ; TODO remove if not needed
(s/def :elisp/plist->map (s/conformer (partial apply hash-map))) ; TODO remove if not needed
(s/def :elisp/nil-or-non-nil :elisp/form) ; TODO think this (perhaps just the name) through more?


(s/def :epkg.dep/name symbol?)
(s/def :epkg.dep/version (nospec string?))
(s/def :epkg.dep/name+ver (s/cat :name :epkg.dep/name
                                 :_version (s/? (nospec :epkg.dep/version))))
(s/def :epkg.dep/name+ver->name
  (s/conformer (fn [[form x]]
                 (case form
                   :name x
                   :name+ver (:name x)))))
(s/def :epkg/dep (s/or :name :epkg.dep/name
                       :name+ver :epkg.dep/name+ver))

(s/def :epkg/deps (s/coll-of :epkg/dep))
(s/def :epkg/deps->name-strs
  (s/coll-of (s/and
              :epkg.dep/name+ver->name
              (s/conformer str))))

;; Testing
;; (def test-deps '((emacs "24.1") another (seq) (cl-lib "0.5")))
;; (s/valid? :epkg/deps test-deps)
;; (s/explain-str :epkg/deps test-deps)
;; (s/conform :epkg/deps test-deps)
;; (s/conform
;;  (s/and
;;   :epkg/deps
;;   :epkg/deps->name-strs)
;;  test-deps)

;; TODO ideally do this better / more flexibly / maybe faster
(s/def :epkg.simple/req-header-name
  (s/&
   (s/+ char?)
   ::chars->str
   #(= "Package-Requires:" %))) ; TODO (if keeping things this way) could this just be a literal set predicate?

(s/def :epkg.simple/req-header-line
  (s/and
   ::str->chars
   (s/cat :_comment (s/&
                     (s/+ #{\;})
                     ::chars->str)
          :_ws (s/&
                (s/* :char/blank)
                ::chars->str)
          :_req-header :epkg.simple/req-header
          :_ws2 (s/&
                 (s/* :char/blank)
                 ::chars->str)
          :deps (s/&
                 (s/* char?)
                 ::chars->str
                 ::str->edn
                 :epkg/deps))))

(s/def :epkg.simple/reqs
  (s/and
   ::text->lines
   (s-filter :epkg.simple/req-header-line)
   ;; TODO spec that there should be exactly :count 1?
   (s/conformer first)
   ;; TODO what was I trying here?
   ;; (s/conformer (fn [xs]
   ;;                (or (first xs) :clojure.alpha.spec/invalid)))
   ))

;; Testing
;; (def test-pkgrequires-line ";; Package-Requires: ((emacs \"24.1\") (cl-lib \"0.5\"))")
;; (s/conform :epkg.simple/reqs (str "asdf\n" test-pkgrequires-line))
;; (s/explain-str :epkg.simple/reqs test-pkgrequires-line)

(s/def :epkg.multifile/reqs
  (s/cat :_define-package #{define-package}
         :_name (nospec string?)
         :_version (nospec :epkg.dep/version)
         :_docstring (s/? (nospec string?))
         :requirements (s/? (s/cat
                             :quote #(= (symbol (str \')) %) ; "Artifact" of `edn/read-string`.
                             :form :epkg/deps))
         :_extra (s/* (nospec nil))))

;; Testing
;; (s/conform :epkg.multifile/reqs {:pname "magit" :dir "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/magit/lisp"})
;; (s/conform :epkg.multifile/reqs (edn/read-string (slurp "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/magit/lisp/magit-pkg.el")))
;; (s/explain-str :epkg.multifile/reqs (edn/read-string (slurp "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/magit/lisp/magit-pkg.el")))
;; (s/conform :epkg.multifile/reqs "asdf")
;; (s/conform :epkg.multifile/reqs (edn/read-string (slurp "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/drag-stuff.el/drag-stuff-pkg.el")))

;; TODO Might not need to test if file-exists for simple packages, is there always a packagename.el file? Or should always be one if there's no -pkg.el so its find to have it as a fallthrough case?
;; TODO maybe do coeffects if it's easy
;; Maybe see my now-deleted cofx attempts
(s/def :epkg/reqs->deps
  (s/or :multifile
        (s/and
         (s/conformer
          (fn [{:keys [pname dir]}]
            (let [f (str dir "/" pname "-pkg.el")]
              (if (file-exists? f)
                (-> f slurp edn/read-string)
                :clojure.alpha.spec/invalid))))
         :epkg.multifile/reqs
         (s/conformer #(get-in % [:requirements :form])))
        :simple
        (s/and
         (s/conformer
          (fn [{:keys [pname dir]}]
            (let [f (str dir "/" pname ".el")]
              (if (file-exists? f)
                (-> f slurp edn/read-string)
                :clojure.alpha.spec/invalid))))
         :epkg.simple/reqs
         (s/conformer :deps))))

(defn epkg-dependencies [name dir]
  (let [deps
        (s/conform
         (s/and
          :epkg/reqs->deps
          (s/conformer (fn [[_ reqs]] reqs))
          :epkg/deps->name-strs)
         {:pname name :dir dir})]
    (when-not (s/invalid? deps)
      deps)))

;; Testing
;; (epkg-dependencies "magit" "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/magit/lisp")
;; (println (epkg-dependencies "dash" "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/dash"))
;; (println (epkg-dependencies "helpful" "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/helpful"))
;; (println (epkg-dependencies "evil" "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/evil"))
;; (println (epkg-dependencies "drag-stuff" "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/drag-stuff.el"))
;; (println (slurp "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/evil/evil-pkg.el"))




(s/def ::forge-repo
  (s/and
   ::str->chars
   (s/cat :user-name (s/&
                      (s/+ char?)
                      ::chars->str)
          :slash #{\/}
          :repo-name (s/&
                      (s/+ char?)
                      ::chars->str))))

(s/def ::glob string?)

(s/def ::recipe-subdirective
  (s/alt :subdir string?
         :exclude #{:exclude}))

(s/def ::recipe-defaults #{:defaults})




; TODO better sha and ref specs
(s/def :git/sha string?)
(s/def :git/ref string?)

(s/def :melpa.recipe.files/element
  (s/alt :glob ::glob
         :sublist (s/nest
                   (s/cat :subdirective ::recipe-subdirective
                          :elements (s/+ :melpa.recipe.files/element)))))
(s/def :melpa.recipe/files
  (s/cat
   :defaults (s/? ::recipe-defaults)
   :elements (s/* :melpa.recipe.files/element)))

(s/def :melpa.recipe/name symbol?)
(s/def :melpa.recipe/fetcher #{git hg github gitlab})
(s/def :melpa.recipe.vc/url string?)
(s/def :melpa.recipe.forge/repo ::forge-repo)
;; TODO nb: "commit" is used only once in all of the melpa recipes. Do doom/straight even consider it?
(s/def :melpa.recipe.git/commit (s/or :git/sha
                                      :git/ref))
(s/def :melpa.recipe.git/branch string?) ; TODO do better spec? It can be a git or hg branch, right?
;; -- originial position of :melpa.recipe/files before I moved it up --
;; TODO nb: ignoring :version-regexp and :old-names, I don't care about them, right (straight doesn't seem to)? And I'm excluding from even this validation spec stuff I don't care about, right? Or just maybe spec them but do a `s/select` that doesn't include them (or use `nospec`)? Remember to add them to :melpa.recipe/schema.

(s/def :melpa.recipe/props
  (s/schema {;; :melpa.recipe/name
             :fetcher :melpa.recipe/fetcher
             :files :melpa.recipe/files}))

(s/def :melpa.recipe/vc-props
  (s/schema {:url :melpa.recipe.vc/url}))

(s/def :melpa.recipe/forge-props
  (s/schema {:repo :melpa.recipe.forge/repo}))

(s/def :melpa.recipe/git-props
  (s/schema {:commit :melpa.recipe.git/commit
             :branch :melpa.recipe.git/branch}))

(defmulti melpa-recipe-fetcher :fetcher)

(defmethod melpa-recipe-fetcher 'git [_]
  (s/select
   (s/union :melpa.recipe/props
            :melpa.recipe/vc-props
            :melpa.recipe/git-props)
   [:url]))
(defmethod melpa-recipe-fetcher 'hg [_]
  (s/select
   (s/union :melpa.recipe/props
            :melpa.recipe/vc-props)
   [:url]))
(defmethod melpa-recipe-fetcher 'github [_]
  (s/select
   (s/union :melpa.recipe/props
            :melpa.recipe/forge-props
            :melpa.recipe/git-props)
   [:repo]))
(defmethod melpa-recipe-fetcher 'gitlab [_]
  (s/select
   (s/union :melpa.recipe/props
            :melpa.recipe/forge-props
            :melpa.recipe/git-props)
   [:repo]))

(s/def :melpa/recipe
  (s/cat
   :name (nospec :melpa.recipe/name)
   :props
   (s/&
    (s/* :elisp/form)
    #(even? (count %))
    :elisp/plist->map
    (s/multi-spec melpa-recipe-fetcher :fetcher))))

;; Testing
;; (def test-melpa-recipe '(yasnippet :repo "joaotavora/yasnippet"
;;                                    :fetcher github
;;                                    :files ("yasnippet.el" "snippets")))
;; (s/conform :melpa/recipe test-melpa-recipe)
;; (s/explain-str :melpa/recipe test-melpa-recipe)



(s/def :straight.recipe-repo/name symbol?)

(s/def :straight.recipe/name symbol?) ; Maybe spec this so I can accept the argument to `straight-use-package` (for other users who use straight): doom doesn't take this just the rest of the recipe plist. Update: also need it for :includes.
(s/def :straight.recipe/local-repo string?)
;; TODO maybe some of the sub-stuff in :straight.recipe/files should be `nospec` or have leading keywork underscores.
(s/def :straight.recipe/files
  (s/*
   (s/alt :glob ::glob
          :pair (s/cat :car string?
                       :dot #{.}
                       :cdr string?)
          :sublist (s/nest
                    (s/cat :subdirective ::recipe-subdirective
                           :elements (s/+ :straight.recipe/files)))
          :defaults ::recipe-defaults)))
(s/def :straight.recipe/flavor #{melpa})
(s/def :straight.recipe/build any?) ; TODO. Had #{nil t}, it would be better to use :elisp/t but set specs take literal, not spec, values
(s/def :straight.recipe/pre-build any?) ; TODO
(s/def :straight.recipe/post-build any?) ; TODO
(s/def :straight.recipe/type #{git built-in})
(s/def :straight.recipe/source (s/or :one :straight.recipe-repo/name
                                     :many (s/coll-of :straight.recipe-repo/name)))
(s/def :straight.recipe/includes (s/or :one :straight.recipe/name
                                       :many (s/coll-of :straight.recipe/name)))
(s/def :straight.recipe/inherit :elisp/nil-or-non-nil)
(s/def :straight.recipe.git/host #{nil github gitlab bitbucket})
(s/def :straight.recipe.git/branch string?)
(s/def :straight.recipe.git/remote string?)
(s/def :straight.recipe.git/nonrecursive :elisp/nil-or-non-nil)
(s/def :straight.recipe.git/fork any?) ; TODO
(s/def :straight.recipe.git/depth (s/or :full #{full}
                                        :n integer?))
(s/def :straight.recipe.git/protocol #{https ssh})
(s/def :straight.recipe.git/upstream any?) ; TODO


(s/def :straight.recipe/props
  (s/schema {;; :straight.recipe/name
             :local-repo :straight.recipe/local-repo
             :files :straight.recipe/files
             :flavor :straight.recipe/flavor
             :build :straight.recipe/build
             :pre-build :straight.recipe/pre-build
             :post-build :straight.recipe/post-build
             :type :straight.recipe/type
             :source :straight.recipe/source
             :includes :straight.recipe/includes
             :inherit :straight.recipe/inherit}))

(s/def :straight.recipe/git-props
  (s/schema {;; :repo :straight.recipe.git/repo
             :host :straight.recipe.git/host
             :branch :straight.recipe.git/branch
             :remote :straight.recipe.git/remote
             :nonrecursive :straight.recipe.git/nonrecursive
             :fork :straight.recipe.git/fork
             :depth :straight.recipe.git/depth
             :protocol :straight.recipe.git/protocol
             :upstream :straight.recipe.git/upstream}))


(s/def :straight/repository-url string?)

(defmulti straight-recipe-git-host :host)

(defmethod straight-recipe-git-host nil [_]
  (s/select {:repo :straight/repository-url} [:repo]))
(defmethod straight-recipe-git-host 'github [_]
  (s/select {:repo ::forge-repo} [:repo]))
(defmethod straight-recipe-git-host 'gitlab [_]
  (s/select {:repo ::forge-repo} [:repo]))
(defmethod straight-recipe-git-host 'bitbucket [_]
  (s/select {:repo ::forge-repo} [:repo]))


(def straight-default-vc 'git)

(defmulti straight-recipe-type #(get % :type straight-default-vc))

(defmethod straight-recipe-type 'git [_]
  (s/and
   (s/union :straight.recipe/props
            :straight.recipe/git-props)
   (s/multi-spec straight-recipe-git-host :host)))
(defmethod straight-recipe-type 'built-in [_]
  (s/schema {}))


(s/def :straight.recipe/props-asdf
  (s/&
   (s/* :elisp/form)
   #(even? (count %))
   :elisp/plist->map
   (s/multi-spec straight-recipe-type :type)))

;; TODO I don't think I need this for anything
(s/def :straight/recipe
  (s/cat
   :name (nospec :straight.recipe/name)
   :props :straight.recipe/props-asdf))


(s/def :doom.package/name symbol?)
(s/def :doom.package/type #{core local built-in virtual}) ; Depending on where I'm doing "checking for stuff I explicitly don't support" either remove local/built-in/(maybe)virtual here or check for them elsewhere
(s/def :doom.package/recipe :straight.recipe/props-asdf)
(s/def :doom.package/disable :elisp/t)
(s/def :doom.package/ignore :elisp/t)
(s/def :doom.package/pin :git/sha)
;; TODO nb: not speccing :modules (for now?)

(s/def :doom.package/props
  (s/schema {:type :doom.package/type
             :recipe :doom.package/recipe
             :disable :doom.package/disable
             :ignore :doom.package/ignore
             :pin :doom.package/pin}))

(s/def :doom/package
  (s/cat
   :name :doom.package/name
   :props
   (s/&
    (s/* :elisp/form)
    #(even? (count %))
    :elisp/plist->map
    :doom.package/props)))


#_(defn parse-doom-packages []
  (as-> (slurp "/home/pharcosyle/projects/phrenetic/doom-packaging/my-doom-packages.el") $
    (edn/read-string $)
    (map parse-doom-package $)
    ;; TODO later: this is Doom-specific, move it out of the main "guix-emacs-generator"
    (remove #(= (:package/name %) "straight") $)
    (remove :package/deactivated? $)))



(s/def ::todo any?)

;; (s/def :fex.repo/user-name ::todo)
;; (s/def :fex.repo/repo-name ::todo)
;; (s/def :fex/repo
;;   (s/schema [:fex.repo/user-name
;;              :fex.repo/repo-name]))

(s/def :fex.package/url ::todo)
;; (s/def :fex.package/forge #{:forge/github
;;                             :forge/gitlab
;;                             ;; :forge/bitbucket
;;                             })
;; (s/def :fex.package.forge/repo :fex/repo) ; TODO maybe just use :fex/repo or ::forge-repo (and make the current ::forge-repo be ::forge-repo-str or something)
(s/def :fex.package/branch ::todo)
(s/def :fex.package/nonrecursive? #{true})
(s/def :fex.package/files :melpa.recipe/files) ; TODO This is "inheritance", maybe make this a "shared" spec like ::recipe-defaults or just allow :melpa.recipe/files as a key in :fex/package (maybe even rename it to ::melpa-style-files or something)

(s/def :fex/package
  (s/schema [:fex.package/url
             ;; :fex.package/forge
             ;; :fex.package.forge/repo
             :fex.package/branch
             :fex.package/nonrecursive?
             :fex.package/files]))





(def ^:private forge-domains
  {'github "github.com"
   'gitlab "gitlab.com"
   'bitbucket "bitbucket.com"})

(defn forge-repo-url [forge user-name repo-name]
  (str "https://" (get forge-domains forge) "/" user-name "/" repo-name ".git"))


(require '[clojure.set :refer [rename-keys]])
(defn select-and-rename-keys [m kmap]
  (as-> m $
    (select-keys $ (keys kmap))
    (rename-keys $ kmap)))






(defmacro defkmultis [& methods]
  (let [create (fn [name]
                 `(defmulti ~name ~(fn [k & _] k)))]
    `(do
       ~@(map create methods))))

(defmacro defkmethods [k & methods]
  (let [register
        (fn [[name argslist & body]]
          `(defmethod ~name ~k ~(vec (cons '_ argslist)) ~@body))]
    `(do
       ~@(map register methods))))





;; Archives
(defkmultis
  ;; has-recipe
  get-recipe) ; TODO maybe rename this get-package or something, I'm returning fex packages, not straight/melpa recipes


(defn gnu-elpa-mirror-recipe-filename [p]
  (str "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/gnu-elpa-mirror" "/" p))

(defkmethods
  :archive/gnu-elpa-mirror
  (get-recipe [p] (let [f (gnu-elpa-mirror-recipe-filename p)]
                    ;; TODO straight checks against straight-recipes-gnu-elpa-ignored-packages for this archive, I might need to do that too. There are other notes on this already.
                    (when (file-exists? f)
                      {:fex.package/url (forge-repo-url
                                         (symbol :github) "emacs-straight" p)
                       :fex.package/files {:elements [[:glob "*"]]}})))) ; TODO straight also has ~(:exclude ".git")~ here but I don't think I need that.

(defn melpa-recipe-filename [p]
  (str "/home/pharcosyle/.local/var/lib/doom-local/straight/repos/melpa/recipes" "/" p))

(defkmethods
  :archive/melpa
  ;; (has-recipe [p] (file-exists? (melpa-recipe-filename p)))
  (get-recipe [p] (let [f (melpa-recipe-filename p)]
                    (when (file-exists? f)
                      (let [text (slurp f)
                            parsed
                            (s/conform (s/and
                                        ::str->edn
                                        :melpa/recipe
                                        (s/conformer :props))
                                       text)]
                        ;; TODO check that `parsed` is not invalid?
                        ;; TODO "supported"-ness: this might be the place to check that the melpa recipe fetcher isn't 'hg. Alternatively, or perhaps preferably (it would match straight's behavior) just report there's no package if the fetcher is 'hg (or isn't 'git, 'github, or 'gitlab)
                        ;; TODO additional things straight does for this archive: adds -pkg.el to :files and sets flavor to melpa. Donno if I need these. There are other todos/notes on these already
                        (merge
                         {:fex.package/url (let [fetcher (:fetcher parsed)]
                                             (condp some #{fetcher}
                                               #{'git} (:url parsed)
                                               #{'github 'gitlab} (let [repo (:repo parsed)]
                                                                    (forge-repo-url
                                                                     fetcher
                                                                     (:user-name repo)
                                                                     (:repo-name repo)))))}
                         (select-and-rename-keys
                          parsed {:branch :fex.package/branch
                                  :files :fex.package/files})
                         ;; TODO not using, remove
                         ;; (when-let [files (:files parsed)]
                         ;;   {:fex.package/files (s/unform :melpa.recipe/files files)})
                         ))))))

;; Testing
;; (get-recipe :archive/melpa "yasnippet")

;; TODO I don't think the lisp/* bits are necessary since these already have :defaults but for now I've copied the :files over just like they are in straight.
(defkmethods
  :archive/org-elpa
  (get-recipe [p] (case p
                    "org"
                    {:fex.package/url "https://git.savannah.gnu.org/git/emacs/org-mode.git"
                     :fex.package/files {:defaults :defaults
                                         :elements [[:glob "lisp/*.el"]
                                                    [:sublist
                                                     {:subdirective [:subdir "etc/styles/"]
                                                      :elements [[:glob "etc/styles/*"]]}]]}}
                    "org-contrib"
                    {:fex.package/url "https://git.sr.ht/~bzg/org-contrib"
                     :fex.package/files {:defaults :defaults
                                         :elements [[:glob "lisp/*.el"]]}}
                    nil)))


;; TODO make this configurable (of course) and probably not global (pass it as an argument to functions that use it)
(def archives [:archive/org-elpa
               :archive/melpa
               :archive/gnu-elpa-mirror])

;; TODO probably add emacsmirror, etc archives but make all of the methods throw an exception stating that they're not implemented "yet".
;; (def archive-priority [:archive/org-elpa
;;                        :archive/melpa
;;                        :archive/gnu-elpa-mirror])

;; TODO maybe a way to get these from Doom programatically is to advise `straight-use-recipes` but then I'd have to run `doom--ensure-straight` as well
;; (def doom-recipe-repos
;;   '((org-elpa :local-repo nil)
;;     (melpa              :type git :host github
;;                         :repo "melpa/melpa"
;;                         :build nil)
;;     (gnu-elpa-mirror    :type git :host github
;;                         :repo "emacs-straight/gnu-elpa-mirror"
;;                         :build nil)
;;     (el-get             :type git :host github
;;                         :repo "dimitri/el-get"
;;                         :build nil)
;;     (emacsmirror-mirror :type git :host github
;;                         :repo "emacs-straight/emacsmirror-mirror"
;;                         :build nil)))
;; (def doom-straight-recipe-repositories
;;   '(org-elpa melpa gnu-elpa-mirror el-get emacsmirror-mirror))




(require '[clojure.java.shell :refer [sh]])
(def eb-dir "/home/pharcosyle/projects/phrenetic/ebullient")
(def guix-repl-cmd ["guix" "repl" "-L" "." "--" "ebullient/home/packaging-runner.scm"])
(defn sh-call [f & args]
  (apply sh (concat guix-repl-cmd
                    [(name f)]
                    (map pr-str args)
                    [:dir eb-dir])))
;; (sh-call :guix/asdf 6)
(def get-origin-data (partial sh-call :guix/get-origin-data))







(defn get-archive-package [archives package-name]
  (first (map #(get-recipe % package-name) archives)))

(defn package-with-inheritance [package-name package]
  (merge
   (get-archive-package package-name)
   package))






(defn convert-straight-recipe-props-to-package [props]
  (let [; parsed (s/conform :straight.recipe/props-asdf props)
        parsed props]
    ;; TODO check that `parsed` is not invalid?
    ;; TODO "supported"-ness: is this the place to check that there aren't unsupported keys and provided keys have supported values (including that the :files is a valid /melpa/ :files)?
    (merge
     {:fex.package/url
      (let [{:keys [host repo]} parsed]
        (if host
          (forge-repo-url
           host
           (:user-name repo)
           (:repo-name repo))
          repo))}
     (select-and-rename-keys
      parsed {:branch :fex.package/branch})
     (when (:nonrecursive parsed)
       {:fex.package/nonrecursive? true})
     (when-let [files (:files parsed)]
       ;; TODO donno why I want to do it this convoluted way, maybe because I don't want to use the "raw" props?
       {:fex.package/files
        ;; (s/conform :melpa.recipe/files props)
        (->> files
             (s/unform :straight.recipe/files)
             (s/conform :melpa.recipe/files))}))))




;; (def my-doom-packages-test "/home/pharcosyle/projects/phrenetic/doom-packaging/my-doom-packages.el")
;; (def my-doom-packages-test "/home/pharcosyle/projects/phrenetic/doom-packaging/my-doom-packages-edited.el")
(def my-doom-packages-test "/home/pharcosyle/projects/phrenetic/doom-packaging/my-doom-packages-small.el")

(defn test-packages []
  (let [data (-> my-doom-packages-test
                 slurp
                 edn/read-string)
        conformed (s/conform (s/coll-of :doom/package) data)]
    ;; (s/explain (s/coll-of :doom/package) data)
    (as-> conformed $
      (map #(get-in % [:props :recipe]) $)
      (map convert-straight-recipe-props-to-package $))))

;; (test-packages)





(def straight-allow-recipe-inheritance? true)

;; TODO Ideally I think I want to grab any pertinent straight settings from Doom Emacs
;; By serializing them "in the same run" as when I grab e.g `doom-packages`. Update: but wait I won't have straight installed when I do this, perhaps scrape the straight code for sexps or maybe it'll be enough to just get the ones that Doom sets itself (see core-packages.el line 78-97)
;; - default protocol, allow inheritance, the recipe repos Doom sets up, etc
;; - straight-default-vc
;; - look through straight's ~defcustom~s
(def defaults {:recipe/protocol "https"})
;; maybe?:
;; :files '("*.el" "*.el.in" "dir"
;;          "*.info" "*.texi" "*.texinfo"
;;          "doc/dir" "doc/*.info" "doc/*.texi" "doc/*.texinfo" "lisp/*.el"
;;          (:exclude ".dir-locals.el" "test.el" "tests.el" "*-test.el" "*-tests.el")

;; TODO regarding :flavor: read `straight-expand-files-directive' and see if I need this / what I should do about :files. Also read the melpa readme about the rules it has for expanding its :files property
;; - :melpa/recipe shouldn't have a flavor, right? Just straight recipes?
;; - new thoughts
;;   - I might need it to make sure template files are copied over "before build", does that make sense I can't be fucked to think through the ordering at present
;;   - If I do need to consider .el.in files perhaps I can prepreocess the :fex.package/files returned from the melpa archive (but that might not be feasable, the .el.in logic is deep in the melpa/straight files expansion logic)
;;   - The Guix elpa importer doesn't even consider .el.in files, maybe they're super rare
;;   - nb: straight recipe inheritance logic includes :flavor and I'm not presently doing that
;;   - reconcile the Guix elpa importer's file expansion logc with melpa's to make sure it's thorough (not straight's, it's different, but do look it over afterwards anyway)
;; TODO downloading to a cache like the elpa importer does would speed up successive/reattempted runs, no?
;; - assuming that is what it's doing (check). Do those repo caches stick around forever though? Will adding my own interfere with anything?
;; - if it's /really/ fast maybe I could get rid of the later-to-come bump "scripts"'s need to read an existing list of generated packges at all! I wouldn't even have to save it to disk, just the lockfile!
;;   - even if the guix git repositories cache thing is untenable maybe there's some other cache I could write the repos or the generated packages-with-hashes to, even just ~./cache. I'd like to not have to manage a generated packages file if I don't have to
;; TODO handle :host: search "bitbucket" in straight to see stuff that affects hosts. If necessary add a check to make sure a supported host is provided.
;; TODO use value of `straight-built-in-pseudo-packages' (let-alist emacs nadvice python) in addition to elpa.scm's `emacs-standard-library?'? What about `straight-recipes-gnu-elpa-ignored-packages'? What about straight--package-built-in-p and package--builtins (read its doc)?
;; - Straight claims to be able to "deal with built-in packages" even without this variable. How? Something like hlissner does when :built-in is set to 'prefer? Use one
;;   of these approaches instead of making a (brittle) list of built-in pseudo packages?
;; - Remember, sometimes even if a package is built-in it should still be installed (like org)
;; - unrelated: are there any built-in dependencies with newer upstream/external versions? Do I want them?
;;   Perhaps not even proper versions just newer commits in a git repo
;; TODO always include *pkg.el like straight.el::3168 says?
;; Is that just about making sure that dependencies get resolved? It says "linked over" though. But then why wouldn't the other `straight-recipes-REPO-retrieve' methods have it? For
;; the elpa one at least it could be because it includes everything (=:files "*"=)
;; - also see the github melpa readme: "For multi-file packages, the file <NAME>-pkg.el is automatically generated..."
;; - update: shit is the /built/ package (after the :files directive has been "applied", among other things) used for determining dependencies? That's the way straight does it, I was just going to use the "raw" cloned repo to find dependencies. Note that e.g. ghub, magit-secion have their -pkg.el files in a subfolder so assuming -pkg.el lives in the root of the unbuilt repo isn't going to work the way I have it now. Conceivably the same could be true of a regular packagename.el file: it could be in a subdirectory.
;;   - I'll probably have to build the package before I get dependencies like straight does. Is there anything else about building the package, besides doing the :files copying/linking, that could affect the packagename.el and packagename-pkg.el files and thus dependency resolution?
;; TODO do I actually need :includes / consider the org-elpa pseudo repository (look at straight-recipes-org-elpa-retrieve in particular)
;; I think the Doom package declarations of org/org-contrib are inheriting from org-elpa and all that stuff it does with :includes and maybe other stuff /does/ matter?
;; - how does Guix handle org? One package, multiple?
;; TODO consider `straight--convert-recipe'
;; TODO consider straight-built-in-pseudo-packages
;; esp. in straight--convert-recipe
;; TODO consider how straight.el recipe inheritance works
;; esp. in straight--convert-recipe

;; TODO hack
;; Wait to do this until the end when I have a concrete idea of all the stuff I'll have to read (doom packages, melpa recipes...) and how I want to do it.
;; Ideas:
;; - hack scm/edn.scm somehow?
;; - convert `doom-packages` (and melpa recipes) package names to strings on the elisp side
;;   Would be messy with melpa recipes since there's no "elisp-reading phase"
;; - elisp "parseclj"/"parseedn" are nice but they don't solve the 0x0 problem
;;   Are they worth the additional overhead of running them on the elisp side? Again, with melpa there might not /be/ an elisp side
;;   - nice to have but maybe not necessary: handling dotted pairs, t/nil become true/nil
;; - don't use the 0x0 package
(defn icky [x]
  (if (= x "0")
    "0x0" x))

;; TODO probably do this with spec, but wait until a bit later / the end
;; (if-let [unsupported (seq (filter (fn [p]
;;                                       (or (let [type (get p :doom.package/type)]
;;                                             (some (hash-set type) (vector :doom.package.type/local :doom.package.type/built-in)))
;;                                           (let [vc (get-in p (vector :package/recipe :recipe/vc))]
;;                                             (and vc (not= vc :vc/git)))
;;                                           (get-in p (vector :package/recipe :straight.recipe/protocol))
;;                                           (get-in p (vector :package/recipe :straight.recipe/source))
;;                                           (get-in p (vector :package/recipe :straight.recipe/fork))
;;                                           (get-in p (vector :package/recipe :straight.recipe/upstream))
;;                                           (get-in p (vector :package/recipe :straight.recipe/includes))))
;;                                   $))]
;;         (throw (ex-info "Package(s) with unsupported configuration" {:packages unsupported}))
;;         $)
;; TODO NEW stuff I've decided I'm /definitely/ not supporting: fork, source
;; - don't support :build. (At leat for values other than 't, which is harmless and which Doom's org package declaration uses. Maybe just override the Doom org package like I'm going to do for its :pre-build)
;; - don't support :pre-build/:post-build (Doom's org and notmuch packages use :pre-build though, so find probably override those recipes to not have :pre-build steps and make sure the Guix packages for them do what the :pre-build steps would have done).
;; - probably not supporting manually-set inherit property (and straight-allow-recipe-inheritance must be true)
;; - list of straight package props Doom actually uses
;;   host
;;   repo
;;   files
;;   nonrecursive
;;   branch
;;   local-repo
;;   - Only straight has this and it doesn't matter for me
;;   build
;;   - only org (:build t)
;;   pre-build
;;   - only org and notmuch
;;   depth
;;   - only org (:depth 1)
;; - spec that both host and repo must be specified so in inheritance one isn't overridden without the other?
#+end_src
********** deps
#+begin_src clojure :tangle ebullient/deps.edn :comments link
{:paths ["src" "resources"]
 :deps {org.clojure/clojure {:mvn/version "1.11.1"}
        org.clojure/alpha.spec {:git/url "https://github.com/clojure/spec-alpha2.git"
                                :sha "99456b1856a6fd934e2c30b17920bd790dd81775"}
        babashka/fs {:mvn/version "0.1.6"}}
 :aliases
 {:run-m {:main-opts ["-m" "protostar.hickeyland"]}
  :run-x {:ns-default protostar.hickeyland
          :exec-fn greet
          :exec-args {:name "Clojure"}}
  :build {:deps {io.github.seancorfield/build-clj
                 {:git/tag "v0.6.3" :git/sha "9b8e09b"
                  ;; since we're building an app uberjar, we do not
                  ;; need deps-deploy for clojars.org deployment:
                  :deps/root "slim"}}
          :ns-default build}
  :test {:extra-paths ["test"]
         :extra-deps {org.clojure/test.check {:mvn/version "1.1.1"}
                      io.github.cognitect-labs/test-runner
                      {:git/tag "v0.5.0" :git/sha "48c3c67"}}}}}
#+end_src
********* guix part
#+begin_src clojure :tangle ebullient/lokke/ns/ebullient/home/packaging-wip.clj :comments link
(ns ebullient.home.packaging-wip
  (:require [guile :refer [command-line]]
            [guile.guix.base32 :refer [bytevector->nix-base32-string]]
            [guile.guix.git :refer [latest-repository-commit]]
            [guile.guix.hash :refer [file-hash*]]
            [guile.guix.store :refer [with-store]]
            [guile.srfi.srfi-11 :as srfi-11]

            [guile.guix.build-system.emacs :refer [emacs-build-system]]
            [guile.guix.git-download :refer [git-fetch git-reference git-file-name]]
            [guile.guix.packages :refer [package origin content-hash]]))

(defn- pair [a b]
  (guile/cons a b))

(defmacro let-values [bindings & body]
  (let [bindings*
        (->> bindings
             (partition 2)
             (map (fn [[names expr]]
                    (list
                     (apply list names) expr))))]
    `(srfi-11/let-values ~bindings*
       ~@body)))

(defn- download-git-repo! [url [ref' ref''] recursive?]
  (let-values
   [[dir commit]
    (with-store store
      (latest-repository-commit store url
                                :ref (pair (symbol ref') ref'')
                                :recursive? recursive?))]
   {:dir dir :commit commit}))

;; (println
;;  (download-git-repo! "https://github.com/raxod502/straight.el.git" [:branch "develop"] false))
;; (println
;;  (download-git-repo! "https://github.com/minad/consult.git" '()))

(defn get-origin-data [url ref recursive?]
  (let [{:keys [dir commit]} (download-git-repo! url ref recursive?)]
   {:commit commit
    :hash (bytevector->nix-base32-string
           (file-hash* dir))}))

;; (println
;;  (get-origin-data "https://github.com/raxod502/straight.el.git" [:branch "develop"] false))





(defn fex-package [package-name url commit recursive? hash]
  (package
   (name (str "emacs-" package-name))
   (version "0.0.1")
   (source
    (origin
     (method git-fetch)
     (uri (git-reference
           (url url)
           (commit commit)
           (recursive? recursive?)))
     (file-name (git-file-name name version))
     (hash
      (content-hash hash))))
   (build-system emacs-build-system)
   ;; (arguments
   ;;  `(#:phases
   ;;    (modify-phases %standard-phases
   ;;      (add-after 'unpack 'move-source-files
   ;;        (lambda _
   ;;          (let ((el-files (find-files "./extensions" ".*\\.el$")))
   ;;            (for-each (lambda (f)
   ;;                        (rename-file f (basename f)))
   ;;                      el-files)))))))
   ;; (native-inputs
   ;;  (list texinfo))
   (home-page nil)
   (synopsis nil)
   (description nil)
   (license nil)))

;; (println
;;  (fex-package "tldr"
;;               "https://github.com/kuanyui/tldr.el"
;;               "7203d1be3dcbf12131846ffe06601933fa874d74"
;;               nil
;;               "1bw6la463l2yfm7rp76ga4makfy4kpxgwi7ni5gxk31w11g26ryk"))




;; (defn call [nm & args]
;;   (let [f (ns-resolve *ns* (symbol nm))]
;;     (apply f args)))

(defn asdf [n]
  (+ 1 n))

(when (< (count (command-line)) 1) ; temporarily let me run this file manually
  (let [f (-> (command-line) second)
        args (-> (command-line) next next)]
    (println
     (let [func
           (case f
             "asdf" asdf)]
       (apply func (map read-string args))))))
#+end_src
********* packaging runner
#+begin_src scheme :tangle (meta-in-dir "packaging-runner.scm")
(use-modules (lokke ns))
(require #(ebullient.home.packaging-wip))
#+end_src
********* test clj
#+begin_src clojure :tangle ebullient/lokke/ns/ebullient/home/test-clj.clj :comments link
(ns ebullient.home.test-clj
  (:require [guile.guix.gexp :as g]
            [guile.guix.packages :refer [package package-description]]))

(println
 (gexp "asdf"))

;; (println
;;  (p/package (name "asdf")))

;; (println
;;  (package-description
;;   (package
;;     (name "asdf")
;;     (version "0")
;;     (source nil)
;;     (build-system nil)
;;     (synopsis "asdf")
;;     (description "asdf3333")
;;     (home-page nil)
;;     (license nil))))

(+ 1 1)
(println 5)

#+end_src
********* test scm
#+begin_src scheme :tangle (meta-in-dir "test-scm.scm")
(use-modules (lokke ns))
(require #(ebullient.home.test-clj))
#+end_src
********* elisp
#+begin_src elisp :tangle (meta-in-dir "parse-doom-packages.el")
(defun m-slurp (f)
  (with-temp-buffer
    (insert-file-contents f)
    (buffer-string)))

(defun m-spit (f content)
  (with-temp-file f
    (insert content)))




(defun m-process ()
  (-as-> (m-slurp "~/projects/phrenetic/doom-packaging/my-doom-packages.el") $
         (read $)
         (-map #'-first-item $)
         (-map #'symbol-name $)))

(defun write-doom-pkgs-txt ()
  (m-spit "doom-packaging/guix-doom-emacs-packages.txt"
          (pp (m-process))))





(defun repo-commit (r)
  (let ((default-directory (concat "~/.local/var/lib/doom-local/straight/repos/" r)))
    (straight--process-output "git" "rev-parse" "HEAD")))

(defun write-current-commits ()
  (let ((pkgs-to-repos
         (-map
          (lambda (x)
            (cons
             (-first-item x)
             (-as-> x $
                    (-fourth-item $)
                    (plist-get $ :local-repo))))
          (map-into straight--build-cache 'list))))
    (-map (lambda (x)
            (cons (car x)
                  (if-let ((y (cdr x)))
                      (if (not (equal y "/home/pharcosyle/projects/dotfiles/donnager"))
                          (repo-commit y)
                        nil)
                    y)))
          pkgs-to-repos)))

;; (write-current-commits)
#+end_src
**** Direnv
#+begin_src scheme
(define* (he-direnv svcs #:key shell)
  (cons*
   (service
    (service-type
     (name 'he-zsh-direnv)
     (extensions
      (list
       ;; REVIEW This might not be necessary once I integrate emacs-envrc during my Doom/Straight/Guix integration.
       (service-extension
        home-profile-service-type
        (const (list direnv)))
       (case shell
         ;; ((#:shell/bash)
         ;;  (service-extension
         ;;   home-bash-service-type
         ;;   (const (home-bash-extension
         ;;           (bashrc
         ;;            (list (mixed-text-file
         ;;                   "direnv-hook"
         ;;                   "eval \"$(" (file-append direnv "/bin/direnv") "hook bash)\"")))))))
         ((#:shell/zsh)
          (service-extension
           home-zsh-service-type
           (const (home-zsh-extension
                   (zshrc
                    (list (mixed-text-file
                           "direnv-hook"
                           "eval \"$(" (file-append direnv "/bin/direnv") "hook zsh)\""))))))))))
     (default-value #f)))
   svcs))
#+end_src
**** Desktop
***** Pipewire
#+begin_src scheme
(define (he-pipewire svcs)
  (cons*
   (service
    (service-type
     (name 'he-pipewire)
     (extensions
      (list
       (service-extension
        home-profile-service-type
        (const (list pipewire-0.3
                     wireplumber)))
       (service-extension
        home-shepherd-service-type
        (const
         (list
          (shepherd-service
           (provision '(pipewire))
           (stop  #~(make-kill-destructor))
           (start #~(make-forkexec-constructor
                     (list #$(file-append pipewire-0.3 "/bin/pipewire"))
                     #:environment-variables
                     (append (list "DISABLE_RTKIT=1")
                             (default-environment-variables))))
           (auto-start? #f))
          (shepherd-service
           (requirement '(pipewire))
           (provision '(wireplumber))
           (stop  #~(make-kill-destructor))
           (start #~(make-forkexec-constructor
                     (list #$(file-append wireplumber "/bin/wireplumber"))
                     #:environment-variables
                     (append (list "DISABLE_RTKIT=1")
                             (default-environment-variables))))
           (auto-start? #f))
          (shepherd-service
           (requirement '(pipewire))
           (provision '(pipewire-pulse))
           (stop  #~(make-kill-destructor))
           (start #~(make-forkexec-constructor
                     (list #$(file-append pipewire-0.3 "/bin/pipewire-pulse"))
                     #:environment-variables
                     (append (list "DISABLE_RTKIT=1")
                             (default-environment-variables))))
           (auto-start? #f)))))
       (service-extension
        home-xdg-configuration-files-service-type
        (const
         `(("alsa/asoundrc"
            ,(mixed-text-file
              "asoundrc"
              #~(string-append
                 "<" #$(file-append pipewire-0.3 "/share/alsa/alsa.conf.d/50-pipewire.conf") ">" "\n"
                 "<" #$(file-append pipewire-0.3 "/share/alsa/alsa.conf.d/99-pipewire-default.conf") ">" "\n"
                 "\n"
                 "pcm_type.pipewire {" "\n"
                 "  lib " #$(file-append pipewire-0.3 "/lib/alsa-lib/libasound_module_pcm_pipewire.so") "\n"
                 "}" "\n"
                 "\n"
                 "ctl_type.pipewire {" "\n"
                 "  lib " #$(file-append pipewire-0.3 "/lib/alsa-lib/libasound_module_ctl_pipewire.so") "\n"
                 "}" "\n"))))))))
     (default-value #f)))
   svcs))
#+end_src
***** Flatpak
#+begin_src scheme
(define (he-flatpak svcs)
  (cons*
   (service
    (service-type
     (name 'he-flatpak)
     (extensions
      (list
       (service-extension
        home-profile-service-type
        (const (list flatpak
                     xdg-desktop-portal
                     xdg-desktop-portal-wlr)))))
     (default-value #f)))
   svcs))
#+end_src
****** Make Flatpak apps visible
#+begin_src sh
export XDG_DATA_DIRS=$HOME/.local/share/flatpak/exports/share:$XDG_DATA_DIRS
#+end_src
****** WIP Flatpak
Ran these manually
#+begin_src sh
flatpak remote-add --user --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo

# flatpak install --user flathub com.spotify.Client
# flatpak install --user flathub us.zoom.Zoom
#+end_src
***** Window managers
****** Sway
#+begin_src scheme
(define-module (rde features wm)
  #:use-module (rde features)
  #:use-module (rde features predicates)
  #:use-module (rde features fontutils)
  #:use-module (gnu system)
  #:use-module (gnu system keyboard)
  #:use-module (rde packages)
  #:use-module (gnu packages wm)
  #:use-module (gnu packages image)
  #:use-module (gnu packages web)
  #:use-module (gnu packages qt)
  #:use-module (gnu packages linux)
  #:use-module (gnu packages xdisorg)
  #:use-module (gnu packages freedesktop)
  #:use-module (gnu packages terminals)
  #:use-module (gnu packages rust-apps)
  #:use-module (gnu services)
  #:use-module (gnu services xorg)
  #:use-module (gnu services shepherd)
  #:use-module (gnu home services)
  #:use-module (rde home services wm)
  #:use-module (gnu home services shells)

  #:use-module (guix gexp)
  #:use-module (guix packages)

  #:use-module (srfi srfi-1)

  #:export (feature-sway
            feature-sway-run-on-tty
            feature-sway-screenshot
            feature-sway-statusbar

            feature-swayidle
            feature-swaylock))

;; https://github.com/jjquin/dotfiles/tree/master/sway/.config/sway/config.d
;; https://nixos.wiki/wiki/Sway
;; https://github.com/swaywm/sway/wiki/Useful-add-ons-for-sway

(define (keyboard-layout-to-sway-config keyboard-layout)
  (let ((kb-options (string-join
                     (keyboard-layout-options keyboard-layout) ",")))
    `((input *
             ((xkb_layout  ,(keyboard-layout-name keyboard-layout))
              (xkb_variant ,(keyboard-layout-variant keyboard-layout))
              (xkb_options ,kb-options))))))

(define* (feature-sway
          #:key
          (extra-config '())
          (sway sway)
          (foot foot)
          (bemenu bemenu)
          (xdg-desktop-portal xdg-desktop-portal)
          (xdg-desktop-portal-wlr xdg-desktop-portal-wlr)
          ;; Logo key. Use Mod1 for Alt.
          (sway-mod 'Mod4)
          (add-keyboard-layout-to-config? #t)
          (xwayland? #f))
  "Setup and configure sway."
  (ensure-pred sway-config? extra-config)
  (ensure-pred boolean? add-keyboard-layout-to-config?)
  (ensure-pred any-package? sway)
  (ensure-pred any-package? foot)
  (ensure-pred any-package? bemenu)
  (ensure-pred any-package? xdg-desktop-portal)
  (ensure-pred any-package? xdg-desktop-portal-wlr)

  (define (sway-home-services config)
    "Returns home services related to sway."
    (let* ((kb-layout      (get-value 'keyboard-layout config))
           (layout-config  (if (and add-keyboard-layout-to-config? kb-layout)
                               (keyboard-layout-to-sway-config kb-layout)
                               '()))

           (lock-cmd
            (get-value 'default-screen-locker config "loginctl lock-session"))

           (default-terminal
             (get-value-eval 'default-terminal config
                             (file-append foot "/bin/foot")))
           (backup-terminal
             (get-value 'backup-terminal config
                        (file-append foot "/bin/foot")))
           (default-application-launcher
             (get-value 'default-application-launcher config
                        (file-append bemenu "/bin/bemenu-run -l 20 -p run:"))))
      (list
       (service
        home-sway-service-type
        (home-sway-configuration
         (package sway)
         (config
          `((xwayland ,(if xwayland? 'enable 'disable))
            (,#~"")
            ,@layout-config

            (,#~"\n\n# General settings:")
            (set $mod ,sway-mod)
            (set $term ,default-terminal)
            (set $backup-term ,backup-terminal)
            (set $menu ,default-application-launcher)
            (set $lock ,lock-cmd)

            (floating_modifier $mod normal)

            (bindsym $mod+Shift+r reload)

            (,#~"\n\n# Launching external applications:")
            (bindsym $mod+Control+Shift+Return exec $backup-term)
            (bindsym $mod+Return exec $term)

            (bindsym $mod+Shift+d exec $menu)
            (bindsym $mod+Shift+l exec $lock)

            (,#~"\n\n# Manipulating windows:")
            (bindsym $mod+Shift+c kill)
            (bindsym $mod+Shift+f fullscreen)
            (bindsym $mod+Shift+space floating toggle)
            (bindsym $mod+Ctrl+space focus mode_toggle)

            (bindsym $mod+Left focus left)
            (bindsym $mod+Down focus down)
            (bindsym $mod+Up focus up)
            (bindsym $mod+Right focus right)

            (bindsym $mod+Shift+Left move left)
            (bindsym $mod+Shift+Down move down)
            (bindsym $mod+Shift+Up move up)
            (bindsym $mod+Shift+Right move right)

            (,#~"\n\n# Moving around workspaces:")
            (bindsym $mod+tab workspace back_and_forth)
            ,@(append-map
               (lambda (x)
                 `((bindsym ,(format #f "$mod+~a" (modulo x 10))
                            workspace number ,x)
                   (bindsym ,(format #f "$mod+Shift+~a" (modulo x 10))
                            move container to workspace number ,x)))
               (iota 10 1))

            (,#~"\n\n# Scratchpad settings:")
            (bindsym $mod+Shift+minus move scratchpad)
            (bindsym $mod+minus scratchpad show)

            (,#~"")
            (default_border pixel)
            (default_floating_border pixel)
            (gaps inner ,(get-value 'emacs-margin config 8))))))

       (when (get-value 'swayidle-cmd config)
         (simple-service
          'sway-enable-swayidle
          home-sway-service-type
          `((,#~"")
            (exec ,(get-value 'swayidle-cmd config)))))

       (when (get-value 'swayidle config)
         (let* ((swaymsg (file-append sway "/bin/swaymsg"))
                (swaymsg-cmd (lambda (cmd)
                               #~(format #f "'~a \"~a\"'" #$swaymsg #$cmd)))
                (idle-timeout (+ 30 (get-value 'lock-timeout config 120))))
           (simple-service
            'sway-add-dpms-to-swayidle
            home-swayidle-service-type
            `((timeout ,idle-timeout ,(swaymsg-cmd "output * dpms off")
               resume                ,(swaymsg-cmd "output * dpms on"))))))

       (simple-service
        'sway-configuration
        home-sway-service-type
        `(,@extra-config
          (,#~"")))

       (simple-service
        'sway-reload-config-on-change
        (@@ (gnu home services) home-run-on-change-service-type)
        `(("files/config/sway/config"
           ,#~(system* #$(file-append sway "/bin/swaymsg") "reload"))))

       (simple-service
        'packages-for-sway
        home-profile-service-type
        (append
         (if (and (get-value 'default-terminal config)
                  (get-value 'backup-terminal config))
             '() (list foot))
         (if (get-value 'default-application-launcher config) '() (list bemenu))
         (list qtwayland swayhide
               xdg-desktop-portal xdg-desktop-portal-wlr)))
       (simple-service 'set-wayland-specific-env-vars
                       home-environment-variables-service-type
                       ;; export NO_AT_BRIDGE=1
                       '(("XDG_CURRENT_DESKTOP" . "sway")
                         ("XDG_SESSION_TYPE" . "wayland")
                         ;; FIXME: Should be in feature-pipewire
                         ("RTC_USE_PIPEWIRE" . "true")
                         ("SDL_VIDEODRIVER" . "wayland")
                         ("MOZ_ENABLE_WAYLAND" . "1")
                         ("CLUTTER_BACKEND" . "wayland")
                         ("ELM_ENGINE" . "wayland_egl")
                         ("ECORE_EVAS_ENGINE" . "wayland-egl")
                         ("QT_QPA_PLATFORM" . "wayland-egl")
                         ("_JAVA_AWT_WM_NONREPARENTING" . "1"))))))

  (feature
   (name 'sway)
   (values `((sway . ,sway)
             (wl-clipboard . ,wl-clipboard)
             (wayland . #t)
             (xwayland? . ,xwayland?)))
   (home-services-getter sway-home-services)))


;;;
;;; sway-screenshot.
;;;

(define* (feature-sway-screenshot)
  "Configure slurp, grim and other tools for screenshot capabilities."

  (define sway-f-name 'screenshot)
  (define f-name (symbol-append 'sway- sway-f-name))

  (define (get-home-services config)
    (require-value 'sway config)
    (define subject-output
      #~(format #f "~a -t get_outputs | ~a -r '.[] | select(.focused) | .name'"
                #$(file-append (get-value 'sway config) "/bin/swaymsg")
                #$(file-append jq "/bin/jq")))
    (define subject-window-or-selection
      #~(format #f "~a -t get_tree | ~a -r '.. | select(.pid? and .visible?) \
| .rect | \"\\(.x),\\(.y) \\(.width)x\\(.height)\"' | ~a -b ~a -B ~a"
                #$(file-append (get-value 'sway config) "/bin/swaymsg")
                #$(file-append jq "/bin/jq")
                ;; TODO: Move to slurp-cmd
                #$(file-append slurp "/bin/slurp")
                "303030AA"
                "303030AA"))

    (define* (shot-script subject #:key output geom (file "-"))
      (program-file
       (string-append "sway-shot-" subject)
       #~(system
          (format #f "~a ~a~a~a | ~a"
                  #$(file-append grim "/bin/grim")
                  #$(if output #~(string-append "-o \"$(" #$output ")\" ") "")
                  #$(if geom #~(string-append "-g \"$(" #$geom ")\" ") "")
                  #$file
                  #$(file-append (get-value 'wl-clipboard config)
                                 "/bin/wl-copy")))))

    (define shot-output
      (shot-script "output" #:output subject-output))
    (define shot-window-or-selection
      (shot-script "window-or-selection" #:geom subject-window-or-selection))
    (list
     ;; (simple-service
     ;;  'sway-screenshot-packages
     ;;  home-profile-service-type
     ;;  (list slurp grim wl-clipboard jq))

     (simple-service
      'sway-screenshot
      home-sway-service-type
      `((bindsym $mod+Print exec ,shot-output)
        (bindsym $mod+Shift+Print exec ,shot-window-or-selection)))))

  (feature
   (name f-name)
   (values `((,f-name . #t)))
   (home-services-getter get-home-services)))




;;;
;;; swayidle.
;;;

(define* (feature-swayidle
          #:key
          (swayidle swayidle)
          (lock-timeout 120)
          (extra-config '()))
  "Configure swayidle."
  (ensure-pred any-package? swayidle)

  (define swayidle-cmd (file-append swayidle "/bin/swayidle -w"))

  (define (get-home-services config)
    (define lock-cmd (get-value 'default-screen-locker config))

    (list
     (service
      home-swayidle-service-type
      (home-swayidle-configuration
       (swayidle swayidle)
       (config
        `(,@(if lock-cmd
                (let ((lock-cmd-quoted (format #f "'~a'" lock-cmd)))
                  `((lock ,lock-cmd-quoted)
                    (before-sleep ,lock-cmd-quoted)
                    (timeout ,lock-timeout ,lock-cmd-quoted)))
                '())
          ,@extra-config))))))

  (feature
   (name 'swayidle)
   (values `((swayidle . ,swayidle)
             (swayidle-cmd . ,swayidle-cmd)
             (lock-timeout . ,lock-timeout)))
   (home-services-getter get-home-services)))


;;;
;;; swaylock.
;;;

(define* (feature-swaylock
          #:key
          (swaylock swaylock)
          (show-failed-attempts? #t)
          (show-keyboard-layout? #f)
          (daemonize? #t)
          (extra-config '())
          (default-screen-locker? #t))
  "Configure swaylock."
  (ensure-pred any-package? swaylock)

  (define (get-home-services config)
    (list
     (service
      home-swaylock-service-type
      (home-swaylock-configuration
       (swaylock swaylock)
       (config
        `((show-failed-attempts . ,show-failed-attempts?)
          (daemonize . ,daemonize?)
          (show-keyboard-layout . ,show-keyboard-layout?)
          ;; TODO: Source color from colorscheme
          (color . 3e3e3e)
          (indicator-caps-lock)
          ,@extra-config))))))

  (define (get-system-services _)
    (list
     (screen-locker-service swaylock "swaylock")
     ;; (simple-service
     ;;  'setuid-chkpwd
     ;;  setuid-program-service-type
     ;;  (list (file-like->setuid-program
     ;;         (file-append linux-pam "/sbin/unix_chkpwd"))))

     ;; (simple-service
     ;;  'sway-add-swaylock-pam
     ;;  pam-root-service-type
     ;;  (list
     ;;   (unix-pam-service "swaylock")))
     ))

  (feature
   (name 'swaylock)
   (values `((swaylock . ,swaylock)
             ,@(if default-screen-locker?
                   ;; TODO: Change it to path in the store, once
                   ;; https://issues.guix.gnu.org/53468 is resolved
                   `((default-screen-locker . "/run/setuid-programs/swaylock"))
                   '())))
   (home-services-getter get-home-services)
   (system-services-getter get-system-services)))
#+end_src
******* Sway old WIP
#+begin_src scheme
(define (sway-env-vars env-vars)
  (simple-service 'set-sway-env-vars
                  home-bash-service-type
                  (home-bash-extension
                   (bash-profile
                    (list (mixed-text-file
                           "sway-env-vars"
                           "if [[ \"$DESKTOP_SESSION\" = \"\" || \"$DESKTOP_SESSION\" = \"sway\" ]] ; then\n"
                           (serialize-posix-env-vars #f env-vars)
                           "fi"))))))

(define (conditionalize-sway-env-vars services)
  (define env-vars)
  (as-> services $
    (update-services*
     $
     (lambda (svc)
       (eq? (-> svc service-kind service-type-name) 'set-wayland-specific-env-vars))
     (lambda (vars)
       (set! env-vars vars)
       '()))
    (cons* (sway-env-vars env-vars) $)))

(define sway-services
  (conditionalize-sway-env-vars
   ((feature-home-services-getter
     (feature-sway #:xwayland? #t
                   #:sway-mod 'Mod1
                   #:extra-config
                   ;; `((include ,(file-append (@ (gnu packages wm) sway) "/etc/sway/config")))
                   ;; `((include ,(local-file "./config/sway/config")))
                   `((include "/home/pharcosyle/projects/phrenetic/config"))))
    (rde-config))))
#+end_src
***** Screen lockers
****** Swaylock
***** Idle management
****** Swayidle
***** Status bars
****** Waybar
***** Applets
****** Gammastep
- TODO broken tray icon. Probably I need to have some part of the =gammastep= package on the path so it can find the icon. Don't worry about this for now, maybe there will be some way to tell =papirus-icon-theme= to use a different icon or something.
#+begin_src scheme
(define (gammastep-shepherd-service _)
  (list
   (shepherd-service
    (provision '(gammastep))
    (start #~(lambda (wayland-display . _)
               ((make-forkexec-constructor
                 (list #$(file-append gammastep "/bin/gammastep-indicator") "-l 44:-123")
                 #:environment-variables
                 ;; (list (string-append "WAYLAND_DISPLAY=" wayland-display))
                 (call-with-input-file "/tmp/env-for-applets" read)))))
    (stop #~(make-kill-destructor))
    (respawn? #f)
    (auto-start? #f))))

(define gammastep-service-type
  (service-type (name 'he-gammastep)
                (extensions
                 (list (service-extension
                        home-shepherd-service-type
                        gammastep-shepherd-service)))
                (default-value #f)))
#+end_src
****** Network Manager
#+begin_src scheme
(define (network-manager-shepherd-service _)
  (list
   (shepherd-service
    (provision '(nm))
    (start #~(lambda (wayland-display . _)
               ((make-forkexec-constructor
                 (list #$(file-append network-manager-applet "/bin/nm-applet") "--indicator")
                 #:environment-variables
                 ;; (list (string-append "WAYLAND_DISPLAY=" wayland-display))
                 (call-with-input-file "/tmp/env-for-applets" read)))))
    (stop #~(make-kill-destructor))
    (respawn? #f)
    (auto-start? #f))))

(define network-manager-service-type
  (service-type (name 'he-network-manager)
                (extensions
                 (list (service-extension
                        home-shepherd-service-type
                        network-manager-shepherd-service)))
                (default-value #f)))
#+end_src
****** Udiskie
#+begin_src scheme
(define (udiskie-shepherd-service _)
  (list
   (shepherd-service
    (provision '(udiskie))
    (start #~(lambda (wayland-display . _)
               ((make-forkexec-constructor
                 (list #$(file-append udiskie "/bin/udiskie")
                       "--tray"
                       ;; (string-append "--file-manager="
                       ;;                #$(file-append xdg-utils "/bin/xdg-open"))
                       )
                 #:environment-variables
                 ;; (list (string-append "WAYLAND_DISPLAY=" wayland-display))
                 (call-with-input-file "/tmp/env-for-applets" read)))))
    (stop #~(make-kill-destructor))
    (respawn? #f)
    (auto-start? #f))))

(define udiskie-service-type
  (service-type (name 'he-udiskie)
                (extensions
                 (list (service-extension
                        home-shepherd-service-type
                        udiskie-shepherd-service)))
                (default-value #f)))
#+end_src
*** Base HE
#+begin_src scheme :tangle (meta-in-dir "base-he.scm")
(define-module (ebullient home base-he)
  #:use-module (gnu home)
  #:use-module ((donnager client) #:prefix d:)
  #:use-module (ebullient)
  #:use-module ((ebullient home emacs) #:select (emacs-fully-loaded))
  #:use-module (ebullient home components)
  #:use-module (mendicant utils)
  #:export (base-he))

(define* (base-he #:key
                  system
                  account
                  developer?)
  (let* ((login-shell
          (let ((shell (get (d:pull '(#:user/login-shell) user) #:user/login-shell)))
            (if (equal? shell #:shell/default)
                default-login-shell shell)))
         (interactive-shell (if developer?
                                #:shell/zsh login-shell))
         (feature?
          (let ((features (get (d:pull '(#:system/features) system) #:system/features)))
            (lambda (feat)
              (member feat features))))
         (nix? (feature? #:feature/nix))
         (desktop? (feature? #:feature/desktop))
         (pipewire? (feature? #:feature/pipewire))
         (session?
          (lambda (s)
            (member s (get (d:pull '(#:user/sessions) account) #:user/sessions))))
         (sway? (session? :session/sway)))
    (home-environment
     (services
      (-> '()
          (he-shells #:login-shell login-shell
                     #:interactive-shell interactive-shell)
          he-extra-profiles
          (as-> $
            (if nix?
                (he-nix $) $)
            (if developer?
                (-> $
                    (he-emacs #:zsh-vterm? (eq? interactive-shell #:shell/zsh)
                              ;; TODO
                              ;; #:config (kvm #:emacs ...)
                              #:config (kvm #:emacs (emacs-fully-loaded #:pgtk? #t)))
                    he-doom
                    (he-direnv #:shell interactive-shell)))
            (if desktop?
                (-> $
                    (as->$
                      (if pipewire?
                          (he-pipewire $) $))
                    he-flatpak
                    (as->$
                      (if sway?
                          (he-sway $) $)))
                $)))))))
#+end_src
*** \
#+begin_src sh :var he_name="" he_dir=(meta-get-dir)
guix pull --channels="$he_dir"/$he_name-channels-lock
#+end_src
- TODO expression shouldn't reference "exhuberant"
#+begin_src sh :var he_name=""
guix home \
	--load-path=. \
	--expression="(@ (exuberant he $he_name) he)" \
	reconfigure
#+end_src
*** Guix extra profiles
:PROPERTIES:
:meta-dir+: /manifests
:END:
**** Manifests
#+name: guix-extra-profile-path
#+begin_src sh :var profileName="" :noweb yes
echo "<<guix-extra-profiles-path>>/$profileName/$profileName"
#+end_src
***** Multiverse :manifest:
#+begin_src scheme :tangle (meta-in-dir "multiverse")
(specifications->manifest
 '("btrfs-progs" ; TODO "depends on"/"exists because of" the stateless module. Maybe it should be in some "system administration" section of Home config

   ;; "protonvpn-cli" ; REVIEW Appears to be broken after the big Guix frozen-updates upgrade.

   ;; General
   "xdg-utils"
   "gtk+:bin" ; TODO Gate this with `desktop?`
   "curl"
   "zip"
   "unzip"

   ;; Nice-to-have ; TODO might get rid of these and just `guix shell' or install as-needed
   "tree"
   "woof"


   ;;; Apps

   ;; Nyxt
   "nyxt"
   "gst-libav"
   "gst-plugins-bad"
   "gst-plugins-base"
   "gst-plugins-good"
   "gst-plugins-ugly"

   ;; "gimp" ; TODO maybe. Or just install as-needed with `guix shell`
   ))
#+end_src
#+begin_src elisp :noweb-ref guix-extra-profiles :noweb-sep " " :noweb yes
"<<guix-extra-profile-path("multiverse")>>"
#+end_src
**** \
#+name: install-profiles
#+begin_src sh :results output silent :dir (meta-get-dir) :noweb yes :async
gepp="<<guix-extra-profiles-path>>"
GUIX_EXTRA_PROFILES="${gepp/#\~/$HOME}"

profiles=$*
if [[ $# -eq 0 ]]; then
    profiles="*";
fi

for profile in $profiles; do
  profileName=$(basename $profile .scm)
  profilePath="$GUIX_EXTRA_PROFILES/$profileName"
  mkdir -p $profilePath
  guix package --profile="$profilePath/$profileName" --manifest="$profileName"
done
#+end_src
#+call: install-profiles[:cmdline ...]()

#+name: upgrade-profiles
#+begin_src sh :results output silent :noweb yes :async
gepp="<<guix-extra-profiles-path>>"
GUIX_EXTRA_PROFILES="${gepp/#\~/$HOME}"

profiles=$*
if [[ $# -eq 0 ]]; then
    profiles="$GUIX_EXTRA_PROFILES/*";
fi

for profile in $profiles; do
  profileName=$(basename $profile)
  profilePath="$GUIX_EXTRA_PROFILES/$profileName"
  guix package --profile="$profilePath/$profileName" --manifest="$profileName"
done
#+end_src
#+call: upgrade-profiles[:cmdline ...]()
** \
#+begin_src sh :var name="" dir=""
guix time-machine \
	--load-path=. \
	--channels="$dir"/$name-channels \
	-- \
	describe --format=channels > "$dir"/$name-channels-lock
#+end_src
** Dev
*** Git ignore
#+begin_src gitignore :tangle (meta-in-dir ".gitignore")
,*
#+end_src
* Projects
:PROPERTIES:
:meta-dir+: /penitent
:END:
- TODO call this something different? Maybe it'll end up being just a container for Guix packages shared across projects and should just be called "Packages" or "Auxillary" or something.
** Packages
:PROPERTIES:
:meta-dir+: /penitent/packages
:END:
*** AWS CLI :package:version:
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "aws.scm")
:END:
- TODO
  - generate the autocompletion index
    As described here:
    [[https://github.com/aws/aws-cli/tree/v2#cli-dev-version][GitHub - aws/aws-cli at v2 (cli dev version)]]
    [[https://github.com/NixOS/nixpkgs/blob/nixos-unstable/pkgs/tools/admin/awscli2/default.nix#L95][nixpkgs/default.nix at nixos-unstable · NixOS/nixpkgs · GitHub]]
  - set up command completion
    [[https://github.com/aws/aws-cli/tree/v2#command-completion][GitHub - aws/aws-cli at v2 (command completion)]]
  - [2022-04-13 Wed] dependencies don't need to be propagated?
    [[https://github.com/guix-mirror/guix/commit/fc89b50b7bb2edbc38b20adf8c899934dedcb6c3][gnu: awscli: Do not propagate inputs. · guix-mirror/guix@fc89b50 · GitHub]]
    This is for v1, might not apply here. At the time of this writing, this commit is only two hours old, see if there's any follow-up.
#+begin_src scheme
(define-module (penitent packages aws)
  #:use-module (guix build-system python)
  #:use-module (guix download)
  #:use-module (guix gexp)
  #:use-module (guix git-download)
  #:use-module ((guix licenses) #:prefix license:)
  #:use-module (guix packages)
  #:use-module ((guix utils) #:select (substitute-keyword-arguments))
  #:use-module ((gnu packages check) #:select (python-mock python-pytest python-coverage python-pytest-cov python-pytest-xdist))
  #:use-module ((gnu packages cmake) #:select (cmake))
  #:use-module ((gnu packages groff) #:select (groff))
  #:use-module ((gnu packages python-web) #:select (awscli) #:prefix python-web:)
  #:use-module ((gnu packages python-web) #:select (python-urllib3))
  #:use-module ((gnu packages python-xyz) #:select (python-prompt-toolkit) #:prefix python:)
  #:use-module ((gnu packages python-xyz) #:select (python-colorama-for-awscli python-docutils-0.15 python-wcwidth python-distro python-jmespath python-boto3 python-botocore python-six python-jsonschema))
  #:use-module ((gnu packages python-crypto) #:select (python-cryptography) #:prefix python-crypto:)
  #:use-module ((gnu packages serialization) #:select (python-ruamel.yaml))
  #:use-module ((gnu packages time) #:select (python-dateutil)))

(define-public awscli
  (package
    (inherit python-web:awscli)
    (version "2.4.23")
    (source
     (origin
       (method git-fetch)
       (uri (git-reference
             (url "https://github.com/aws/aws-cli")
             (commit version)))
       (sha256
        (base32
         "1xdgj6w6ibfiwpzd85g9lhk106nxrw06c9bdcrmfr68zaa32k6ff"))
       (file-name (git-file-name (package-name python-web:awscli) version))))
    (arguments
     (substitute-keyword-arguments (package-arguments python-web:awscli)
       ;; A few tests fail at present but I'm not gonna sweat it. A number more error but I think that's mostly due to the lack of network access. The vast majority pass:
       ;; Total tests ~7000 (failures=3, errors=222, skipped=6)
       ((#:tests? _) #f)))
    (propagated-inputs
     (list python-colorama-for-awscli
           python-docutils-0.15
           python-cryptography
           python-ruamel.yaml-0.15
           python-wcwidth
           python-prompt-toolkit
           python-distro-1.5
           python-awscrt
           python-dateutil
           python-jmespath
           python-urllib3))
    (native-inputs
     (list groff
           ;; For tests.
           python-jsonschema
           python-mock
           python-pytest
           python-coverage
           python-pytest-cov
           python-pytest-xdist))))
#+end_src
**** Deps :package:version:
#+begin_src scheme
(define python-awscrt
  (package
    (name "python-awscrt")
    (version "0.12.4")
    (source
     (origin
       (method url-fetch)
       (uri (pypi-uri "awscrt" version))
       (sha256
        (base32 "1cmfkcv2zzirxsb989vx1hvna9nv24pghcvypl0zaxsjphv97mka"))))
    (build-system python-build-system)
    (native-inputs
     (list
      cmake
      ;; For tests.
      python-boto3))
    (home-page "https://github.com/awslabs/aws-crt-python")
    (synopsis "A common runtime for AWS Python projects")
    (description "This package provides a common runtime for AWS Python projects")
    (license license:asl2.0)))

(define python-cryptography
  (package
    (inherit python-crypto:python-cryptography)
    (version "3.3.2")
    (source
     (origin
       (method url-fetch)
       (uri (pypi-uri "cryptography" version))
       (sha256
        (base32
         "1vcvw4lkw1spiq322pm1256kail8nck6bbgpdxx3pqa905wd6q2s"))))))

(define python-ruamel.yaml-0.15
  (package
    (inherit python-ruamel.yaml)
    (version "0.15.100")
    (source
     (origin
       (method url-fetch)
       (uri (pypi-uri "ruamel.yaml" version))
       (sha256
        (base32
         "1r5j9n2jdq48z0k4bdia1f7krn8f2x3y49i9ba9iks2rg83g6hlf"))))))

(define python-prompt-toolkit
  (package
    (inherit python:python-prompt-toolkit)
    (version "3.0.28")
    (source
     (origin
       (method url-fetch)
       (uri (pypi-uri "prompt_toolkit" version))
       (sha256
        (base32
         "0l0nnm9fvs8lklk2qq8mylb9jrlxvlqzpmqr4n7rdhl63rmx274z"))))))

(define python-distro-1.5
  (package
    (inherit python-distro)
    (version "1.5.0")
    (source
     (origin
       (method url-fetch)
       (uri (pypi-uri "distro" version))
       (sha256
        (base32
         "14nz51cqlnxmgfqqilxyvjwwa5xfivdvlm0d0b1qzgcgwdm7an0f"))))))
#+end_src
*** Datomic CLI tools :package:version:
- TODO =bin/datomic= introduces a dependency (~com.datomic/tools.ops~)
  Is that something I'd want to include in the package or whatever?
#+begin_src scheme :tangle (meta-in-dir "datomic.scm")
(define-module (penitent packages datomic)
  #:use-module (guix build-system copy)
  #:use-module (guix download)
  #:use-module (guix gexp)
  #:use-module (guix packages)
  #:use-module ((gnu packages compression) #:select (unzip))
  #:use-module ((nonguix licenses) #:prefix license:))

(define-public datomic-cli-tools
  (package
    (name "datomic-cli-tools")
    (version "1.0.91")
    (source
     (origin
       (method url-fetch)
       (uri (string-append "https://datomic-releases-1fc2183a.s3.amazonaws.com/tools/datomic-cli/datomic-cli-" version ".zip"))
       (sha256
        (base32
         "1xicmbsig8f1p5r9rxkhndi0f9l9w421zf49rbx44yc6v0db523b"))))
    (build-system copy-build-system)
    (arguments
     `(#:install-plan
       '(("." "bin" #:include-regexp ("^\\./datomic")) ; Files that start with "datomic" are the scripts. Restrict to this subset to automatically pick up any added in the future without being too inclusive about what we add to bin.
         ("README.txt" "share/doc/datomic/"))
       #:phases
       ,#~(modify-phases %standard-phases
            (add-after 'install 'make-scripts-executable
              (lambda _
                (for-each (lambda (f) (chmod f #o555))
                          (find-files (string-append #$output "/bin"))))))))
    (native-inputs
     (list unzip))
    (home-page "https://docs.datomic.com/cloud/index.html")
    (synopsis "CLI tools for Datomic")
    (description synopsis)
    (license (license:nonfree "https://www.datomic.com/cloud-eula.html"))))
#+end_src
*** Clojure :package:version:
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "clojure.scm")
:END:
**** Non-bootstrapped clojure tools
- REVIEW
  - source
    Do I have access to any clojure/java source code so that e.g. cider jump-to-definition works right?
  - the =docs= output of the jdk
    Is is useful/necessary, e.g. would any tooling, like cider, take advantage of it?

A =clojure-tools= package that mirrors the clojure.org install script and thus uses prebuilt resources instead of bootstrapping everything the way the Guix package does. I don't see any advantages to bootstrapping and I'm leery that the various split-out dependencies (like =clojure-tools-deps-alpha= which in turn requires =clojure-data-xml=, etc) aren't the same ones the prebuilt clojure uses or the same versions.

Some considerations if I want to switch to the Guix =clojure-tools= package:
- bumping
  I'm interested in using the latest versions of =clojure-tools= / =clojure=, how would I suss out the dependency chain to bump all of the transitive deps?
- clojure and jdk deps
  The ~clojure-build-system~ specifies versions of clojure and java to use ("It adds clojure, icedtea and zip to the set of inputs...") and the ~clojure~ package specifies a java input. Should I make them use newer versions / specifically the versions I have installed; does it matter?

#+begin_src scheme
(define-module (penitent packages clojure)
  #:use-module (guix build-system copy)
  #:use-module (guix download)
  #:use-module (guix gexp)
  #:use-module (guix packages)
  #:use-module ((guix utils) #:select (substitute-keyword-arguments))
  #:use-module ((gnu packages clojure) #:select (clojure-tools) #:prefix clojure:)
  #:use-module ((gnu packages readline) #:select (rlwrap)))

(define-public clojure-tools
  (with-man-pages
   (package
     (name "clojure-tools")
     (version "1.11.1.1105")
     (source
      (origin
        (method url-fetch)
        (uri (string-append "https://download.clojure.org/install/clojure-tools-" version ".tar.gz"))
        (sha256
         (base32
          "0rq5wk59h9r69jv598knhpnmhm0lw8rq57rc4b29sidcl81as74r"))))
     (build-system copy-build-system)
     (arguments
      `(#:install-plan
        '(("deps.edn" "lib/clojure/")
          ("example-deps.edn" "lib/clojure/")
          ("tools.edn" "lib/clojure/")
          ("exec.jar" "lib/clojure/libexec/")
          (,(string-append "clojure-tools-" version ".jar") "lib/clojure/libexec/")
          ("clojure" "bin/")
          ("clj" "bin/"))
        #:phases
        (modify-phases %standard-phases
          (add-after 'unpack 'fix-paths
            (lambda* (#:key outputs #:allow-other-keys)
              (substitute* "clojure"
                (("PREFIX") (string-append (assoc-ref outputs "out") "/lib/clojure")))
              (substitute* "clj"
                (("BINDIR") (string-append (assoc-ref outputs "out") "/bin"))
                (("rlwrap") (which "rlwrap"))))))))
     (inputs
      (list rlwrap))
     (home-page (package-home-page clojure:clojure-tools))
     (synopsis (package-synopsis clojure:clojure-tools))
     (description (package-description clojure:clojure-tools))
     (license (package-license clojure:clojure-tools)))))
#+end_src
**** =man= pages :upstream:
#+begin_src scheme
(define-public (with-man-pages clojure-tools)
  (package
    (inherit clojure-tools)
    (arguments
     (substitute-keyword-arguments (package-arguments clojure-tools)
       ((#:install-plan install-plan)
        #~(append #$install-plan '(("clojure.1" "/share/man/man1/")
                                   ("clj.1" "/share/man/man1/"))))))))
#+end_src
** Dev
*** Git ignore
#+begin_src gitignore :tangle (meta-in-dir ".gitignore")
,*
#+end_src
* DB
:PROPERTIES:
:meta-dir+: /donnager
:END:
** Core
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "donnager-core.el")
:END:
#+begin_src elisp
;;; -*- lexical-binding: t; -*-

(require 'dash)
(require 'tangential)
#+end_src




#+begin_src elisp
(defun db--entity->datoms (entity)
  (->> entity
       ;; FIXME what was `map-pairs' for?
       map-pairs
       (map-remove (lambda (k _)
                     (equal k :db/id)))
       (-mapcat (-lambda ((a . v))
                  (let ((avs (if (listp v)
                                 (-map (lambda (i) `(,a ,i)) v)
                               `((,a ,v)))))
                    (-map (-lambda ((attr value))
                            (db--datom (map-elt entity :db/id) attr value))
                          avs))))))
#+end_src

#+name: base-schema
| =:db/id=        | =:db/valueType=  | =:db/cardinality=   |
|-----------------+------------------+---------------------|
| :db/id          | :db.type/keyword | :db.cardinality/one |
| :db/valueType   | :db.type/keyword | :db.cardinality/one |
| :db/cardinality | :db.type/keyword | :db.cardinality/one |

#+begin_src elisp
(defun db--parse-schema-entity (entity)
  (map-apply (lambda (a b)
               (cons (intern a) (intern b)))
             entity))
#+end_src

#+begin_src elisp :var base-schema-table=base-schema
(defun db--parse-base-schema ()
  (->> base-schema-table
       db--parse-org-table
       (-map #'db--parse-schema-entity)
       (-mapcat #'db--entity->datoms)))
#+end_src
#+begin_src elisp
(setq db--base-schema-memo nil)

(defun db--base-schema ()
  (if db--base-schema-memo
      db--base-schema-memo
    (setq db--base-schema-memo db--parse-base-schema)))


(defun db--with-base-schema (db)
  (-concat (db--base-schema) db))
#+end_src



#+begin_src elisp
(setq db--schema-defaults
      (kvm :db.valueType :db.type/string
           :db.cardinality :db.cardinality/one))

(defun db--get-schema (db attr schema-attr)
  (-as-> db $
         (db--with-base-schema $)
         (-first (lambda (datom)
                   (db--datom-match-e+a datom attr schema-attr))
                 $)
         (if $
             (db--dget $ :datom/v)
           (map-elt db--schema-defaults schema-attr))))
#+end_src




#+begin_src elisp
(defun db--datom (e a v)
  (list e a v))

(defun db--dget (datom component)
  ((pcase component
     (:datom/e #'-first-item)
     (:datom/a #'-second-item)
     (:datom/v #'-third-item))
   datom))

(defun db--datom-match-e+a (datom e a)
  (and (equal (db--dget datom :datom/e) e)
       (equal (db--dget datom :datom/a) a)))

(defun db--assert (db datom)
  (cons datom))
#+end_src
*** \
#+begin_src elisp
(provide 'donnager-core)
#+end_src
** Client API
*** Elisp
*** Scheme
#+begin_src scheme :tangle (meta-in-dir "donnager/client.scm")
(define-module (donnager client)
  #:export (q
            q-many
            pull
            pull-many))

(define (q)
  #f)
(define (q-many)
  #f)
(define (pull)
  #f)
(define (pull-many)
  #f)
#+end_src
** Org API
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "donnager-org.el")
:END:
#+begin_src elisp
;;; -*- lexical-binding: t; -*-

(require 'donnager-core)

(setq db--empty-db '())
#+end_src
*** Data
#+begin_src elisp
(setq db--parse-keyword #'intern)

(defun match-string-one (regex s)
  (save-match-data
    (when (string-match regex s)
      (match-string 1 string))))

(setq db--parsers
      (kvm :db.type/keyword db--parse-keyword
           :db.type/string #'identity
           :db.type/boolean (lambda (s)
                              (pcase s
                                ("true" t)
                                ("false" nil)))
           :db.type/symbol (lambda (s)
                             (intern (match-string-one (rx "'" (group (* anything))) s)))))

(defalias 'db--parse-attr #'db--parse-keyword)

(defun db--parse-value (db a raw-v)
  (let* ((type (db--get-schema db a :db/valueType))
         (parser (map-elt db--parsers type))
         (cardinality (db--get-schema db a :db/cardinality)))
    (if (equal cardinality :db.cardinality/many)
        (-as-> raw-v $
               (split-string $ (rx (+ whitespace)))
               (-map (lambda (raw-item)
                       (funcall parser raw-item))))
      (funcall parser raw-v))))

(defun db--parse-entity (db raw-entity)
  (map-apply (lambda (raw-a raw-v)
               (let ((a (db--parse-attr raw-a)))
                 (cons a
                       (db--parse-value db a raw-v))))
             raw-entity))
#+end_src
*** Tables
#+begin_src elisp
(defun db--normalize-org-table (table)
  (-remove (-partial #'equal 'hline) table))

(defun db--strip-org-emphasis (s)
  (if (and (< 2 (length s))
           (let ((first (substring s 0 1))
                 (last (substring s -1)))
             (and (equal first last)
                  (member first (map-keys org-emphasis-alist)))))
      (substring s 1 -1)
    s))

(defun db--parse-org-table (table)
  (let* ((table (db--normalize-org-table table))
         (attrs (-map #'db--strip-org-emphasis (car table)))
         (rows (cdr table)))
    (-map (lambda (row)
            (->> row
                 (-zip-pair attrs)
                 (map-remove (lambda (_ v)
                               (equal v "")))))
          rows)))
#+end_src
*** Injest
#+begin_src elisp
(defun db--raw-entity-into-db (db raw-entity)
  (->> raw-entity
       (db--parse-entity db)
       db--entity->datoms
       (-reduce-from #'db--assert db)))

(defun db--tables-into-db (tables)
  (->> tables
       (-mapcat #'db--parse-org-table)
       (-reduce-from #'db--raw-entity-into-db db--empty-db)))

(defun db--load (table-refs)
  (require 'ob-ref)
  (db--tables-into-db
   (-map #'org-babel-ref-resolve table-refs)))
#+end_src
*** Serialize
#+begin_src elisp
(setq db--tokenize-keyword #'identity)

(setq db--tokenizers
      (kvm :db.type/keyword db--tokenize-keyword
           :db.type/string #'identity
           :db.type/boolean (lambda (v)
                              (if v 'true 'false))
           :db.type/symbol #'identity))

(defalias 'db--tokenize-attr #'db--tokenize-keyword)

(defun db--tokenize-value (db a v)
  (let* ((type (db--get-schema db a :db/valueType))
         (tokenizer (map-elt db--tokenizers type)))
    (funcall tokenizer v)))

(defun db--tokenize-datom (db datom)
  (let ((e (db--dget datom :datom/e))
        (a (db--dget datom :datom/a))
        (v (db--dget datom :datom/v)))
    (db--datom
     (db--tokenize-value db :db/id e)
     (db--tokenize-attr a)
     (db--tokenize-value db a v))))

(defalias 'db--serialize-fn (-partial #'format "%S"))

(defun db--spit (f content)
  (with-temp-file f
    (insert content)))

(defun db--serialize (file datoms)
  (with-temp-file file
    (->> datoms
         (-map (-partial #'tokenize-datom datoms))
         db--serialize-fn
         ;; db--pretty-print-db
         db--spit)))

;; TODO pretty-printing
;; https://emacs.stackexchange.com/questions/10382/perform-function-until-it-returns-user-error

;; (defmacro db--buffer->string (&rest body)
;;   `(with-temp-buffer
;;      ,@body
;;      (buffer-string)))

;; (defun db--pretty-print-db (s)
;;   (let ((delim "\n "))
;;     (dt--buffer->string
;;      (insert s)
;;      (goto-char (point-min))
;;      (forward-char)
;;      (condition-case _
;;          (while t
;;            (forward-sexp)
;;            (insert delim))
;;        (scan-error nil))
;;      (dotimes (_ (length delim))
;;        (backward-delete-char)))))
#+end_src
*** Deserialize
#+begin_src elisp
(setq db--marshall-keyword #'identity)

(setq db--marshallers
      (kvm :db.type/keyword db--marshall-keyword
           :db.type/string #'identity
           :db.type/boolean (lambda (token)
                              (pcase s
                                ('true t)
                                ('false nil)))
           :db.type/symbol #'identity))

(defalias 'db--marshall-attr #'db--marshall-keyword)

(defun db--marshall-value (db a v)
  (let* ((type (db--get-schema db a :db/valueType))
         (marshaller (map-elt db--marshallers type)))
    (funcall marshaller v)))

(defun db--marshall-datom (db tokenized-datom)
  (let ((e (db--dget tokenized-datom :datom/e))
        (a (db--dget tokenized-datom :datom/a))
        (v (db--dget tokenized-datom :datom/v)))
    (db--datom
     (db--marshall-value db :db/id e)
     (db--marshall-attr a)
     (db--marshall-value db a v))))

(defalias 'db--deserialize-fn #'read)

(defun db--slurp (f)
  (with-temp-buffer
    (insert-file-contents f)
    (buffer-string)))

(defun db--deserialize (file)
  (->> (db--slurp file)
       db--deserialize-fn
       (-map #'marshall-datom)))
#+end_src
*** \
#+begin_src elisp
(provide 'donnager-org)
#+end_src
** Dev
*** Git ignore
#+begin_src gitignore :tangle (meta-in-dir ".gitignore")
,*
#+end_src
* Utils
** Scheme
:PROPERTIES:
:meta-dir+: /mendicant
:END:
*** Utils
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "mendicant/utils.scm")
:END:
#+begin_src scheme
(define-module (mendicant utils)
  #:use-module ((guix inferior) #:select (inferior-for-channels lookup-inferior-packages))
  #:use-module (gnu services)
  #:use-module ((ice-9 match) #:select (match-lambda))
  #:use-module ((srfi srfi-1) #:select (take drop remove fold first))
  #:export (update-list
            when-let
            if-let
            when-not
            if-not
            partial
            ->
            ->>
            as->
            kvm
            get
            keys
            massoc
            merge
            keyvals
            update-services*
            update-services))

(define (update-list l pred f)
  (map (lambda (x)
         (if (pred x) (f x) x))
       l))
#+end_src
**** Branching
#+begin_src scheme
(define-syntax when-let
  (syntax-rules ()
    ((_ ((var expr)) body ...)
     (let ((var expr))
       (when var body ...)))))

(define-syntax if-let
  (syntax-rules ()
    ((_ ((var expr)) then else)
     (let ((var expr))
       (if var then else)))))

(define-syntax when-not
  (syntax-rules ()
    ((_ test body ...)
     (when (not test) body ...))))

(define-syntax if-not
  (syntax-rules ()
    ((_ test then else)
     (if (not test) then else))))
#+end_src
**** Functions
#+begin_src scheme
(define* (partial f #:rest args)
  (lambda* (#:rest more)
    (apply f (append args more))))

(define* (rpartial f #:rest args)
  (lambda* (#:rest more)
    (apply f (append more args))))

(define-syntax ->
  (syntax-rules ()
    ((_ value) value)
    ((_ value (f . body) next ...) (-> (f value . body) next ...))
    ((_ value f next ...) (-> (f value) next ...))))

(define (thread-last-helper f value . body)
  (apply f (append body (list value))))

(define-syntax ->>
  (syntax-rules ()
    ((_ value) value)
    ((_ value (f . body) next ...) (->> (thread-last-helper f value . body) next ...))
    ((_ value f next ...) (-> (f value) next ...))))

(define-syntax as->
  (syntax-rules ()
    ((_ expr name) expr)
    ((_ expr name form form* ...)
     (let ((name expr))
       (as-> form name form* ...)))))
#+end_src
**** Maps
#+begin_src scheme
(define* (kvm #:rest keyvals)
  (let loop ((m '())
             (more keyvals))
    (if (null? more)
        m
        (loop (cons (as-> more $
                          (take $ 2)
                          (apply cons $))
                    m)
              (drop more 2)))))

(define get assoc-ref)

(define (keys m)
  (map car m))

(define (massoc m k v)
  (->> m
       (remove (match-lambda
                 ((k1 . _)
                  (equal? k k1))))
       (cons '(k . v))))

(define* (merge #:rest maps)
  (fold
   (lambda (m1 m2)
     (fold
      (match-lambda
        (((k . v) res)
         (massoc res k v)))
      m1 m2))
   (kvm)
   maps))

(define (keyvals m)
  (->> m
       (map (match-lambda
              ((k . v)
               (list k v))))
       (apply append)))
#+end_src
**** Guix
#+begin_src scheme
(define (update-services* services pred update-fn)
  (update-list
   services
   pred
   (lambda (svc)
     (service (service-kind svc)
              (update-fn (service-value svc))))))

(define (update-services services kind update-fn)
  (update-services*
   services
   (lambda (svc)
     (eq? (service-kind svc) kind))
   update-fn))

(define (get-inferior-package channels package)
  (-> (inferior-for-channels channels)
      (lookup-inferior-packages package)
      first))
#+end_src
*** Dev
**** Git ignore
#+begin_src gitignore :tangle (meta-in-dir ".gitignore")
,*
#+end_src
** Emacs Lisp
:PROPERTIES:
:meta-dir+: /tangential
:END:
*** Utils
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "utils.el")
:END:
#+begin_src elisp
(defun kvm (&rest keyvals)
  (->> keyvals
       (-partition 2)
       (-map (-lambda ((a b))
               (cons a b)))))

(provide 'tangential)
#+end_src
*** Dev
**** Git ignore
#+begin_src gitignore :tangle (meta-in-dir ".gitignore")
,*
#+end_src
* Configurations
:PROPERTIES:
:meta-dir+: /exuberant
:END:
#+name: db/systems-common
| =:db/id=          | =:system/features=                              |
|-------------------+-------------------------------------------------|
| :system/frostfire | :feature/nix :feature/desktop :feature/pipewire |

#+name: db/users-common
| =:db/id=      | =:entity/channel-deps= | =:user/full-name=      | =:user/login-shell= | =:user/sessions=             |
|---------------+------------------------+------------------------+---------------------+------------------------------|
| :user/primary | :channel/nonguix       | Krzysztof Baranowski   | :shell/default      | :session/gnome :session/sway |
| :user/aux     | :channel/nonguix       | Phil Coulson           | :shell/default      | :session/gnome :session/sway |
| :user/guest   | :channel/nonguix       | Speak Friend and Enter | :shell/default      | :session/gnome               |

** Operating systems
:PROPERTIES:
:meta-dir+: /exuberant/os
:END:
#+name: db/users-system
| =:db/id=      | =:user/username= | =:user/admin?= | =:user/password= |
|---------------+------------------+----------------+------------------|
| :user/primary | pharcosyle       | true           |                  |
| :user/aux     | pcoulson         | true           |                  |
| :user/guest   | gandalf          |                | mellon           |

*** Frostfire
#+name: db/systems-frostfire
| =:db/id=          | =:system/features=                                                                  |
|-------------------+-------------------------------------------------------------------------------------|
| :system/frostfire | :feature/linux-nonfree :feature/disk-encryption :feature/stateless :feature/macbook |

#+begin_src scheme :tangle (meta-in-dir "frostfire.scm") :noweb yes
(define-module (exuberant os frostfire)
  #:use-module (ebullient system base-os))

(define-public os
  (base-os #:system #:system/frostfire
           #:host-name "frostfire"
           #:timezone "America/Los_Angeles"
           #:accounts '(#:user/primary
                        #:user/aux
                        #:user/guest)
           #:luks-uuid "<<frostfire-luks-uuid>>"
           ;; #:auto-login-account #:user/primary ; REVIEW Enable this later.
           #:console? #t
           #:laptop? #t
           #:bluetooth? #t))
#+end_src
**** Channel deps
#+begin_src scheme :tangle (meta-in-dir "frostfire-channels")
(use-modules (ebullient system channels))

(get-system-channels
 (system-channel-deps #:system/frostfire))
#+end_src
**** Channels lock :version:
#+begin_src scheme :tangle (meta-in-dir "frostfire-channels-lock")
(list (channel
        (name 'guix)
        (url "https://git.savannah.gnu.org/git/guix.git")
        (branch "master")
        (commit
          "85f026f36ae93ac3ce3fa50150848eab9b31b69f")
        (introduction
          (make-channel-introduction
            "9edb3f66fd807b096b48283debdcddccfea34bad"
            (openpgp-fingerprint
              "BBB0 2DDF 2CEA F6A8 0D1D  E643 A2A0 6DF2 A33A 54FA"))))
      (channel
        (name 'nonguix)
        (url "https://gitlab.com/nonguix/nonguix")
        (branch "master")
        (commit
          "35533c763a81365e14d0b58ad262e8f88c82872c")
        (introduction
          (make-channel-introduction
            "897c1a470da759236cc11798f4e0a5f7d4d59fbc"
            (openpgp-fingerprint
              "2A39 3FFF 68F4 EF7A 3D29  12AF 6F51 20A0 22FB B2D5")))))
#+end_src
**** LUKS UUID :external_state:
#+name: frostfire-luks-uuid
#+begin_src org
bdda56af-6ca0-4953-bc13-d5af8715e0e5
#+end_src
** Home environments
:PROPERTIES:
:meta-dir+: /exuberant/he
:END:
#+name: db/users-home
| =:db/id=      | =:entity/channel-deps= | =:user/email=            |
|---------------+------------------------+--------------------------|
| :user/primary | :channel/flat          | pharcosyle@gmail.com     |
| :user/aux     | :channel/flat          | pharcosyle+aux@gmail.com |

*** Solitude
#+begin_src scheme :tangle (meta-in-dir "solitude.scm")
(define-module (exuberant he solitude)
  #:use-module (ebullient home base-he)
  #:export (he))

(define-public he
  (base-he #:system #:system/frostfire
           #:account #:user/primary
           #:developer? #t))
#+end_src
**** Solitude old WIP
#+begin_src scheme
(define-module (exuberant he solitude)
  #:use-module (ebullient home base-he)
  #:export (he))

(define he
  (home-environment
   (packages (list ;; (specification->package "font-adobe-source-code-pro")
                   (specification->package "font-awesome") ; TODO for waybar, move this somewhere later
                   (specification->package "font-google-noto") ; TODO for sway (or any non-DE probably)
                   ))
   (services
    (list
     (service gammastep-service-type)
     (service network-manager-service-type)
     (service udiskie-service-type)

     (service home-xdg-user-directories-service-type
              (let* ((xdg-user-subdir "/files")
                     (xdg-dir (lambda (path)
                                (string-append "$HOME" xdg-user-subdir path))))
                (home-xdg-user-directories-configuration
                 (desktop "$HOME/desktop")
                 (documents (xdg-dir "/docs"))
                 (download "$HOME/dl")
                 (music (xdg-dir "/music"))
                 (pictures (xdg-dir "/pics"))
                 (publicshare (xdg-dir "/public"))
                 (templates (xdg-dir "/templates"))
                 (videos (xdg-dir "/vids")))))

     (service home-mcron-service-type
              (home-mcron-configuration
               (jobs
                (list
                 #~(job '(next-hour)
                        (lambda ()
                          (call-with-output-file "/tmp/test-mcron-file"
                            (lambda (port)
                              (display "Output!" port))))
                        "Test mcron output")))))
     (service home-git-service-type
              (home-git-configuration
               (config
                `((user
                   ((name . "Krzysztof Baranowski") ; FIXME <user-full-name>>
                    (email . "pharcosyle@gmail.com"))) ; FIXME <user-email>>
                  ;; (http "https://weak.example.com"
                  ;;   ((ssl-verify . #f)))
                  ;; (gpg
                  ;;  ((program . ,(file-append gnupg "/bin/gpg"))))
                  ;; (sendmail
                  ;;  ((annotate . #t)))
                  ))))
     ;; [2022-06-18 Sat] TODO compare with the new home-openssh-service-type: https://guix.gnu.org/manual/devel/en/guix.html#Secure-Shell
     (service home-ssh-service-type
              ;; (home-ssh-configuration
              ;;  (extra-config
              ;;   (list
              ;;    (ssh-host "savannah"
              ;;              '((compression . #f))))))
              )


     ;; TODO Examples from RDE I may want to make use of.
     ;; (service home-keyboard-service-type
     ;;          (keyboard-layout "us,ru" "dvorak,"
     ;;                           #:options '("grp:win_space_toggle" "ctrl:nocaps")))
     ;; (service home-gnupg-service-type
     ;;          (home-gnupg-configuration
     ;;           (gpg-agent-config
     ;;            (home-gpg-agent-configuration
     ;;             (ssh-agent? #t)))))
     ;; (service home-state-service-type
     ;;          (append
     ;;           (list
     ;;            (state-rsync "/home/bob/tmp/example-rsync-state/"
     ;;                         "abcdw@olorin.lan:/var/services/homes/abcdw/tmp-state/")
     ;;            (state-git "/home/bob/tmp/talkes/"
     ;;                       "git@git.sr.ht:~abcdw/rde"))))
     ))))
#+end_src
**** Channel deps
#+begin_src scheme :tangle (meta-in-dir "solitude-channels")
(use-modules (ebullient home channels))

(get-home-channels
 (user-channel-deps #:user/primary))
#+end_src
**** Channels lock
#+begin_src scheme :tangle (meta-in-dir "solitude-channels-lock")
(list (channel
        (name 'guix)
        (url "https://git.savannah.gnu.org/git/guix.git")
        (branch "master")
        (commit
          "04ac1a248c188e4e49e6372e8336c31d32d1c96e")
        (introduction
          (make-channel-introduction
            "9edb3f66fd807b096b48283debdcddccfea34bad"
            (openpgp-fingerprint
              "BBB0 2DDF 2CEA F6A8 0D1D  E643 A2A0 6DF2 A33A 54FA"))))
      (channel
        (name 'flat)
        (url "https://github.com/flatwhatson/guix-channel.git")
        (branch "master")
        (commit
          "ece373bcd1e00ef746fb7b104e56ab610cc4af2a")
        (introduction
          (make-channel-introduction
            "33f86a4b48205c0dc19d7c036c85393f0766f806"
            (openpgp-fingerprint
              "736A C00E 1254 378B A982  7AF6 9DBE 8265 81B6 4490"))))
      (channel
        (name 'rde)
        (url "https://git.sr.ht/~abcdw/rde")
        (branch "master")
        (commit
          "520e1429593c2daf4a296a9ea55c4aa32848b491")
        (introduction
          (make-channel-introduction
            "257cebd587b66e4d865b3537a9a88cccd7107c95"
            (openpgp-fingerprint
              "2841 9AC6 5038 7440 C7E9  2FFA 2208 D209 58C1 DEB0"))))
      (channel
        (name 'nonguix)
        (url "https://gitlab.com/nonguix/nonguix")
        (branch "master")
        (commit
          "35533c763a81365e14d0b58ad262e8f88c82872c")
        (introduction
          (make-channel-introduction
            "897c1a470da759236cc11798f4e0a5f7d4d59fbc"
            (openpgp-fingerprint
              "2A39 3FFF 68F4 EF7A 3D29  12AF 6F51 20A0 22FB B2D5")))))
#+end_src
**** Dotfiles
- TODO move the "Dotfiles" headline somewhere better later?

#+name: db/palette
| =:db/id=                 | =:color/hex= |
|--------------------------+--------------|
| :color/fg                | #dee2f8      |
| :color/highlight         | #8496ff      |
| :color/comments          | #63677f      |
| :color/comment-delimiter | #939abd      |
| :color/red               | #fb8578      |
| :color/orange            | #fdce5f      |
| :color/green             | #9fed9c      |
| :color/yellow            | #eddc91      |
| :color/blue              | #7db9fe      |
| :color/dark-blue         | #5f68de      |
| :color/magenta           | #e29bf7      |
| :color/violet            | #aeb9f3      |
| :color/cyan              | #75e0f9      |
| :color/gold              | #fdd94a      |
| :color/pink              | #ff9999      |

- FIXME remove this
#+name: palette
| Name              | Color   |
|-------------------+---------|
| fg                | #dee2f8 |
| highlight         | #8496ff |
| comments          | #63677f |
| comment-delimiter | #939abd |
| red               | #fb8578 |
| orange            | #fdce5f |
| green             | #9fed9c |
| yellow            | #eddc91 |
| blue              | #7db9fe |
| dark-blue         | #5f68de |
| magenta           | #e29bf7 |
| violet            | #aeb9f3 |
| cyan              | #75e0f9 |
| gold              | #fdd94a |
| pink              | #ff9999 |

***** Doom private
:PROPERTIES:
:meta-dir+: /doom-private
:END:
****** Init
#+begin_src elisp :tangle (meta-in-dir "init.el")
;;; -*- lexical-binding: t; -*-

(doom! :completion
       (company +childframe)
       (vertico +icons)

       :ui
       doom
       doom-dashboard
       (emoji +unicode)
       hl-todo
       hydra
       indent-guides
       (ligatures +extra)
       modeline
       nav-flash
       ophints
       (popup +defaults +all)
       tabs
       treemacs
       vc-gutter
       vi-tilde-fringe
       window-select
       workspaces

       :editor
       (evil +everywhere)
       file-templates
       fold
       format
       lispy
       multiple-cursors
       rotate-text
       snippets
       word-wrap

       :emacs
       (dired +icons)
       electric
       (ibuffer +icons)
       undo
       vc

       :term
       eshell
       vterm

       :checkers
       (syntax +childframe)

       :tools
       direnv ; TODO should be contributed by direnv component
       (eval +overlay)
       lookup
       (magit +forge)
       (pass +auth)
       pdf
       prodigy ; TODO dependency of hyperdrive. Keep it enabled by default too.
       rgb
       taskrunner

       :lang
       clojure ; TODO contribute this with some Clojure module/compnent /if I end up having one/ (maybe along with the WIP clojure manifest)
       common-lisp ; TODO this should be contributed by Nyxt / my eventual nyxt project
       data
       emacs-lisp
       json
       javascript
       markdown
       nix ; TODO this should be gated by Nix inclusion like system components do.
       (org +journal)
       rest
       (scheme +guile) ; TODO Should be contributed by some Guix component (also the guix-related packages.el entries and stuff in config)
       sh
       web
       yaml ; TODO this should probably be specific to the krush/hyperdrive/afterburner(?) project

       :app
       calendar

       :config
       (default +bindings +smartparens))
#+end_src
****** Config
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "config.el")
:END:
#+begin_src elisp
;;; -*- lexical-binding: t; -*-

(use-package! dash)
(use-package! s)
#+end_src
******* Personal Info :user:
#+begin_src elisp :noweb yes
(setq user-full-name "Krzysztof Baranowski" ; FIXME <user-full-name>>
      user-mail-address "pharcosyle@gmail.com") ; FIXME <user-email>>
#+end_src
******* Locals :path:
#+begin_src elisp
(defconst biome--org-dir (concat org-directory "~/org"))
(defconst biome--org-gcal-dir (concat biome--org-dir "/gcal"))

(defconst biome--very-big 1000000)

(defconst biome--theme 'doom-nuclear)
#+end_src
#+begin_src elisp :var palette=palette
(defun biome--color (color)
  (let ((k (-> color symbol-name (substring 1))))
    (cadr (assoc k palette))))
#+end_src
******* General :UI:path:
#+begin_src elisp
;; hlissner says this must be set before org loads. I'm not sure if this is a requirement of org-mode but the Doom org config certainly does a lot of gymnastics with this variable so I'll just set this exactly like the example config does.
(setq org-directory biome--org-dir)

(setq scroll-margin 10
      save-interprogram-paste-before-kill t)

;; I like having line numbers on but hlissner says they're slow so I might want to disable them at some point. Keep in mind I use them to determine what lines are continuation lines so I might have to make the right fringe bigger if I do this and set visual-line-fringe-indicators.
;; (setq display-line-numbers-type nil)
#+end_src
******** Doom resets
#+begin_src elisp
(setq-default indent-tabs-mode t)

;; I'd like to have this on but in the Doom code it says it's more efficient not to.
;; (setq-default cursor-in-non-selected-windows t)
#+end_src
******** Doom
#+begin_src elisp
;; REVIEW Might be useful if there end up being a lot more of these and they have a lot of similarities: https://www.gnu.org/software/emacs/manual/html_node/elisp/Extending-Rx.html
(add-hook! 'doom-real-buffer-functions
  ;; (defun biome-new-buffer-p (buf)
  ;;   (s-matches?
  ;;    (rx bol "*new*"
  ;;        (* "<" (+ digit) ">")
  ;;        eol)
  ;;    (buffer-name buf)))
  ;; TODO This should be in my Org config section / module but wait to move it until I'm confident I'll be continuing with this marking-buffers-as-real approach.
  (defun biome-org-src-edit-buffer-p (buf)
    (s-matches?
     (rx bol "*Org Src " (+ anything) "*"
         (* "<" (+ digit) ">")
         eol)
     (buffer-name buf))))
#+end_src
******* Keybindings :bindings:
#+begin_src elisp
(setq help-char (string-to-char "\C-_"))
#+end_src
******** Translations
#+begin_src elisp
(defun biome--trans (&rest rest)
  (-each (-partition 2 rest)
    (-lambda ((to from))
      (define-key key-translation-map (kbd to) (kbd from)))))

(biome--trans "C-h" "DEL"
              "C-?" "C-h"

              "s-h" "<left>"
              "s-j" "<down>"
              "s-k" "<up>"
              "s-l" "<right>")
#+end_src
******** Leader/localleader
#+begin_src elisp
(setq doom-leader-alt-key "s-SPC"
      doom-localleader-key "s-m"
      doom-localleader-alt-key "s-m")
#+end_src
******** General
#+begin_src elisp
(defalias 'original-yank-pop #'yank-pop)

;; REVIEW Some of these should be in `:after' (or their respective package) sections but I'm not totally certain where I want to put bindings yet and I'm lazy.
(map! "s-V" #'original-yank-pop

      "s-SPC" doom-leader-map

      ;; Adapted from Doom macOS bindings: ~/.config/emacs/modules/config/default/config.el:263
      "s-`" #'other-frame
      "s-n" #'+default/new-buffer
      "s-z" #'undo
      "s-Z" #'redo
      "s-c" (if (featurep 'evil) #'evil-yank #'copy-region-as-kill)
      "s-v" #'yank
      "s-s" #'save-buffer
      "s-x" #'execute-extended-command
      ;; REVIEW I don't think I need this, any time I'm in visual mode I can use `evil-delete` ("d")
      ;; :v "s-x" #'kill-region
      "s-/" (cmd! (save-excursion (comment-line 1)))
      :n "s-/" #'evilnc-comment-or-uncomment-lines
      :v "s-/" #'evilnc-comment-operator

      "s-t" (lookup-key doom-leader-map (kbd "`"))
      "s-f" (lookup-key doom-leader-map (kbd "s b"))
      "s-r" (lookup-key doom-leader-map (kbd "f r"))
      "s-w" (lookup-key doom-leader-map (kbd "b k"))
      "s-d w" (lookup-key doom-leader-map (kbd "w d"))
      "s-d s-w" (cmd! (kill-current-buffer)
                      (+workspace/close-window-or-workspace))
      "s-g" (lookup-key doom-leader-map (kbd "g g"))
      "s-," (lookup-key doom-leader-map (kbd "w w"))
      "s-<" (lookup-key doom-leader-map (kbd "w W"))
      "s-y" (lookup-key doom-leader-map (kbd "i y"))
      "s-{" (lookup-key doom-leader-map (kbd "b p"))
      "s-}" (lookup-key doom-leader-map (kbd "b n"))
      "s-p" (lookup-key global-map (kbd "C-~")) ; TODO if I'm keeping this, improve it to first switch focus to a/the popup window if one isn't focused already

      "s-u" (lookup-key doom-leader-map (kbd "u"))
      "s-U" #'negative-argument         ; Trying this out.
      (:map universal-argument-map
       "s-u" #'universal-argument-more)

      (:after evil-easymotion
       "s-a" (lookup-key evilem-map (kbd "SPC")))

      "s-." #'repeat

      "s-J" #'evil-scroll-down
      "s-K" #'evil-scroll-up

      (:prefix "s-d"
       "." #'repeat-complex-command

       "h" #'git-gutter:popup-hunk
       ;; "o" #'+macos/open-in-default-program ;; TODO consider a Guix alternative? Meh.
       "r" #'projectile-replace
       "t" #'tldr
       "s" #'org-save-all-org-buffers
       "a" #'link-hint-open-multiple-links
       ;; "b" (cmd! (evil-local-mode 'toggle)
       ;;           (when evil-local-mode (evil-normal-state)))
       (:prefix "c"
        "f" #'org-gcal-fetch
        "s" #'org-gcal-sync
        "p" #'org-gcal-post-at-point)))
#+end_src
******* Modules
******** Completion
********* Vertico
********** vertico
#+begin_src elisp
(after! vertico
  (map! :map vertico-map
        "DEL" #'vertico-directory-delete-char))
#+end_src
******** UI
********* Doom
********** doom-themes
- TODO get rid of this if I'm not going to try it out again
#+begin_src elisp
;; (after! doom-themes
;;   (doom-themes-visual-bell-config))
#+end_src
********* Modeline
********** doom-modeline
#+begin_src elisp
(after! doom-modeline
  ;; (setq doom-modeline-checker-simple-format nil)
  (setq doom-modeline-major-mode-icon t)
  (setq doom-modeline-persp-name t))
#+end_src
********* Indent Guides
********** highlight-indent-guides :prog_mode:
#+begin_src elisp
(use-package! highlight-indent-guides
  :defer t
  :init
  ;; I don't want indent guides on by default, remove all the Doom module's hooks.
  (remove-hook! '(prog-mode-hook
                  text-mode-hook
                  conf-mode-hook)
    #'highlight-indent-guides-mode))
#+end_src
********* Ligatures
********** ligature
#+begin_src elisp :tangle (meta-in-dir "init.el")
(use-package-hook! ligature
  :pre-config
  (setq +ligatures-all-modes-list
        '("www")
        +ligatures-prog-mode-list
        '(;; Fira Code (from https://github.com/tonsky/FiraCode/wiki/Emacs-instructions#using-ligatureel)
          "**" "***" "**/" "*>" "*/" "\\\\" "\\\\\\" "{-" "::"
          ":::" ":=" "!!" "!=" "!==" "-}" "----" "-->" "->" "->>"
          "-<" "-<<" "-~" "#{" "#[" "##" "###" "####" "#(" "#?" "#_"
          "#_(" ".-" ".=" ".." "..<" "..." "?=" "??" ";;" "/*" "/**"
          "/=" "/==" "/>" "//" "///" "&&" "||" "||=" "|=" "|>" "^=" "$>"
          "++" "+++" "+>" "=:=" "==" "===" "==>" "=>" "=>>" "<="
          "=<<" "=/=" ">-" ">=" ">=>" ">>" ">>-" ">>=" ">>>" "<*"
          "<*>" "<|" "<|>" "<$" "<$>" "<!--" "<-" "<--" "<->" "<+"
          "<+>" "<=" "<==" "<=>" "<=<" "<>" "<<" "<<-" "<<=" "<<<"
          "<~" "<~~" "</" "</>" "~@" "~-" "~>" "~~" "~~>" "%%"
          ;; Doom defaults (just the ones not already present in Fira Code)
          "|||>" "<|||" "<==>" "||>" "::=" "=!=" "!!." ">->" "---" "<~>"
          "<||" "<-<" "_|_" "~=" "|}" "|]" "|-" "{|" "[|" "]#" ":>" ":<"
          ">:" "-|" "--" "<:" "#:" "#=" "#!" ".?" "?:" "?." "__" "(*"
          "*)" "://"))
  t)
#+end_src
******** Editor
********* Evil
********** evil :bindings:theming:
#+begin_src elisp
(after! evil
  (defun biome--set-theme-cursor-color-symbols ()
    (put 'cursor 'evil-normal-color (biome--color :gold))
    (put 'cursor 'evil-emacs-color  (biome--color :pink)))

  (defadvice! biome-update-cursor-color-a (&rest _)
    :after #'+evil-update-cursor-color-h
    (when (memq biome--theme custom-enabled-themes)
      (biome--set-theme-cursor-color-symbols)))

  (map! :m [C-i] nil)) ; Remove Doom's binding for `evil-jump-forward'.
#+end_src
********* Multiple Cursors
********** evil-multiedit :evil:
#+begin_src elisp
(after! evil-multiedit
  (setq evil-multiedit-follow-matches t))
#+end_src
********* Lisp
********** lispy
#+begin_src elisp
(use-package! lispy
  :defer t
  :init
  ;; Not using lispy, remove all the Doom module's hooks.
  (remove-hook! '(lisp-mode-hook
                  emacs-lisp-mode-hook
                  ielm-mode-hook
                  scheme-mode-hook
                  racket-mode-hook
                  hy-mode-hook
                  lfe-mode-hook
                  dune-mode-hook
                  clojure-mode-hook
                  fennel-mode-hook)
    #'lispy-mode)
  (remove-hook! 'eval-expression-minibuffer-setup-hook #'doom-init-lispy-in-eval-expression-h))
#+end_src
********** lispyville :prog_mode:bindings:
#+begin_src elisp
(use-package! lispyville
  :hook (prog-mode . lispyville-mode)
  :init
  (setq lispyville-key-theme nil) ; Prevent Doom module's invocation of `lispyville-set-key-theme' from doing anything.
  :config
  (lispyville-set-key-theme
   '(operators
     c-w
     c-u
     commentary))
  (map! :map lispyville-mode-map
        "C-s-j" #'lispyville-beginning-of-next-defun
        "C-s-k" #'lispyville-beginning-of-defun
        "C-s-," #'lispyville-end-of-defun
        "C-s-a" #'lispyville-drag-backward
        "C-s-g" #'lispyville-drag-forward
        "C-s-p" #'lispyville-prettify
        (:prefix "C-s-;"
         "R" #'lispyville-raise-list)))
#+end_src
******** Emacs
********* Dired
********** dired-x :UI:hidden:
Don't hide files in dired, remove the Doom module's hook. However, via the Doom config dired-x is only loaded when ~dired-omit-mode~ is triggered so add another hook that mimics this (loads dired-x after the first use of dired). A simple =:after= would probably be fine too (and less odd) but this is lazier.
- TODO dired buffers always marked modified
  *wait to do this until I do my dired project*
  Removing the ~dired-omit-mode~ hook causes dired buffers to start off marked as modified. I don't think this was happening until I upgraded to Emacs 29 so maybe this will resolve itself on a later Emacs upgrade.
  - although even before this started happenning I recall dired buffers being marked modified and annoying to close irritating me. I don't know why I'd want that behavior to begin with but I suspect there are good reasons.
    Some remarks on modified dired buffers: [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Auto-Reverting-Dired.html]]
#+begin_src elisp
(use-package! dired-x
  :defer t
  :init
  (remove-hook! 'dired-mode-hook #'dired-omit-mode)
  (add-hook! 'dired-mode-hook
    (defun require-dired-x-h ()
      (require 'dired-x))))
#+end_src
******** Term
********* eshell :persistence:
#+begin_src elisp
(after! eshell
  (setq eshell-history-size biome--very-big)) ; Setting this to `nil' to inherit envvar HISTSIZE is another option.
#+end_src
******** Tools
********* Magit
********** magit :UI:
#+begin_src elisp
(after! magit
  (setq git-commit-style-convention-checks '(non-empty-second-line))
  (setq magit-revision-show-gravatars '("^Author:     " . "^Commit:     ")))
#+end_src
******** Lang
********* Clojure
********** clojure :bindings:theming:
#+begin_src elisp
(use-package! clojure-mode
  :defer t
  :init
  (setq clojure-refactor-map-prefix (kbd "s-M r")) ; Has to be set before clojure-mode loads. ; REVIEW temporary binding
  :config
  (set-ligatures! 'clojure-mode :lambda "fn")
  (custom-theme-set-faces! biome--theme
    `(clojure-character-face :foreground ,(doom-color 'violet) :weight bold)))
#+end_src
********** cider :persistence:
#+begin_src elisp
(after! cider
  (setq cider-repl-history-size biome--very-big
        cider-print-options '(("length" 100))))

;; REVIEW make sure this is still working after nesting in `after!'
(after! cider-repl
  (add-hook! 'cider-repl-mode-hook
             #'goto-address-prog-mode
             #'highlight-numbers-mode
             #'rainbow-delimiters-mode
             #'yas-minor-mode-on
             #'biome-sp-strict-h))
#+end_src
********** clj-refactor :bindings:
#+begin_src elisp
(after! clj-refactor
  (cljr-add-keybindings-with-prefix "s-M R")) ; REVIEW temporary binding
#+end_src
********* Emacs Lisp
********** emacs-lisp
#+begin_src elisp
(after! elisp-mode
  (setq-hook! 'emacs-lisp-mode-hook indent-tabs-mode nil))
#+end_src
********* Org
********** org :UI:path:theming:
#+begin_src elisp
(after! org
  (setq org-agenda-files `(,biome--org-dir
                           ,biome--org-gcal-dir
                           ,(concat biome--org-dir "/projects"))
        org-log-done 'time
        org-priority-lowest ?E
        org-priority-default ?C
        org-priority-faces `((?A . ,(doom-color 'red))
                             (?B . ,(doom-color 'orange))
                             (?C . ,(doom-color 'blue))
                             (?D . ,(doom-color 'yellow))
                             (?E . ,(doom-color 'green)))))
#+end_src
********** ob
#+begin_src elisp
(after! ob
  (setq org-babel-noweb-error-all-langs t))
#+end_src
********** evil-org :evil:bindings:
#+begin_src elisp
(after! evil-org
  (map! :map evil-org-mode-map
        :nv "C-j" #'outline-forward-same-level
        :nv "C-k" #'outline-backward-same-level))
#+end_src
********* Scheme
********** scheme
#+begin_src elisp
(after! scheme
  (setq-hook! 'scheme-mode-hook indent-tabs-mode nil))
#+end_src
********** geiser :persistence:path:guix:
Use ~:init~ to configure variables (as opposed to ~:config~, which seems like it'd be fine) because hlissner does it this way for the Geiser package so I will too.
#+begin_src elisp
(use-package! geiser
  :defer t
  :init
  (setq geiser-repl-current-project-function #'ignore) ; Reset this back to its default (don't have separate REPLs for projects) because it doesn't play nice with the Guix store.
  (setq geiser-repl-history-filename (concat doom-cache-dir "geiser-history")))
#+end_src
******** App
********* Calendar
********** org-gcal :org:user:secret:persistence:path:
#+begin_src elisp
(after! org-gcal
  (setq org-gcal-client-id "446729771716-pp79934q99aro2h8v3iki1fejcodbdoo.apps.googleusercontent.com"
        org-gcal-client-secret (-> (auth-source-search :host org-gcal-client-id) car (plist-get :secret) funcall)
        org-gcal-fetch-file-alist `((user-mail-address . ,(concat biome--org-gcal-dir "/" user-mail-address ".org"))
                                    ("addressbook%23contacts@group.v.calendar.google.com" . ,(concat biome--org-gcal-dir "/contacts.org"))
                                    ("en.usa%23holiday@group.v.calendar.google.com" . ,(concat biome--org-gcal-dir "/holidays.org")))
        org-gcal-recurring-events-mode 'nested))
#+end_src
******** Config
********* expand-region :bindings:
#+begin_src elisp
(use-package! expand-region
  :defer t
  :init
  (map! :nv "s-e" #'er/expand-region
        :nv "s-E" #'er/contract-region)
  :config
  (setq expand-region-fast-keys-enabled nil) ; My mapping is conventient enough and I don't want the repeat key to conflict with anything.
  ;; Copied from Doom config: ~/.config/emacs/modules/config/default/+emacs.el:12
  (defadvice! biome--quit-expand-region-a (&rest _)
    "Properly abort an expand-region region."
    :before '(evil-escape doom/escape)
    (when (memq last-command '(er/expand-region er/contract-region))
      (er/contract-region 0))))
#+end_src
******** Guix
********* guix.el
********** guix :UI:
#+begin_src elisp
(after! guix
  (set-popup-rules!
    '(("^\\*Guix" :height 0.5))))
#+end_src
********** guix-devel :scheme:
#+begin_src elisp
(use-package! guix-devel
  :hook (scheme-mode . guix-devel-mode))
#+end_src
********** guix-popup :bindings:
#+begin_src elisp
(use-package! guix-popup
  :defer t
  :init
  (map! :leader
        "l" #'guix))  ; REVIEW temporary binding?
#+end_src
********** guix-prettify :UI:
#+begin_src elisp
(use-package! guix-prettify
  :hook (doom-first-buffer . global-guix-prettify-mode))
#+end_src
********* guix-contributing
#+begin_src elisp
;; TODO once I'm done packaging Doom figure out how to enable this
;; (use-package! guix-contributing)
#+end_src
********* guix-packaging :persistence:path:
#+begin_src elisp
(use-package! guix-packaging
  :defer t
  :init
  (setq guix-packaging--data-dir (concat doom-cache-dir "guix-packaging")))
#+end_src
******** ?
********* avy
#+begin_src elisp
;; REVIEW Trying out not having this so I can use avy dispatch commands.
;; (after! avy
;;   (setq avy-single-candidate-jump t))
#+end_src
********* paren :UI:
#+begin_src elisp
(after! paren
  (setq! show-paren-delay 0))
#+end_src
********* prog-mode :prog_mode:
#+begin_src elisp
(add-hook! 'prog-mode-hook #'biome-sp-strict-h)
#+end_src
********* rainbow-delimiters :theming:
#+begin_src elisp
(after! rainbow-delimiters
  (let ((default-max rainbow-delimiters-max-face-count))
    (defun biome-set-rainbow-delimiters-max-face-count ()
      (setq rainbow-delimiters-max-face-count
            (if (memq biome--theme custom-enabled-themes)
                8 default-max))))

  (biome-set-rainbow-delimiters-max-face-count)
  (add-hook! 'doom-load-theme-hook #'biome-set-rainbow-delimiters-max-face-count)

  (custom-theme-set-faces! biome--theme
    `(rainbow-delimiters-depth-1-face :foreground ,(doom-color 'fg))
    `(rainbow-delimiters-depth-2-face :foreground ,(doom-color 'magenta))
    `(rainbow-delimiters-depth-3-face :foreground ,(doom-color 'blue))
    `(rainbow-delimiters-depth-4-face :foreground ,(doom-color 'cyan))
    `(rainbow-delimiters-depth-5-face :foreground ,(doom-color 'green))
    `(rainbow-delimiters-depth-6-face :foreground ,(doom-color 'yellow))
    `(rainbow-delimiters-depth-7-face :foreground ,(doom-color 'orange))
    `(rainbow-delimiters-depth-8-face :foreground ,(doom-color 'red))))
#+end_src
********* recentf :persistence:
#+begin_src elisp
(after! recentf
  (setq recentf-max-saved-items 500))
#+end_src
********* smartparens :bindings:
#+begin_src elisp
(after! smartparens
  (map! :map smartparens-mode-map
        "C-s-h" #'sp-backward-sexp
        "C-s-l" #'sp-forward-sexp
        "C-s-u" #'sp-backward-up-sexp
        "C-s-o" #'sp-up-sexp
        :gn "C-s-m" #'sp-backward-down-sexp ; Bind in normal mode explicitly to override the Doom mapping in ~/.config/emacs/modules/config/default/config.el:447
        "C-s-." #'sp-down-sexp
        "C-s-c" #'sp-splice-sexp
        "C-s-s" #'sp-splice-sexp-killing-backward
        "C-s-f" #'sp-splice-sexp-killing-forward
        "C-s-x" #'sp-backward-slurp-sexp
        "C-s-v" #'sp-forward-slurp-sexp
        "C-s-w" #'sp-backward-barf-sexp
        "C-s-r" #'sp-forward-barf-sexp
        (:prefix "C-s-;"
         "(" #'sp-wrap-round
         "[" #'sp-wrap-square
         "{" #'sp-wrap-curly
         "s" #'sp-split-sexp
         "j" #'sp-join-sexp
         "r" #'sp-raise-sexp
         "c" #'sp-convolute-sexp
         "w" #'sp-rewrap-sexp)))
#+end_src
********** Hook :bindings:
#+begin_src elisp
(defun biome-sp-strict-h ()
  (add-hook! 'smartparens-enabled-hook :local
             #'turn-on-smartparens-strict-mode
             (defun biome-modify-sp-strict-mode-map-h ()
               (map! :map smartparens-strict-mode-map
                     :i "DEL" #'sp-backward-delete-char))))
#+end_src
********* transient :persistence:
- TODO Not sure where this should be categorized, it's a helper package required by at least magit, forge, git-timemachine
#+begin_src elisp
(after! transient
  (setq transient-history-limit biome--very-big))
#+end_src
********* undo-fu
#+begin_src elisp
(after! undo-fu
  (setq undo-fu-ignore-keyboard-quit t))
#+end_src
********* undo-tree :UI:
#+begin_src elisp
;; (after! undo-tree
;;   (setq undo-tree-visualizer-timestamps t))
#+end_src
********* emojify :UI:
#+begin_src elisp
(after! emojify
  (setq emojify-display-style 'unicode))
#+end_src
********* asdf :bindings:
- TODO donno where this should go, ~+default-minibuffer-maps~ is a doom thing I guess
#+begin_src elisp
(define-key! :keymaps +default-minibuffer-maps
  "s-J" #'scroll-up-command
  "s-K" #'scroll-down-command)
#+end_src
******* Theming :theming:
#+begin_src elisp
(setq doom-theme biome--theme)

(custom-theme-set-faces! biome--theme
  `(font-lock-comment-delimiter-face :foreground ,(biome--color :comment-delimiter))
  `(font-lock-doc-face :foreground ,(doom-color 'cyan)))
#+end_src
******** Font
#+begin_src elisp
(let ((font (font-spec :family "LigaSrc Pro" :size 12)))
  (when (find-font font)
    (setq doom-font font)))
#+end_src
******** Nuclear Theme

#+call: gen-doom-theme() :results code :post unescape(*this*) :results_switches ":tangle (meta-in-dir \"themes/doom-nuclear-theme.el\")"

#+RESULTS:
#+begin_src elisp :tangle (meta-in-dir "themes/doom-nuclear-theme.el")
;;; nuclear-theme.el --- inspired by Atom One Dark -*- lexical-binding: t; no-byte-compile: t; -*-
;;
;;
;;
;;; Commentary:
;;
;; Inspired by Atom's One Dark color scheme.
;;
;;; Code:

(require 'doom-themes)


;;
;;; Variables

(defgroup nuclear-theme nil
  "Options for the `nuclear' theme."
  :group 'doom-themes)

(defcustom nuclear-brighter-modeline nil
  "If non-nil, more vivid colors will be used to style the mode-line."
  :group 'nuclear-theme
  :type 'boolean)

(defcustom nuclear-brighter-comments nil
  "If non-nil, comments will be highlighted in more vivid colors."
  :group 'nuclear-theme
  :type 'boolean)

(defcustom nuclear-padded-modeline doom-themes-padded-modeline
  "If non-nil, adds a 4px padding to the mode-line.
Can be an integer to determine the exact padding."
  :group 'nuclear-theme
  :type '(choice integer boolean))


;;
;;; Theme definition

(def-doom-theme doom-nuclear
  "A dark theme inspired by Atom One Dark."

  ;; name        default   256           16
  ((bg         '("#282c34" "black"       "black"  ))
   (fg         '("#dee2f8" "#bfbfbf"     "brightwhite"  ))

   ;; These are off-color variants of bg/fg, used primarily for `solaire-mode',
   ;; but can also be useful as a basis for subtle highlights (e.g. for hl-line
   ;; or region), especially when paired with the `doom-darken', `doom-lighten',
   ;; and `doom-blend' helper functions.
   (bg-alt     '("#21242b" "black"       "black"        ))
   (fg-alt     '("#5B6268" "#2d2d2d"     "white"        ))

   ;; These should represent a spectrum from bg to fg, where base0 is a starker
   ;; bg and base8 is a starker fg. For example, if bg is light grey and fg is
   ;; dark grey, base0 should be white and base8 should be black.
   (base0      '("#1B2229" "black"       "black"        ))
   (base1      '("#1c1f24" "#1e1e1e"     "brightblack"  ))
   (base2      '("#202328" "#2e2e2e"     "brightblack"  ))
   (base3      '("#23272e" "#262626"     "brightblack"  ))
   (base4      '("#3f444a" "#3f3f3f"     "brightblack"  ))
   (base5      '("#5B6268" "#525252"     "brightblack"  ))
   (base6      '("#73797e" "#6b6b6b"     "brightblack"  ))
   (base7      '("#9ca0a4" "#979797"     "brightblack"  ))
   (base8      '("#DFDFDF" "#dfdfdf"     "white"        ))

   (grey       base4)
   (red        '("#fb8578" "#ff6655" "red"          ))
   (orange     '("#fdce5f" "#dd8844" "brightred"    ))
   (green      '("#9fed9c" "#99bb66" "green"        ))
   (teal       '("#4db5bd" "#44b9b1" "brightgreen"  ))
   (yellow     '("#eddc91" "#ECBE7B" "yellow"       ))
   (blue       '("#7db9fe" "#51afef" "brightblue"   ))
   (dark-blue  '("#5f68de" "#2257A0" "blue"         ))
   (magenta    '("#e29bf7" "#c678dd" "brightmagenta"))
   (violet     '("#aeb9f3" "#a9a1e1" "magenta"      ))
   (cyan       '("#75e0f9" "#46D9FF" "brightcyan"   ))
   (dark-cyan  '("#5699AF" "#5699AF" "cyan"         ))

   ;; These are the "universal syntax classes" that doom-themes establishes.
   ;; These *must* be included in every doom themes, or your theme will throw an
   ;; error, as they are used in the base theme defined in doom-themes-base.
   (highlight      "#8496ff")
   (vertical-bar   (doom-darken base1 0.1))
   (selection      dark-blue)
   (builtin        blue)
   (comments       "#63677f")
   (doc-comments   (doom-lighten (if nuclear-brighter-comments dark-cyan base5) 0.25))
   (constants      yellow)
   (functions      blue)
   (keywords       magenta)
   (methods        violet)
   (operators      cyan)
   (type           orange)
   (strings        green)
   (variables      red)
   (numbers        violet)
   (region         `(,(doom-lighten (car bg-alt) 0.15) ,@(doom-lighten (cdr base1) 0.35)))
   (error          red)
   (warning        yellow)
   (success        green)
   (vc-modified    orange)
   (vc-added       green)
   (vc-deleted     red)

   ;; These are extra color variables used only in this theme; i.e. they aren't
   ;; mandatory for derived themes.
   (modeline-fg              fg)
   (modeline-fg-alt          base5)
   (modeline-bg              (if nuclear-brighter-modeline
                                 (doom-darken blue 0.45)
                               (doom-darken bg-alt 0.1)))
   (modeline-bg-alt          (if nuclear-brighter-modeline
                                 (doom-darken blue 0.475)
                               `(,(doom-darken (car bg-alt) 0.15) ,@(cdr bg))))
   (modeline-bg-inactive     `(,(car bg-alt) ,@(cdr base1)))
   (modeline-bg-inactive-alt `(,(doom-darken (car bg-alt) 0.1) ,@(cdr bg)))

   (-modeline-pad
    (when nuclear-padded-modeline
      (if (integerp nuclear-padded-modeline) nuclear-padded-modeline 4))))


  ;;;; Base theme face overrides
  (((line-number &override) :foreground base4)
   ((line-number-current-line &override) :foreground violet)
   ((font-lock-comment-face &override)
    :background (if nuclear-brighter-comments (doom-lighten bg 0.05)))
   (mode-line
    :background modeline-bg :foreground modeline-fg
    :box (if -modeline-pad `(:line-width ,-modeline-pad :color ,modeline-bg)))
   (mode-line-inactive
    :background modeline-bg-inactive :foreground modeline-fg-alt
    :box (if -modeline-pad `(:line-width ,-modeline-pad :color ,modeline-bg-inactive)))
   (mode-line-emphasis :foreground (if nuclear-brighter-modeline base8 highlight))

   ;;;; css-mode <built-in> / scss-mode
   (css-proprietary-property :foreground orange)
   (css-property             :foreground green)
   (css-selector             :foreground blue)
   ;;;; doom-modeline
   (doom-modeline-bar :background (if nuclear-brighter-modeline modeline-bg highlight))
   (doom-modeline-buffer-file :inherit 'mode-line-buffer-id :weight 'bold)
   (doom-modeline-buffer-path :inherit 'mode-line-emphasis :weight 'bold)
   (doom-modeline-buffer-project-root :foreground green :weight 'bold)
   ;;;; elscreen
   (elscreen-tab-other-screen-face :background "#353a42" :foreground "#1e2022")
   ;;;; ivy
   (ivy-current-match :background dark-blue :distant-foreground base0 :weight 'normal)
   ;;;; LaTeX-mode
   (font-latex-math-face :foreground green)
   ;;;; markdown-mode
   (markdown-markup-face :foreground base5)
   (markdown-header-face :inherit 'bold :foreground red)
   ((markdown-code-face &override) :background (doom-lighten base3 0.05))
   ;;;; rjsx-mode
   (rjsx-tag :foreground red)
   (rjsx-attr :foreground orange)
   ;;;; solaire-mode
   (solaire-mode-line-face
    :inherit 'mode-line
    :background modeline-bg-alt
    :box (if -modeline-pad `(:line-width ,-modeline-pad :color ,modeline-bg-alt)))
   (solaire-mode-line-inactive-face
    :inherit 'mode-line-inactive
    :background modeline-bg-inactive-alt
    :box (if -modeline-pad `(:line-width ,-modeline-pad :color ,modeline-bg-inactive-alt))))

  ;;;; Base theme variable overrides-
  ())

;;; nuclear-theme.el ends here
#+end_src
********* Generator
:PROPERTIES:
:header-args+: :tangle no
:END:
#+name: gen-doom-theme
#+begin_src elisp :var palette=palette
(defun dt--color (color)
  (let ((k (-> color symbol-name (substring 1))))
    (cadr (assoc k palette))))

(defmacro dt--buffer->string (&rest body)
  `(with-temp-buffer
     ,@body
     (buffer-string)))

(defun dt--slurp (f)
  (dt--buffer->string
   (insert-file-contents f)))

(defun dt--replace (s match replacement)
  (replace-regexp-in-string match replacement s 'fixedcase 'literal))

(defun dt--replace-sexp (s match replacement)
  (dt--buffer->string
   (insert s)
   (goto-char (point-min))
   (re-search-forward match)
   ;; Calling `forward-sexp' and `backward-sexp' here to preserve whitespace.
   (forward-sexp)
   (backward-sexp)
   (kill-sexp)
   (insert (format "%S" replacement))))

(defun dt--gen-doom-theme (f)
  (-as->
   (dt--slurp f) $
   (dt--replace-sexp $ "def-doom-theme" 'doom-nuclear)
   (dt--replace $ "doom-one" "nuclear")
   (-reduce-from
    (-lambda (s (match replacement))
      (dt--replace-sexp s match replacement))
    $
    (-partition
     2
     (let ((match-base-color (lambda (form)
                               (rx-to-string `(seq "(" ,form (+ whitespace) "'("))))
           (match-face (lambda (&rest forms)
                         (rx-to-string `(seq "(" ,@forms)))))
       (list
        (funcall match-base-color "fg") (dt--color :fg)
        (funcall match-base-color "red") (dt--color :red)
        (funcall match-base-color "orange") (dt--color :orange)
        (funcall match-base-color "green") (dt--color :green)
        (funcall match-base-color "yellow") (dt--color :yellow)
        (funcall match-base-color "blue") (dt--color :blue)
        (funcall match-base-color "dark-blue") (dt--color :dark-blue)
        (funcall match-base-color "magenta") (dt--color :magenta)
        (funcall match-base-color "violet") (dt--color :violet)
        (funcall match-base-color "cyan") (dt--color :cyan)
        (funcall match-face "highlight") (dt--color :highlight)
        (funcall match-face "builtin") 'blue
        (funcall match-face "comments") (dt--color :comments)
        (funcall match-face "constants") 'yellow
        (funcall match-face "functions") 'blue
        (funcall match-face "keywords") 'magenta
        (funcall match-face "methods") 'violet
        (funcall match-face "operators") 'cyan
        (funcall match-face "type") 'orange
        (funcall match-face "variables") 'red
        (funcall match-face "numbers") 'violet
        (funcall match-face "line-number-current-line" '(+? anything) ":foreground") 'violet))))
   (dt--replace $ (rx ";; Copyright" (*? anything) "\n") "")
   (dt--replace $ (rx ";; Author" (*? anything) "\n") "")
   (dt--replace $ (rx ";; Maintainer" (*? anything) "\n") "")
   (dt--replace $ (rx ";; Created" (*? anything) "\n") "")))

;; REVIEW do this better (don't hardcode it?). Add a :path: tag to this org header if necessary. Perhaps it would be best to have the doom-themes repo be an explicit dependency in some way and manage like I do other Guix or Doom/straight dependencies.
(dt--gen-doom-theme "~/.config/emacs/.local/straight/repos/themes/themes/doom-one-theme.el")
#+end_src

#+name: unescape
#+begin_src elisp :var s=""
(-as-> s $
       (substring s 1 -1) ; Remove outer quotes.
       (replace-regexp-in-string (rx "\\n" ) "\n" $) ; Unescape newlines specifically before unescaping everything else (not how this works / why it's necessary).
       (replace-regexp-in-string (rx "\\" (group anything)) "\\1" $))
#+end_src
******* Projects
******** Phrenetic :path:
#+begin_src elisp
(load "~/projects/phrenetic/meta" 'noerror 'nomessage)

(pushnew! safe-local-variable-values
          '(eval . (with-eval-after-load 'geiser-guile
                     (let ((root-dir
                            (file-name-directory
                             (locate-dominating-file default-directory ".dir-locals.el"))))
                       (make-local-variable 'geiser-guile-load-path)
                       (add-to-list 'geiser-guile-load-path root-dir)))))
#+end_src
******** Nyxt
- TODO donno if I should keep this section in particular (it's not really impoportant), I'm just thinking I want to start trying out adding safe local variables for other codebases so I can get their advantages. Also the changes it makes persist (modify ~lisp-imenu-generic-expression~), I don't know if that's a good idae.
#+begin_src elisp
(pushnew! safe-local-variable-values
          '(eval . (cl-flet ((enhance-imenu-lisp
                              (&rest keywords)
                              (dolist (keyword keywords)
                                (add-to-list
                                 'lisp-imenu-generic-expression
                                 (list (purecopy (concat (capitalize keyword)
                                                         (if (string= (substring-no-properties keyword -1) "s")
                                                             "es"
                                                           "s")))
                                       (purecopy (concat "^\\s-*("
                                                         (regexp-opt
                                                          (list (concat "define-" keyword))
                                                          t)
                                                         "\\s-+\\(" lisp-mode-symbol-regexp "\\)"))
                                       2)))))
                     ;; This adds the argument to the list of imenu known keywords.
                     (enhance-imenu-lisp
                      "bookmarklet-command"
                      "class"
                      "command"
                      "ffi-method"
                      "function"
                      "mode"
                      "parenscript"
                      "user-class"))))
#+end_src
******** Hyperdrive :path:
#+begin_src elisp
(pushnew! safe-local-variable-values
          '(cider-preferred-build-tool . shadow-cljs)
          '(cider-default-cljs-repl . shadow)
          '(cider-shadow-default-options . ":app")
          '(cider-offer-to-open-cljs-app-in-browser . nil)
          '(cider-clojure-cli-global-options . "-A:dev")
          '(eval . (setenv "DATOMIC_APP_INFO_MAP" "{:app-name \"neutrino\"}"))
          '(eval . (setenv "DATOMIC_ENV_MAP" "{:env :dev}"))
          '(cider-clojure-cli-global-options . nil))

(prodigy-define-service
  :name "Amplify Mock"
  :command "amplify"
  :args '("mock")
  :cwd "~/projects/Krush/hyperdrive/apps/singularity"
  :kill-process-buffer-on-stop t)

(prodigy-define-service
  :name "Datomic Access (exogenesis)"
  :command "bash"
  :args '("datomic" "client" "access" "exogenesis")
  :cwd "~/projects/Krush/hyperdrive/ion/team"
  :kill-process-buffer-on-stop t)
#+end_src
******** Massrealty :path:
#+begin_src elisp
;; (pushnew! safe-local-variable-values
;;           '(ssh-deploy-root-remote . "/ssh:massrealty@35.196.144.73:/home/massrealty/deploy/homes/public_html/")
;;           '(ssh-deploy-automatically-detect-remote-changes . t))

;; (after! org-gcal
;;   (add-to-list 'org-gcal-fetch-file-alist `("krzysztof@massrealty.com" . ,(concat biome--org-gcal-dir "/krzysztof@massrealty.com.org")) 'append))
#+end_src
******* WIP
#+begin_src elisp
(after! org
  (add-to-list 'org-agenda-files (concat biome--org-dir "/spring_cleaning") 'append))

;; I don't think I'll ever need this with Sway. Is it worth keeping this and having an "I'm not on Sway / some WM" conditional around it?
;; (add-to-list 'initial-frame-alist '(fullscreen . fullboth))

(map! "s-A" #'app-launcher-run-app)

(map! "s-&" (lambda (command)
              (interactive (list (read-shell-command "$ ")))
              (call-process-shell-command command nil 0 nil)))

(map! :leader
      "s-," (lookup-key doom-leader-map (kbd "<")))

(after! company
  (map! :map company-active-map
        "s-[" #'company-show-doc-buffer ; Currently opens Help, it would be better if I made it use Helpful.
        "s-]" #'company-show-location))

(after! evil-org
  (map! :map evil-org-mode-map
        (:prefix "g"
         :nv "{" #'evil-backward-paragraph
         :nv "}" #'evil-forward-paragraph)))

;; TODO Maybe do this if popping to the side is too annoying
;; (after! geiser-repl
;;   (setq geiser-repl-use-other-window nil))

;; Doesn't work yet: you have to switch to the buffer "manually" once before it starts being treated as real
(map! "s-d m" (cmd! (doom-set-buffer-real (current-buffer) t)))

;; `forward-char' in original definition is messing things up, do this for now
;; (defun +eshell/search-history ()
;;   (interactive)
;;   (consult-history))
(after! esh-mode
  (map! :map eshell-mode-map
        "C-s" #'consult-history))

;; Remove the :mode set by the Doom module. It's unnecessary (`guix-drv-mode.el' already does this, and for /nix/store drvs specifically) and it shadows `guix-derivation-mode'.
;; TODO should this go in the Guix or Nix config section?
(use-package! nix-drv-mode
  :defer t
  :init
  (setq auto-mode-alist (delete '("\\.drv\\'" . nix-drv-mode) auto-mode-alist)))

(after! vertico
  (setq vertico-count 20  ; Trying out, maybe too big.
        vertico-scroll-margin 7))
#+end_src
******** "status bar"
Not using waybar at the moment so these are handy.
#+begin_src elisp
(use-package! battery
  :config
  (display-battery-mode 1))

(use-package! time
  :config
  (setq display-time-day-and-date t)
  ;; (setq display-time-24hr-format t)
  (display-time-mode 1))
#+end_src
******** keybinding ideas
#+begin_src elisp
;; If I keep this I can get rid of the "C-_" binding I have too. Update: maybe? Some places C-_ works and some s-h does (in vertico)? What about my key translation for C-? ? Straighten all this shit out.
(biome--trans "s-h" "C-h")

(map! "s-o" (lookup-key doom-leader-map (kbd "<")))
;; Get rid of binding for =s-r=?
(map! "s-r" nil)

;; Maybe "C-s-i" but then I'll have to change my sexp-movement command(s). Maybe keep this even if I do that, for consistency.
(biome--trans "C-S-i" "<backtab>")
;; Also messes with my sexp-movement bindings
;; (map! "C-s-j" #'evil-scroll-down
;;       "C-s-k" #'evil-scroll-up)

(after! evil
  (map! :map evil-motion-state-map
        ;; Maybe "C-s-o" but then I'll have to change my sexp-movement command(s). There are other bindings for jump-forward though, maybe I'll just use those.
        "C-S-o" #'evil-jump-forward))

;; Maybe `s-S' to save-and-tangle? If I don't get some sort of auto-tangling thing going
;; - maybe it could be "save and eval defun (C-M-x)" in lisp/programming modes?'
;; Maybe a hotkey that just jumps back and forth between my most recently focused browser window and eemacs?
;; Maybe bind `s-o' in `consult-buffer' to "close consult-buffer and open +vertico/switch-workspace-buffer"
#+end_src
******** phrenetic auto-tangle :path:
- TODO Might be easier to do this with file-local variables.
#+begin_src elisp
;; (setq biome--phrenetic-dir "~/projects/phrenetic")

;; (add-hook! 'org-mode-hook
;;   (defun biome-add-org-autotangle-after-save-hook-h ()
;;     (add-hook! 'after-save-hook :local
;;       (defun biome-autotangle-h ()
;;         (when (file-in-directory-p buffer-file-name biome--phrenetic-dir)
;;           ;; TODO ensure there aren't files in the output directory that no longer correspond to the org file. Just wipe it?
;;           (let ((org-confirm-babel-evaluate nil))
;;             (org-babel-tangle)))))))
#+end_src
******** org-tanglesync
#+begin_src elisp
;; (use-package! org-tanglesync
;;   :hook ((org-mode . org-tanglesync-mode)
;;          ((prog-mode text-mode) . org-tanglesync-watch-mode))
;;   :config
;;   (setq org-tanglesync-watch-files '("/home/pharcosyle/projects/phrenetic/phrenetic.org")))
#+end_src
******** Temporary copypasta from bloodhound
Copying this here for now, for convenience.
#+begin_src elisp
(setq my-dotfiles-git-dir (concat "--git-dir=" (expand-file-name "~/home-state.git")))
;; (setq my-dotfiles-work-tree (concat "--work-tree=" (expand-file-name "~")))
(map! "s-b" (cmd!
             (pushnew! magit-git-global-arguments my-dotfiles-git-dir)
             (magit-status "~")))
(map! "s-B" (cmd!
             ;; (delq! my-dotfiles-git-dir magit-git-global-arguments)
             ;; Why is the above not working? Doing this for now:
             ;; - Update: because `delq!' tests for equality with `eq'
             (setq magit-git-global-arguments (remove my-dotfiles-git-dir magit-git-global-arguments))))
#+end_src
******** until I get semicolon working
#+begin_src elisp
(map! (:map minibuffer-local-map
       "C-:" #'embark-act
       "C-c C-:" #'embark-export)
      (:leader
       "A" #'embark-dwim)
      ;; Trying out cycling (temp)
      "C-:" #'embark-act
      "s-q" #'embark-cycle)
#+end_src
******** ligatures
Probably move these to ~after!~ blocks
#+begin_src elisp
(set-ligatures! '(html-mode nxml-mode web-mode)
  :font-ligatures '("<!--" "-->" "</>" "</" "/>" ; Fira Code
                    "://"))
#+end_src
******* Out-of-band
Useful for making quick configuration additions if the the active Doomdir isn't writable (for example if it's symlinked to the Guix store).
#+begin_src elisp :var oob-dir=(meta-get-dir)
(let ((oob-dir (concat "~/projects/phrenetic/" oob-dir))) ; TODO currently `meta-get-dir' returns a path relative to the phrenetic dir. That might change but regardless don't hardcode the path here eventually.
  (let* ((file "out-of-band"))
    (or (load (concat oob-dir "/" file) 'noerror 'nomessage)
        (load! file 'noerror))))
#+end_src
******** File
#+begin_src elisp :tangle (meta-in-dir "out-of-band.el")
#+end_src
****** Packages :version:
#+begin_src elisp :tangle (meta-in-dir "packages.el")
;; -*- no-byte-compile: t; -*-

(package! dash :pin "0ac1ecf6b56eb67bb81a3cf70f8d4354b5782341") ; TODO make this be introduced by my doom config (where I need it)?
(package! expand-region :pin "7e5bbe2763c12bae3e77fe0c49bcad05ff91dbfe")
(package! tldr :pin "d3fd2a809a266c005915026799121c78e8b358f0")
(package! trashed :pin "ddf5830730544435a068f2dc9ac75a81ea69df1d")

(package! guix :pin "c9aef52121b458297e70bb50f49f7276b4a8d759")
(package! build-farm :pin "5c268a3c235ace0d79ef1ec82c440120317e06f5") ; REVIEW trying out
(package! guix-packaging ; REVIEW trying out
  :recipe (:host github
           :repo "ryanprior/emacs-guix-packaging"
           :files (:defaults "snippets"))
  :pin "5bbd1f1a268b3dfd813a75125ca88cbf0bef6529")

(package! bluetooth :pin "3a3c3c04437518f1ce0e940adf4a5e020b9755c3") ; TODO just maybe make this dependent on my "bluetooth feature"

(package! symon :pin "8dd8b6df49b03cd7d31b85aedbe9dd08fb922335")

;; TODO this should probably be specific to the krush/hyperdrive/afterburner(?) project
;; (package! graphql-mode :pin "2371316a750b807de941184d49ca19d277ecadcd")

(package! org-tanglesync :pin "af83a73ae542d5cb3c9d433cbf2ce1d4f4259117")

(package! i3wm-config-mode :pin "3574d88241118ed6cc5a3022b6dde58d6f5af9dd") ; TODO maybe make this part of a Sway / Window Manager feature or introduced by my Dotfiles project

;; REVIEW Breaks stuff after I updated to emacs 29 latest:
;; Compiling EmacSQL SQLite binary ...
;; Code Review initialization: (error "No EmacSQL SQLite binary available, aborting")
(package! code-review :disable t)

(package! app-launcher
  :recipe (:host github
           :repo "SebastienWae/app-launcher")
  :pin "d5015e394b0a666a8c7c4d4bdf786266e773b145")

(package! 0x0 :pin "63cd5eccc85e527f28e1acc89502a53245000428")

;; TODO do hardcoded path better?
;; TODO currently donnager is part of my dotfiles but if that isn't going to be the case I might like to make my dotfiles able to work in a "self-contained" fashion by providing a fallback in case it isn't available. To a github repo, or somehing. Actually can/should I do something like `out-of-band.el' and have donnager compiled and used like a regular package BUT prefer using the source in ~/projects if available. Does straight support doing things like this? Implement it myself if not?
(package! donnager
  :recipe (:local-repo "~/projects/phrenetic/donnager"
           ;; Avoid having to run `doom sync' every time the package is changed. REVIEW after packaging Doom revisit this and see if it still makes sense to disable compilation. Byte-compiled code is faster, after all. Natively-compiled even more so.
           :build (:not compile)))
#+end_src
** Dev
- REVIEW I might want to have the res files (e.g. =alucard_bg.png=) placed closer to the dotfiles config that uses them. Don't worry about this right now, gitignores are a pain and they've been changing frequently as I rewrite stuff.
*** Git ignore
#+begin_src gitignore :tangle (meta-in-dir ".gitignore")
/*
!res/
#+end_src
* Dev
- TODO maybe make this a =*= with excludes later. I could then get rid of any subproject dirs' gitignores that consist solely of a =*= but I might not want to, for project isolation
** Git ignore
#+begin_src gitignore :tangle (meta-in-dir ".gitignore")
/.gitignore
#+end_src
** Github
*** Git config
#+begin_src gitconfig :tangle (meta-in-dir ".git/config")
[remote "origin"]
	url = https://github.com/pharcosyle/phrenetic.git
	fetch = +refs/heads/*:refs/remotes/origin/*

[branch "master"]
	remote = origin
	merge = refs/heads/master
#+end_src
* Dev local
** Git config
- REVIEW I may want to pull this out for reuse across all my projects since this bit of git config will always be the same (on a Guix system that is, so ideally have multiple default git configs per-OS and select the right one dynamically when tangling)
#+begin_src gitconfig :tangle (meta-in-dir ".git/config")
[core]
	repositoryformatversion = 0
	filemode = true
	bare = false
	logallrefupdates = true
#+end_src
** Emacs directory-local variables
- TODO Causes gesier to fail to load outside of this directory
  *don't do this until I figure out how I'm doing per-project Emcas config* I might not end up doing Geiser setup this way at all
  Since the ~with-eval-after-load~ body will get called wherever geiser-guile is first loaded, if the geiser library isn't loaded yet and I e.g. visit a file in this directory, then leave, then try to =M-x guix p e= while I'm viewing a file elsewhere it'll fail to run since it loads geiser internally and can't find a dominating .dir-locals.
  - an alternative approach to setting up geiser for a project: [[https://github.com/guix-mirror/guix/blob/master/.dir-locals.el#L21][guix/.dir-locals.el at master · guix-mirror/guix · GitHub]]
    Maybe try that or something like it.
    - here's where I got the original approach, for reference: [[https://github.com/flatwhatson/flycheck-guile#troubleshooting][GitHub - flatwhatson/flycheck-guile: A Flycheck checker for GNU Guile]]
  - update [2022-03-26 Sat]: this won't work as-is any more
    I have multiple directories to load (ebullient, exhuberant...)
#+begin_src elisp :tangle (meta-in-dir ".dir-locals.el")
((nil
  (eval . (with-eval-after-load 'geiser-guile
            (let ((root-dir
                   (file-name-directory
                    (locate-dominating-file default-directory ".dir-locals.el"))))
              (make-local-variable 'geiser-guile-load-path)
              (add-to-list 'geiser-guile-load-path root-dir))))))
#+end_src

#+begin_src gitignore :tangle (meta-in-dir ".gitignore")
/.dir-locals.el
#+end_src




* COMMENT Guix Emacs integration WIP
My old "Guix > Emacs Integration" code that I might still want for extra-profiles or on a per-project basis. What did the Andrew Tropin video(s) on per-project dev environment have to say again? Move them into some sort of shared/parameterizable per-project section?
** man :path:
#+begin_src elisp :noweb yes
(after! man
  (prependq! Man-header-file-path
             (-map (lambda (p)
                     (concat p "/include"))
                   '(<<guix-extra-profiles>>))))
#+end_src
** tramp :path:
Make tramp work on Guix. Tramp is used locally to do sudo from inside Emacs so include my user-specific paths too.
- TODO why did I add =~/.config/guix/current/bin=?
#+begin_src elisp :noweb yes
(after! tramp
  (prependq! tramp-remote-path
             (-map (lambda (p)
                     (concat p "/bin"))
                   '(<<guix-extra-profiles>>))))
#+end_src
