#+TITLE: Dotfiles
#+PROPERTY: header-args :mkdirp yes

* Meta
#+begin_src elisp
(defun tangle-dir* ()
  (thread-first
    (org-entry-get (point) "tangle-dir" 'inherit)
    (split-string " ")
    (string-join "/")))

(defun get-tangle-dir ()
  (expand-file-name (tangle-dir*)))

(defun in-tangle-dir (sub-path)
  (expand-file-name sub-path (tangle-dir*)))

;; TODO Don't hardcode
(defun scheme-dir ()
  "ebullient")
#+end_src
** Git
#+begin_src gitignore :tangle .gitignore
/.gitignore
/ebullient/
/.dir-locals.el
#+end_src
* Common
#+name: user-name
#+begin_src org
pharcosyle
#+end_src
#+name: user-full-name
#+begin_src org
Krzysztof Baranowski
#+end_src
#+name: user-email
#+begin_src org
pharcosyle@gmail.com
#+end_src
#+name: spartan-exe
#+begin_src org
spartan
#+end_src
* Installation Guide
** Create bootable USB
Download (or create) a Guix installation ISO
- I'm using the [[https://github.com/SystemCrafters/guix-installer/releases/latest][System Crafters Guix Installer]] since it's kept up-to-date which should speed things up a bit.
- Run ~lsblk~ to find the usb device.
#+begin_src sh
iso_file=guix-system-install-1.3.0.x86_64-linux.iso
usb_device=/dev/sdc
dd if=$iso_file of=$usb_device status=progress bs=4M
sync
#+end_src
** Install
Boot from the installation medium, select your language and country, and select "Install using the shell based process" when prompted.
*** Keyboard layout
This messed up the keyboard when I tried it on mac, not doing ~loadkeys~ at all was fine.
#+begin_src sh
# keysfile=mac-us
# loadkeys mac-us
#+end_src
*** Networking
#+begin_src sh
# List network interfaces and find one to use.
ifconfig -a

# Is this necessary if the interface is already activated?
interface=usb0
ifconfig $interface up

dhclient -v $interface

# Test that networking is up and working.
ping -c 3 gnu.org
#+end_src
*** Partitioning
#+begin_src sh
# Check out the current block devices and partitions if you want.
lsblk

device=/dev/sda

# Make two partitions, partition types should be "EFI system partition" and "Linux x86-64 root (/)". For EFI I'm gonna do 1GB to be on the safe side, second should be remainder of free space.
cfdisk $device
parted $device set 1 esp on

efi_system_partition="$device"1
efi_label=genesis

mkfs.fat -F32 -n $efi_label $efi_system_partition

root_partition="$device"2
root_label=firmament
crypt_name=ciphered
crypt_mapping=/dev/mapper/$crypt_name

cryptsetup luksFormat $root_partition
cryptsetup open --type luks $root_partition $crypt_name

mkfs.btrfs -L $root_label $crypt_mapping
#+end_src
*** Set up subvolumes
#+begin_src sh
# I don't know if the type argument is necessary but that's how Andrew Tropin had it.
mount -t btrfs LABEL=$root_label /mnt

btrfs subvolume create /mnt/root
btrfs subvolume create /mnt/boot
btrfs subvolume create /mnt/guix-store
btrfs subvolume create /mnt/guix-var
btrfs subvolume create /mnt/log
btrfs subvolume create /mnt/home
btrfs subvolume create /mnt/persist
btrfs subvolume create /mnt/nix

# Take an empty readonly snapshot of the root subvolume (might be useful later for rolling back or comparison)
btrfs subvolume snapshot -r /mnt/root /mnt/root-blank

umount /mnt
#+end_src
*** Mount
NB: ~$crypt_mapping~ can/"should" be ~LABEL=$root_label~
#+begin_src sh
mount -o subvol=root,compress=zstd,autodefrag $crypt_mapping /mnt

mkdir /mnt/boot
mount -o subvol=boot,compress=zstd,autodefrag $crypt_mapping /mnt/boot
mkdir -p /mnt/gnu/store
mount -o subvol=guix-store,compress=zstd,autodefrag,noatime $crypt_mapping /mnt/gnu/store
mkdir -p /mnt/var/guix
mount -o subvol=guix-var,compress=zstd,autodefrag $crypt_mapping /mnt/var/guix
mkdir -p /mnt/var/log
mount -o subvol=log,compress=zstd,autodefrag $crypt_mapping /mnt/var/log
mkdir /mnt/home
mount -o subvol=home,compress=zstd,autodefrag $crypt_mapping /mnt/home
mkdir /mnt/.persist
mount -o subvol=persist,compress=zstd,autodefrag $crypt_mapping /mnt/.persist

mkdir -p /mnt/boot/efi
mount LABEL=$efi_label /mnt/boot/efi
#+end_src
*** Proceeding with installation
#+begin_src sh
herd start cow-store /mnt
#+end_src
*** System configuration
#+begin_src sh
# Grab my dotfiles, from github if I put them up at some point or maybe from a USB or another computer with `woof`, into the current directory (the one I'm already in, not `/mnt`).
# git clone https://github.com/pharcosyle/dotfiles
# guix environment --ad-hoc woof -- woof -U
# Important: `woof` didn't work for me over the local network, I had to have my other computer offer it over the public internet with localtunnel.

mkdir -p ~/.config/guix
cp ~/projects/dotfiles/ebullient/home/channels.scm ~/.config/guix
guix pull
hash guix

# Find the LUKS UUID to update it in the system config. Make sure to update in the dotfiles upstream later.
cryptsetup luksUUID $root_partition

cd ~/projects/dotfiles/ebullient
guix system --load-path=. init system/frostfire.scm /mnt
#+end_src
*** Post-installation
#+begin_src sh
# Reboot the system, take out the installation medium, and login as root when faced with a login prompt.

# Set the password for the root account.
passwd
# Set the password for my user.
my_user=pharcosyle
passwd $my_user

# Log out and log in to my user account.

# Grab my dotfiles again.

# Ensure my channels file is in `~/.config/guix` and update my channels.
guix pull

# Run a system reconfigure, home reconfigure, install manifests, and deploy `home-state.git`. Copy over all my old data.
#+end_src
* System
:PROPERTIES:
:tangle-dir+: ebullient/system
:END:
** Components
:PROPERTIES:
:header-args+: :tangle (in-tangle-dir "components.scm")
:END:
#+begin_src scheme
(define-module (ebullient system components)
  #:use-module (guix build-system trivial)
  #:use-module ((guix modules) #:select (source-module-closure))
  #:use-module (guix gexp)
  #:use-module ((guix store) #:select (%default-substitute-urls))
  #:use-module (gnu bootloader)
  #:use-module (gnu bootloader grub)
  #:use-module ((gnu packages fonts) #:select (font-terminus))
  #:use-module ((gnu packages gnupg) #:select (guile-gcrypt))
  #:use-module ((gnu packages linux) #:select (brightnessctl))
  #:use-module (gnu services)
  #:use-module (gnu services base)
  #:use-module (gnu services desktop)
  #:use-module (gnu services nix)
  #:use-module (gnu services xorg)
  #:use-module (gnu system)
  #:use-module (gnu system accounts)
  #:use-module (gnu system file-systems)
  #:use-module (gnu system keyboard)
  #:use-module (gnu system mapped-devices)
  #:use-module ((nongnu packages linux) #:select (linux linux-firmware))
  #:use-module ((nongnu system linux-initrd) #:select (microcode-initrd))
  #:use-module (ebullient packages xf86-input-mtrack)
  #:use-module (ice-9 match)
  #:use-module (srfi srfi-1)
  #:export (system-comp
            define-system-comp
            barebones-os
            basic-info
            boot
            initial-services
            linux-nonfree
            disk-encryption
            stateless
            users
            nix
            hidpi-console-font
            mtrack
            macbook
            macbook-kbl
            custom-wm
            et-cetera))
#+end_src
#+begin_src scheme
(define-syntax-rule (system-comp os form ...)
  (operating-system
    (inherit os)
    form ...))

(define-syntax-rule (define-system-comp (name arg ...) body ...)
  (define* (name os arg...)
    (system-comp os body ...)))
#+end_src
*** Barebones OS
#+begin_src scheme
(define barebones-os
  (operating-system
    (host-name #f)
    (timezone #f)
    (bootloader #f)
    (services '())
    (file-systems %base-file-systems)))
#+end_src
*** Basics
Other components may inherit ~keyboard-value~ so use this component early. At the time of this writing, nothing depends on the values of hostname, etc but I could see them being useful base values to have present early.
#+begin_src scheme
(define-system-comp (basics #:key host-name timezone locale keyboard-layout)
  (host-name host-name)
  (timezone timezone)
  (locale locale)
  (keyboard-layout keyboard-layout))
#+end_src
*** Boot
#+begin_src scheme
(define-system-comp (boot #:key label target)
  (bootloader (bootloader-configuration
               (bootloader grub-efi-bootloader)
               (targets (list target))
               (timeout 1)
               (keyboard-layout (operating-system-keyboard-layout os))))
  (file-systems
   (cons* (file-system
            (device (file-system-label label))
            (mount-point target)
            (type "vfat"))
          (operating-system-file-systems os))))
#+end_src
*** Initial services
Other components may wish to modify the list of operating system services so use this in the component chain early.
#+begin_src scheme
(define selective-desktop-services
  (remove (lambda (service)
            (member (service-kind service)
                    (list gdm-service-type ; Kind of a presumptuous default.
                          ;; TODO remove if I don't end up needing this for pipewire. Removal might be behind a pipewire flag, also.
                          ;; pulseaudio-service-type
                          ;; alsa-service-type
                          )))
          %desktop-services))

(define-system-comp (initial-services #:key desktop?)
  (services
   (append (if desktop?
               selective-desktop-services
               %base-services)
           (operating-system-user-services os))))
#+end_src
*** Linux nonfree
#+begin_src scheme
(define-system-comp (linux-nonfree)
  (kernel linux)
  (initrd microcode-initrd)
  (firmware (cons* linux-firmware
                   (operating-system-firmware os))))
#+end_src
*** Disk encryption
#+begin_src scheme
(define* (disk-encryption os #:key source-uuid target encrypted-mount-points)
  (let ((encrypted-device (mapped-device
                           (source (uuid source-uuid))
                           (target target)
                           (type luks-device-mapping))))
    (system-comp
     os
     (mapped-devices
      (cons* encrypted-device
             (operating-system-mapped-devices os)))
     (file-systems
      (map (lambda (fs)
             (if (member (file-system-mount-point fs) encrypted-mount-points)
                 (file-system
                   (inherit fs)
                   (dependencies (cons* encrypted-device
                                        (file-system-dependencies fs))))
                 fs))
           (operating-system-file-systems os))))))
#+end_src
*** Stateless
The stateless service should come after base/desktop services (potentially others as well) so its state gets installed before theirs during activation. To this end the ~stateless-service-type~ is appended, not prepended, to operating system services. It also modifies file systems so users of this component should include it at the end of their component chain.
#+begin_src scheme
(define-system-comp (stateless #:key persist-dir bluetooth?)
  (initrd (lambda (file-systems . rest)
            (apply (operating-system-initrd os) file-systems
                   #:volatile-root? #t
                   rest)))
  (file-systems
   (map (lambda (fs)
          (if (member (file-system-mount-point fs)
                      '("/var/guix" "/var/log" ,persist-dir))
              (file-system
                (inherit fs)
                (needed-for-boot? #t))
              fs))
        (operating-system-file-systems os)))
  (services
   (append
    (operating-system-user-services os)
    (list
     (service stateless-service-type
              `(#:persist-dir ,persist-dir
                #:paths ,(append
                          '("/etc/machine-id"
                            "/var/lib/random-seed"
                            "/etc/NetworkManager/system-connections"
                            "/var/lib/NetworkManager/secret_key"
                            "/etc/guix/signing-key.pub"
                            "/etc/guix/signing-key.sec")
                          (if bluetooth?
                              (list "/var/lib/bluetooth") '()))))))))
#+end_src
**** Service
#+begin_src scheme
(define (populate-gexp config)
  (with-extensions (list guile-gcrypt)
    (with-imported-modules (source-module-closure
                            '((gnu build install)))
      #~(begin
          (use-modules ((gnu build install) #:select (populate-root-file-system)))

          (define* (populate #:key persist-dir #:allow-other-keys)
            (let ((system-link (readlink "/var/guix/profiles/system"))
                  (system-1-link (readlink "/var/guix/profiles/system-1-link")))
              (populate-root-file-system system-1-link ""
                                         #:extras `(("/var/guix/profiles/system" -> ,system-link))))
            ;; I'd like to do this during activation with the rest of the state but I can't get the activation service to run before account-service and I don't want to overwrite any changes it makes to these files.
            (for-each (lambda (path)
                        (copy-file (string-append persist-dir path) path))
                      '("/etc/group"
                        "/etc/passwd"
                        "/etc/shadow")))

          (apply populate '#$config)))))

(define (activate-state-gexp config)
  #~(begin
      (use-modules (ice-9 match))

      (define* (activate-state #:key persist-dir paths)

        (define (install path)
          (let loop ((components (string-tokenize path (char-set-complement (char-set #\/))))
                     (base persist-dir)
                     (target-base ""))
            (match components
              ((head tail ...)
               (let* ((path (string-append base "/" head))
                      (target-path (string-append target-base "/" head)))
                 (if (null? tail)
                     ;; The Guix code makes a point of doing stuff like this atomically. I don't really know why but I will too.
                     (let ((pivot (string-append target-path ".new")))
                       (symlink path pivot)
                       (rename-file pivot target-path))
                     (begin
                       (catch 'system-error
                         (lambda ()
                           (mkdir target-path))
                         (lambda args
                           (unless (= EEXIST (system-error-errno args))
                             (apply throw args))))
                       (let ((st (lstat path)))
                         (chown target-path (stat:uid st) (stat:gid st))
                         (chmod target-path (stat:perms st)))
                       (loop tail path target-path))))))))

        (for-each install paths))

      (apply activate-state '#$config)))

(define stateless-service-type
  (service-type (name 'stateless)
                (extensions
                 (list (service-extension boot-service-type
                                          populate-gexp)
                       (service-extension activation-service-type
                                          activate-state-gexp)))))
#+end_src
*** Btrfs
#+begin_src scheme
(define-system-comp (btrfs #:key label subvols)
  (file-systems
   (append
    (map (match-lambda
           ((subvol mount-point)
            (file-system
              (device (file-system-label label))
              (mount-point mount-point)
              (type "btrfs")
              (options (string-append "subvol=" subvol ",compress=zstd,autodefrag")))))
         subvols)
    (operating-system-file-systems os))))
#+end_src
*** Users
#+begin_src scheme
(define* (account user-name user-full-name #:key admin? password salt bluetooth?)
  (user-account
   (name user-name)
   (comment user-full-name)
   (group "users")
   ;; TODO `input' group necessary for mtrack (at present, maybe there's a way around
   ;; this. Libinput doesn't need it, for example, but maybe it's "built in" or
   ;; something. Also I'd ideally like the touchpad to work on the gdm login screen.)
   (supplementary-groups (append '("netdev" "audio" "video" "input")
                                 (if admin? (list "wheel") '())
                                 (if bluetooth? (list "lp") '())))
   (password (if password
                 (crypt password salt)
                 #f))))

(define-system-comp (users #:key who bluetooth?)
  (users (append (map (lambda* (user)
                        (apply account (append user `(#:bluetooth? ,bluetooth?))))
                      who)
                 (operating-system-users os))))
#+end_src
*** HiDPI console font
#+begin_src scheme
(define (with-hidpi-console-font services)
  (modify-services services
    (console-font-service-type config =>
                               (map (lambda (tty-and-font)
                                      (cons (car tty-and-font)
                                            (file-append font-terminus "/share/consolefonts/ter-132n")))
                                    config))))

(define-system-comp (hidpi-console-font)
  (services (with-hidpi-console-font
             (operating-system-user-services os))))
#+end_src
*** mtrack
- TODO Get the setting of keyboard-layout into et-cetera
- TODO tried `#~#$(local-file "xorg.conf")' but it didn't work, I don't think xorg.conf is protected from garbage collection. Also the path isn't relative to this file like local-file would be (I think) it'll only work if I run the reconfigure command from the generated files directory. Update: I forget what the problem was exactly but would rde's `slurp-file-gexp' work?
#+begin_src scheme
(define-system-comp (mtrack)
  (packages
   (cons* xf86-input-mtrack
          (operating-system-packages os)))
  (services
   (cons* (service gdm-service-type
                   (gdm-configuration
                    (xorg-configuration
                     (xorg-configuration
                      (modules (cons* xf86-input-mtrack
                                      %default-xorg-modules))
                      (keyboard-layout (operating-system-keyboard-layout os))
                      (extra-config (list (with-input-from-file "xorg.conf" read-string)))))))
          (operating-system-user-services os))))
#+end_src
**** Xorg config
#+begin_src conf :tangle (in-tangle-dir "xorg.conf")
Section "InputClass"
  Identifier      "Touchpads"
  Driver          "mtrack"
  MatchIsTouchpad "on"
EndSection
#+end_src
*** Nonguix substitutes
#+begin_src scheme
(define-system-comp (nonguix-substitutes)
  (services (modify-services (operating-system-user-services os)
              (guix-service-type config =>
                                 (guix-configuration
                                  (inherit config)
                                  (substitute-urls
                                   (append %default-substitute-urls
                                           (list "https://mirror.brielmaier.net")))
                                  (authorized-keys
                                   (append %default-authorized-guix-keys
                                           (list (local-file "mirror.brielmaier.net.pub")))))))))
#+end_src
**** Public key
#+begin_src scheme :tangle (in-tangle-dir "mirror.brielmaier.net.pub")
(public-key
 (ecc
  (curve Ed25519)
  (q #7514F8D729DB1935470A581CE3851ED9FD6F1F9BAFE1D8BEC77A931ADB7A4337#)))
#+end_src
*** Macbook
I'm not sure if this requires [[Linux nonfree][Linux nonfree]] and/or if the blacklist refers to kernel modules that are only in the nonfree linux kernel (i.e., not linux-libre)
#+begin_src scheme
(define (with-blacklist kernel-args new)

  (define (update-list pred l f)
    (map (lambda (x)
           (if (pred x) (f x) x))
         l))

  (define (blacklist? ka)
    (string-prefix? "modprobe.blacklist" ka))

  (if (any blacklist? kernel-args)
      (update-list blacklist? kernel-args (lambda (blacklist)
                                            (string-append blacklist "," new)))
      (cons* (string-append "modprobe.blacklist=" new) kernel-args)))

(define-system-comp (macbook #:key bluetooth?)
  (kernel-arguments (with-blacklist (operating-system-user-kernel-arguments os)
                                    "b43,b43legacy,ssb,bcm43xx,brcm80211,brcmfmac,brcmsmac,bcma"))
  (kernel-loadable-modules (cons* broadcom-sta
                                  (operating-system-kernel-loadable-modules os)))
  (firmware (append
             (if bluetooth? (list broadcom-bt-firmware) '())
             (operating-system-firmware os))))

(define macbook-kbl
  (keyboard-layout "us" #:model "macbook78"))
#+end_src
*** Custom WM
#+begin_src scheme
(define-system-comp (custom-wm #:key package-name desktop-name executable)
  (packages
   (cons* (private-package
           (name package-name)
           (build-system trivial-build-system)
           (arguments
            `(#:modules ((guix build utils))
              #:builder
              (begin
                (use-modules (guix build utils))
                (let* ((out (assoc-ref %outputs "out"))
                       (xsessions (string-append out "/share/xsessions")))
                  (mkdir-p xsessions)
                  (make-desktop-entry-file
                   (string-append xsessions "/" ,name ".desktop")
                   #:name ,desktop-name
                   #:comment ,desktop-name
                   #:exec ,executable))
                #t))))
          (operating-system-packages os))))
#+end_src
*** Miscellany (nss-certs, GDM, Gnome, backlight control, Nix, bluetooth)
#+begin_src scheme
(define-system-comp (miscellany #:key laptop? nix? bluetooth?)
  (packages
   (cons* (specification->package "nss-certs")
          (operating-system-packages os)))
  (services
   (append
    (if desktop?
        (list (service gdm-service-type
                       (gdm-configuration
                        (xorg-configuration
                         (xorg-configuration
                          (keyboard-layout (operating-system-keyboard-layout os))))))
              (service gnome-desktop-service-type))
        '())
    (if laptop?
        (list (simple-service 'brightnessctl-udev-rules
                              udev-service-type
                              (list brightnessctl)))
        '())
    (if nix?
        (list (service nix-service-type)) '())
    (if bluetooth?
        (list (bluetooth-service #:auto-enable? #t)) '())
    (operating-system-user-services os))))
#+end_src
** Hosts
:PROPERTIES:
:tangle-dir+: hosts
:END:
*** Frostfire
#+begin_src scheme :tangle (in-tangle-dir "frostfire.scm") :noweb yes
(define-module (ebullient system hosts frostfire)
  #:use-module (ebullient system components))

(define-syntax ->
  (syntax-rules ()
    ((_ value) value)
    ((_ value (f1 . body) next ...) (-> (f1 value . body) next ...))
    ((_ value f1 next ...) (-> (f1 value) next ...))))

(define-syntax as->
  (syntax-rules ()
    ((_ expr name) expr)
    ((_ expr name form form* ...)
     (let ((name expr))
       (as-> form name form* ...)))))

(define* (create-os #:key
                    host-name
                    (desktop? #t)
                    (laptop? #t)
                    (macbook? #t)
                    (nix? #t)
                    (bluetooth? #t))
  (-> barebones-os
      (basics #:host-name host-name
              #:timezone "America/Los_Angeles"
              #:locale "en_US.utf8"
              #:keyboard-layout (if macbook?
                                    macbook-kbl #f))
      (boot #:label "genesis"
            #:target "/boot/efi")
      (initial-services #:desktop? desktop?)
      linux-nonfree
      (users #:who '(("<<user-name>>" "<<user-full-name>>" #:admin? #t)
                     ("pcoulson" "Phil Coulson" #:admin? #t)
                     ("gandalf" "Speak Friend and Enter" #:password "mellon" #:salt "toosimple"))
             #:bluetooth? bluetooth?)
      (as-> $
        (if desktop?
            (-> $
                hidpi-console-font
                mtrack
                (custom-wm #:package-name "spartan-wm"
                           #:desktop-name "Spartan WM"
                           #:executable "<<spartan-exe>>"))
            $))
      nonguix-substitutes
      (as-> $
        (if macbook?
            (macbook $ #:bluetooth? bluetooth?) $))
      (miscellany #:desktop desktop?
                  #:laptop? laptop?
                  #:nix? nix?
                  #:bluetooth? bluetooth?)
      (as-> $
        (let* ((persist-dir "/.persist")
               (subvols
                (append
                 `(("root-blank" "/")
                   ("boot" "/boot")
                   ("guix-store" "/gnu/store")
                   ("guix-var" "/var/guix")
                   ("log" "/var/log")
                   ("home" "/home")
                   ("persist" ,persist-dir))
                 (if nix? '(("nix" "/nix") '())))))
          (-> $
              (btrfs #:label "firmament"
                     #:subvols subvols)
              (disk-encryption #:source-uuid "bdda56af-6ca0-4953-bc13-d5af8715e0e5"
                               #:target "ciphered"
                               #:encrypted-mount-points (map cadr subvols))
              (stateless #:persist-dir persist-dir
                         #:bluetooth? bluetooth?))))))

(create-os #:host-name "frostfire")
#+end_src
#+begin_src sh :results output silent :dir (scheme-dir) :async
sudo guix system --load-path=. reconfigure system/hosts/frostfire.scm
#+end_src
* Home
:PROPERTIES:
:tangle-dir+: ebullient/home
:END:
#+name: guix-home-profile
#+begin_src sh
~/.guix-home/profile
#+end_src
#+name: guix-extra-profiles-path
#+begin_src sh
~/.guix-extra-profiles
#+end_src
** ~home-environment~
*** Solitude
- TODO direnv
  RDE and upstream Guix Home have incompatibly diverged for the moment, when they're back in sync:
  + comment the direnv use-module and the `home-bash-direnv-service-type` usage lines back in
  + remove (gnu packages shellutils #:select direnv) from the module definition and remove direnv from the package list
  If it doesn't get resolved before I need to use direnv just copy the direnv service code, it's tiny
#+begin_src scheme :tangle (in-tangle-dir "solitude.scm") :noweb yes
(define-module (solitude)
  #:use-module (guix gexp)
  #:use-module (gnu home)
  #:use-module (gnu home services)
  #:use-module (gnu home services mcron)
  #:use-module (gnu home services shells)
  #:use-module (gnu home services xdg)
  ;; #:use-module (gnu home-services gnupg)
  #:use-module (gnu home-services ssh)
  ;; #:use-module (gnu home-services shellutils)
  #:use-module (gnu home-services version-control)
  #:use-module (gnu packages)
  ;; #:use-module (gnu packages admin)
  ;; #:use-module (gnu packages gnupg)
  ;; #:use-module (gnu packages linux)
  #:use-module ((gnu packages shellutils) #:select (direnv))
  #:use-module (gnu services)
  ;; #:use-module (gnu system keyboard)


  #:use-module ((guix packages) #:select (package-input-rewriting))
  #:use-module ((gnu packages emacs) #:select (emacs emacs-minimal emacs-no-x))
  #:use-module ((flat packages emacs) #:select (emacs-native-comp))


  #:use-module (initialization core)
  #:use-module (spartan core)

  #:use-module (doom-emacs-temp)
  #:use-module (emacs-desktop-environment-temp))

(define emacs-variant emacs-native-comp)

;; TODO Guix Home has an emacs service with a parameter `rebuild-elisp-packages?` that accomplishes I think the same thing as this but it's based on `substitute-keyword-arguments` instead of `package-input-rewriting`. How doe these approaches compare? Update: actually my approach won't do transitive dependencies (and maybe emacs argument like e.g. exwm has?) so it's pretty flawed. Doesn't matter though, I'm not going to be using the guix emacs packages, right?
(define with-emacs-variant
  (package-input-rewriting `((,emacs . ,emacs-variant)
                             (,emacs-minimal . ,emacs-variant)
                             (,emacs-no-x . ,emacs-variant))))

(define solitude
  (home-environment
   ;; (packages (list htop))
   (packages (list direnv
                   ;; emacs-variant ; TODO add this back when I can do so without eating up all my inodes (update: or do I want it in a manifest instead? Or better yet, since [if I recall] the only thing I needed the "direct" access to the emacs program for was running `doom upgrade` just make it a non-propagated input to my eventual Doom guix package. That is, if I even end up running `doom upgrade` after packaging Doom). Also delete bastille manifest
                   (with-emacs-variant spartan)
                   (with-emacs-variant doom-emacs-temp)
                   ;; TODO temp emacs stuff
                   (with-emacs-variant emacs-desktop-environment-temp) ; TODO donno where this should really go
                   (specification->package "font-adobe-source-code-pro"))) ; TODO (propagated) dependency of Doom config, move it somewhere when I figure out how I'm doing Emacs/Doom guix configuration.
   (services
    (list
     (service home-bash-service-type
              (home-bash-configuration
               (environment-variables
                `(("VISUAL" . ,(file-append emacs-variant "/bin/emacsclient"))
                  ("EDITOR" . "$VISUAL")))
               (bash-profile
                `(,(local-file "bash_profile")
                  ,(file-append initialization "/script.sh"))))) ; This shouldn't really be in the bash profile but I can't find a good way to run a script post-login.
     (service home-xdg-user-directories-service-type
              (let* ((xdg-user-subdir "/files")
                     (xdg-dir (lambda (path)
                                (string-append "$HOME" xdg-user-subdir path))))
                (home-xdg-user-directories-configuration
                 (desktop "$HOME/desktop")
                 (documents (xdg-dir "/docs"))
                 (download "$HOME/dl")
                 (music (xdg-dir "/music"))
                 (pictures (xdg-dir "/pics"))
                 (publicshare (xdg-dir "/public"))
                 (templates (xdg-dir "/templates"))
                 (videos (xdg-dir "/vids")))))
     (service home-mcron-service-type
              (home-mcron-configuration
               (jobs
                (list
                 #~(job '(next-hour)
                        (lambda ()
                          (call-with-output-file "/tmp/test-mcron-file"
                            (lambda (port)
                              (display "Output!" port))))
                        "Test mcron output")))))
     (service home-git-service-type
              (home-git-configuration
               (config
                `((user
                   ((name . "<<user-full-name>>")
                    (email . "<<user-email>>")))
                  ;; (http "https://weak.example.com"
                  ;;   ((ssl-verify . #f)))
                  ;; (gpg
                  ;;  ((program . ,(file-append gnupg "/bin/gpg"))))
                  ;; (sendmail
                  ;;  ((annotate . #t)))
                  ))))
     ;; (service home-bash-direnv-service-type)
     (service home-ssh-service-type
              ;; (home-ssh-configuration
              ;;  (extra-config
              ;;   (list
              ;;    (ssh-host "savannah"
              ;;              '((compression . #f))))))
              )
     (simple-service 'rename-me-channels
                     home-files-service-type
                     (list `("config/guix/channels.scm"
                             ,(local-file "channels.scm"))))
     (simple-service 'doomdir
                     home-files-service-type
                     (list `("config/doom"
                             ,(local-file "doom" #:recursive? #t))))
     ;; TODO I think this was my abortive attempt to customize the fonts service
     ;; (simple-service 'my-fontconfig-config-file
     ;;                 home-files-service-type
     ;;                 (list `("config/fontconfig/fonts.conf"
     ;;                         ,(plain-file "fonts.conf" %my-fontconfig-config-file))))
     ;; TODO Examples from RDE I may want to make use of.
     ;; (service home-keyboard-service-type
     ;;          (keyboard-layout "us,ru" "dvorak,"
     ;;                           #:options '("grp:win_space_toggle" "ctrl:nocaps")))
     ;; (service home-gnupg-service-type
     ;;          (home-gnupg-configuration
     ;;           (gpg-agent-config
     ;;            (home-gpg-agent-configuration
     ;;             (ssh-agent? #t)))))
     ;; (service home-state-service-type
     ;;          (append
     ;;           (list
     ;;            (state-rsync "/home/bob/tmp/example-rsync-state/"
     ;;                         "abcdw@olorin.lan:/var/services/homes/abcdw/tmp-state/")
     ;;            (state-git "/home/bob/tmp/talkes/"
     ;;                       "git@git.sr.ht:~abcdw/rde"))))
     ))))

solitude
#+end_src
#+begin_src sh :results output silent :dir (scheme-dir) :async
guix home --load-path=. reconfigure home/solitude.scm
#+end_src
** Bash profile
:PROPERTIES:
:header-args+: :tangle (in-tangle-dir "bash_profile")
:END:
*** Use Guix extra profiles
#+begin_src sh :noweb yes
gepp="<<guix-extra-profiles-path>>"
GUIX_EXTRA_PROFILES="${gepp/#\~/$HOME}"

for i in $GUIX_EXTRA_PROFILES/*; do
  profile=$i/$(basename "$i")
  if [ -f "$profile"/etc/profile ]; then
    GUIX_PROFILE="$profile"
    . "$GUIX_PROFILE"/etc/profile
  fi

  # Emulate guix-home setup-environment file (and thus `/etc/profile` as well). Regarding MANPATH and INFOPATH in particular, see https://guix.gnu.org/en/cookbook/en/guix-cookbook.html#Required-packages
  case $XDG_DATA_DIRS in
    ,*"$profile"/share*) ;;
    ,*) export XDG_DATA_DIRS="$profile"/share:$XDG_DATA_DIRS ;;
  esac
  case $MANPATH in
    ,*"$profile"/share/man*) ;;
    ,*) export MANPATH="$profile"/share/man:$MANPATH
  esac
  case $INFOPATH in
    ,*"$profile"/share/info*) ;;
    ,*) export INFOPATH="$profile"/share/info:$INFOPATH ;;
  esac
  case $XDG_CONFIG_DIRS in
    ,*"$profile"/etc/xdg*) ;;
    ,*) export XDG_CONFIG_DIRS="$profile"/etc/xdg:$XDG_CONFIG_DIRS ;;
  esac
  case $XCURSOR_PATH in
    ,*"$profile"/share/icons*) ;;
    ,*) export XCURSOR_PATH="$profile"/share/icons:$XCURSOR_PATH ;;
  esac

  unset profile
done
#+end_src
*** Load Nix environment
#+begin_src sh
. /run/current-system/profile/etc/profile.d/nix.sh
#+end_src
** Initialization
:PROPERTIES:
:tangle-dir+: initialization
:END:
#+begin_src scheme :tangle (in-tangle-dir "core.scm")
(define-module (initialization core)
  #:use-module (guix gexp)
  #:use-module (guix build-system trivial)
  #:use-module ((gnu packages xorg) #:select (xinput xkbcomp xrandr))
  #:use-module (ebullient utils))

(define-public initialization
  (private-package
   (name "initialization")
   (native-inputs
    `(("script.sh" ,(local-file "script.sh"))
      ("xkb-source" ,(local-file "current_setxkbmap_print.xkb"))
      ("xkb-custom" ,(local-file "xkb_custom" #:recursive? #t))))
   (inputs
    `(("xkbcomp" ,xkbcomp)
      ("xinput" ,xinput)
      ("xrandr" ,xrandr)))
   (build-system trivial-build-system)
   (arguments
    '(#:modules ((guix build utils))
      #:builder
      (begin
        (use-modules (guix build utils))
        (let* ((out (assoc-ref %outputs "out"))
               (get-input (lambda (k)
                            (assoc-ref %build-inputs k)))
               (cmd (lambda* (input #:optional (executable input))
                      (string-append (get-input input) "/bin/" executable)))
               (install-input (lambda* (input-file #:optional (name (basename input-file)))
                                (let ((newfile (string-append out "/" name)))
                                  (mkdir-p (dirname newfile))
                                  (copy-file (get-input input-file) newfile)
                                  newfile))))
          (let ((script-file (install-input "script.sh")))
            (substitute* script-file
              (("xkbcomp") (cmd "xkbcomp"))
              (("xkb_source=" all) (string-append all (get-input "xkb-source")))
              (("xkb_custom=" all) (string-append all (get-input "xkb-custom")))
              (("xinput") (cmd "xinput"))
              (("xrandr") (cmd "xrandr")))))
        #t)))))
#+end_src
*** Script
#+begin_src sh :tangle (in-tangle-dir "script.sh")
xkb_custom=
xkb_source=
xkbcomp -I$xkb_custom $xkb_source $DISPLAY

trackpad_set ()
{
  xinput set-prop "bcm5974" "$@"
}
trackpad_set "Device Accel Profile" 2
trackpad_set "Trackpad Sensitivity" 0.08
trackpad_set "Trackpad Edge Sizes" 15, 15, 15, 15 # TODO make the sides smaller (like macOS). Maybe turn the top and bottom down a bit too.
trackpad_set "Trackpad Scroll Settings" 150, 10, 0 # TODO trying this out, doesn't seem to do anything in chromium, maybe a full restart?
trackpad_set "Trackpad Scroll Coasting" 0.05 200
trackpad_set "Trackpad Scroll Buttons" 5, 4, 7, 6 # Invert vertical and horizontal scrolling.
trackpad_set "Trackpad Drag Settings" 0, 350, 40, 200, 500 # First value disables, others are defaults.
# Three-finger dragging
trackpad_set "Trackpad Swipe Settings" 1, 0, 1000
trackpad_set "Trackpad Swipe Buttons" 1, 1, 1, 1
# Trying out
trackpad_set "Trackpad Swipe Settings" 1, 0, 1500
trackpad_set "Trackpad Palm Detection" 1, 0
trackpad_set "Trackpad Palm Size" 30
# trackpad_set "Trackpad Scroll Settings" 250, 10, 0
trackpad_set "Trackpad Hold1Move1 Stationary Settings" 20, 0 # First value is the default, second value disables. # TODO I think?
trackpad_set "Trackpad Edge Scroll Settings" 105, 20, 0, 0, 0, 0, 0 # First three values are defaults, last four disable. # TODO I think? Otherwise disable by just setting the distance really high?

xrandr --fb 2724x1800 --output eDP-1 --transform 1,0,-156,0,1,0,0,0,1
#+end_src
*** XKB
- TODO I'm using "C" for the xkb syntax currently, what should it be / is there a value for "no language"? Don't do this until the end.
**** current_setxkbmap_print
#+begin_src c :tangle (in-tangle-dir "current_setxkbmap_print.xkb")
xkb_keymap {
	xkb_keycodes  { include "evdev+aliases(qwerty)"	};
	xkb_types     { include "complete+numpad(mac)"	};
	xkb_compat    { include "complete"	};
	xkb_symbols   { include "pc+macintosh_vndr/us+inet(evdev)+ctrl(nocaps)+shift(both_capslock)+mysymbols(semicolon_to_control)"	};
	xkb_geometry  { include "macintosh(macbook78)"	};
};
#+end_src
**** Custom
#+begin_src c :tangle (in-tangle-dir "xkb_custom/symbols/mysymbols")
partial modifier_keys
xkb_symbols "semicolon_to_control" {
    key <AC10> { [ Control_R, colon ] };
    modifier_map Control { <AC10> };
};
#+end_src
** Guix extra profiles
:PROPERTIES:
:tangle-dir+: manifests
:END:
#+name: install-profiles
#+begin_src sh :results output silent :dir (get-tangle-dir) :noweb yes :async
gepp="<<guix-extra-profiles-path>>"
GUIX_EXTRA_PROFILES="${gepp/#\~/$HOME}"

profiles=$*
if [[ $# -eq 0 ]]; then
    profiles="*";
fi

for profile in $profiles; do
  profileName=$(basename $profile .scm)
  profilePath="$GUIX_EXTRA_PROFILES/$profileName"
  mkdir -p $profilePath
  guix package --profile="$profilePath/$profileName" --manifest="$profileName.scm"
done
#+end_src
#+call: install-profiles[:cmdline ...]()

#+name: upgrade-profiles
#+begin_src sh :results output silent :dir (get-tangle-dir) :noweb yes :async
gepp="<<guix-extra-profiles-path>>"
GUIX_EXTRA_PROFILES="${gepp/#\~/$HOME}"

profiles=$*
if [[ $# -eq 0 ]]; then
    profiles="$GUIX_EXTRA_PROFILES/*";
fi

for profile in $profiles; do
  profileName=$(basename $profile)
  profilePath="$GUIX_EXTRA_PROFILES/$profileName"
  guix package --profile="$profilePath/$profileName" --manifest="$profileName.scm"
done
#+end_src
#+call: upgrade-profiles[:cmdline ...]()
*** Manifests
#+name: guix-extra-profile-path
#+begin_src sh :var profileName="" :noweb yes
echo "<<guix-extra-profiles-path>>/$profileName/$profileName"
#+end_src
**** multiverse
#+begin_src scheme :tangle (in-tangle-dir "multiverse.scm")
(specifications->manifest
 '("ungoogled-chromium"
   "ublock-origin-chromium" ; For/with ungoogled-chromium
   "protonvpn-cli"

   "btrfs-progs" ; TODO "depends on"/"exists because of" the stateless module. Maybe it should be in some "system administration" section of Home config

   ;; Code
   "clojure-tools" ; TODO comes from nonguix channel, I might be making that explicit later
   "icedtea" ; For clojure-tools ; TODO can I make this a non-propagated input to "clojure-tools" (`substitute*' or `wrap-program'? Automatic in some way?) or is that a bad idea / a pain?

   "flatpak"

   ;; General
   "xdg-utils"
   "gtk+:bin"
   "curl"
   "zip"
   "unzip"

   ;; Nice-to-have ; TODO might get rid of these and just `guix shell' or install as-needed
   "tree"
   "woof"

   ;; Apps
   ;; "gimp" ; TODO maybe. Or just install as-needed with `guix shell`
   ))
#+end_src
#+begin_src elisp :noweb-ref guix-extra-profiles :noweb-sep " " :noweb yes
"<<guix-extra-profile-path("multiverse")>>"
#+end_src
**** bastille
#+begin_src scheme :tangle (in-tangle-dir "bastille.scm")
;; TODO Getting rid of this (either putting it in "multiverse" manifest or in solitude). Make it a reference to emacs-variant.
(specifications->manifest
 '("emacs-native-comp"))
#+end_src
#+begin_src elisp :noweb-ref guix-extra-profiles :noweb-sep " " :noweb yes
"<<guix-extra-profile-path("bastille")>>"
#+end_src
** Channels
#+begin_src scheme :tangle (in-tangle-dir "channels.scm")
(cons* (channel
        (name 'flat)
        (url "https://github.com/flatwhatson/guix-channel.git")
        (introduction
         (make-channel-introduction
          "33f86a4b48205c0dc19d7c036c85393f0766f806"
          (openpgp-fingerprint
           "736A C00E 1254 378B A982  7AF6 9DBE 8265 81B6 4490"))))
       (channel
        (name 'rde)
        (url "https://git.sr.ht/~abcdw/rde")
        (introduction
         (make-channel-introduction
          "257cebd587b66e4d865b3537a9a88cccd7107c95"
          (openpgp-fingerprint
           "2841 9AC6 5038 7440 C7E9  2FFA 2208 D209 58C1 DEB0"))))
       (channel
        (name 'nonguix)
        (url "https://gitlab.com/nonguix/nonguix")
        (introduction
         (make-channel-introduction
          "897c1a470da759236cc11798f4e0a5f7d4d59fbc"
          (openpgp-fingerprint
           "2A39 3FFF 68F4 EF7A 3D29  12AF 6F51 20A0 22FB B2D5"))))
       %default-channels)

;; (append (channel
;;          (name 'flat)
;;          (url "https://github.com/flatwhatson/guix-channel.git")
;;          (introduction
;;           (make-channel-introduction
;;            "33f86a4b48205c0dc19d7c036c85393f0766f806"
;;            (openpgp-fingerprint
;;             "736A C00E 1254 378B A982  7AF6 9DBE 8265 81B6 4490")))
;;          (commit "7b8353ebbcf486e3344924d1cac0fa7ba47c371d"))
;;         (channel
;;          (name 'rde)
;;          (url "https://git.sr.ht/~abcdw/rde")
;;          (introduction
;;           (make-channel-introduction
;;            "257cebd587b66e4d865b3537a9a88cccd7107c95"
;;            (openpgp-fingerprint
;;             "2841 9AC6 5038 7440 C7E9  2FFA 2208 D209 58C1 DEB0")))
;;          (commit "930b9aa377cd4b2fbf43e39b2583df27b70f8ad0"))
;;         (channel
;;          (name 'nonguix)
;;          (url "https://gitlab.com/nonguix/nonguix")
;;          (introduction
;;           (make-channel-introduction
;;            "897c1a470da759236cc11798f4e0a5f7d4d59fbc"
;;            (openpgp-fingerprint
;;             "2A39 3FFF 68F4 EF7A 3D29  12AF 6F51 20A0 22FB B2D5")))
;;          (commit "706d8af5b111d85902280f1154dc4fad683b5281"))
;;         (channel
;;          (name 'guix)
;;          (url "https://git.savannah.gnu.org/git/guix.git")
;;          (introduction
;;           (make-channel-introduction
;;            "9edb3f66fd807b096b48283debdcddccfea34bad"
;;            (openpgp-fingerprint
;;             "BBB0 2DDF 2CEA F6A8 0D1D  E643 A2A0 6DF2 A33A 54FA")))
;;          (commit "20dfda3d9ebb14b72ed33fed940ee3a1f030c99a")))
#+end_src
** Doom
:PROPERTIES:
:tangle-dir+: doom
:END:
*** Init
:PROPERTIES:
:header-args+: :tangle (in-tangle-dir "init.el")
:END:
**** Header
#+begin_src elisp
;;; -*- lexical-binding: t; -*-
#+end_src
**** ~doom!~ block
#+begin_src elisp
(doom! :completion
       company
       (ivy +icons)

       :ui
       doom
       doom-dashboard
       (emoji +unicode)
       hl-todo
       hydra
       indent-guides
       (ligatures +extra)
       modeline
       nav-flash
       ophints
       (popup +defaults +all)
       treemacs
       vc-gutter
       vi-tilde-fringe
       window-select
       workspaces

       :editor
       (evil +everywhere)
       file-templates
       fold
       format
       lispy
       multiple-cursors
       rotate-text
       snippets
       word-wrap

       :emacs
       (dired +icons)
       electric
       (ibuffer +icons)
       undo
       vc

       :term
       eshell
       vterm

       :checkers
       syntax

       :tools
       direnv
       (eval +overlay)
       lookup
       (magit +forge)
       (pass +auth)
       pdf
       prodigy
       rgb
       taskrunner

       :lang
       clojure
       data
       emacs-lisp
       json
       javascript
       markdown
       (org +journal)
       rest
       (scheme +guile)
       sh
       web
       yaml ; TODO this should probably be specific to the krush/hyperdrive/afterburner(?) project

       :app
       calendar

       :config
       (default +bindings +smartparens))
#+end_src
*** Config
:PROPERTIES:
:header-args+: :tangle (in-tangle-dir "config.el")
:END:
**** Header
#+begin_src elisp
;;; -*- lexical-binding: t; -*-
#+end_src
**** Requires
#+begin_src elisp
(use-package! dash)
#+end_src
**** Personal Info :user:
#+begin_src elisp :noweb yes
(setq user-full-name "<<user-full-name>>"
      user-mail-address "<<user-email>>")
#+end_src
**** Locals :path:
#+begin_src elisp
(defconst biome--org-dir (concat org-directory "~/org"))
(defconst biome--org-gcal-dir (concat biome--org-dir "/gcal"))

(defconst biome--very-big 1000000)
#+end_src
**** General :UI:path:
#+begin_src elisp
;; hlissner says this must be set before org loads. I'm not sure if this is a requirement of org-mode but the Doom org config certainly does a lot of gymnastics with this variable so I'll just set this exactly like the example config does.
(setq org-directory biome--org-dir)

(setq scroll-margin 10
      save-interprogram-paste-before-kill t)

;; I like having line numbers on but hlissner says they're slow so I might want to disable them at some point. Keep in mind I use them to determine what lines are continuation lines so I might have to make the right fringe bigger if I do this and set visual-line-fringe-indicators.
;; (setq display-line-numbers-type nil)
#+end_src
***** Doom resets
#+begin_src elisp
(setq-default indent-tabs-mode t)

;; I'd like to have this on but in the Doom code it says it's more efficient not to.
;; (setq-default cursor-in-non-selected-windows t)
#+end_src
**** Doom
***** UI :UI:theming:
#+begin_src elisp
(setq doom-theme 'doom-nuclear
      doom-font (font-spec :family "Source Code Pro" :size 24))
#+end_src
***** Leader/Localleader :bindings:
#+begin_src elisp
(setq doom-leader-alt-key "s-SPC"
      doom-localleader-key "s-m"
      doom-localleader-alt-key "s-m")
#+end_src
**** Keybindings :bindings:
#+begin_src elisp
(setq help-char (string-to-char "\C-_"))
#+end_src
***** Translations
#+begin_src elisp
(defun biome--trans (&rest rest)
  (-each (-partition 2 rest)
    (-lambda ((to from))
      (define-key key-translation-map (kbd to) (kbd from)))))

(biome--trans "C-h" "DEL"
              "C-?" "C-h"

              "s-i" "<tab>"
              "s-I" "<backtab>"

              "s-h" "<left>"
              "s-j" "<down>"
              "s-k" "<up>"
              "s-l" "<right>")
#+end_src
***** General
#+begin_src elisp
(defalias 'original-yank-pop #'yank-pop)

;; REVIEW Some of these should be in `:after' (or their respective package) sections but I'm not totally certain where I want to put bindings yet and I'm lazy.
(map! "s-V" #'original-yank-pop

      "s-SPC" doom-leader-map

      ;; Copied from Doom macOS bindings: ~/.config/emacs/modules/config/default/config.el:263
      "s-`" #'other-frame
      "s-n" #'+default/new-buffer
      "s-z" #'undo
      "s-Z" #'redo
      "s-c" (if (featurep 'evil) #'evil-yank #'copy-region-as-kill)
      "s-v" #'yank
      "s-s" #'save-buffer
      "s-x" #'execute-extended-command
      :v "s-x" #'kill-region
      "s-/" (cmd! (save-excursion (comment-line 1)))
      :n "s-/" #'evilnc-comment-or-uncomment-lines
      :v "s-/" #'evilnc-comment-operator

      "s-t" (lookup-key doom-leader-map (kbd "`"))
      "s-f" (cl-flet ((f (lookup-key doom-leader-map (kbd "s b"))))
              ;; `swiper' hangs initially when `visual-line-mode' is active. Plus Doom defaults to having `visual-line-mode' enabled in text-mode (and derived) buffers where it makes more sense to not search linewise.
              (cmd! (if visual-line-mode
                        (letf! ((#'swiper #'swiper-isearch))
                          (f))
                      (f))))
      "s-r" (lookup-key doom-leader-map (kbd "f r"))
      "s-w" (lookup-key doom-leader-map (kbd "b k"))
      "s-d w" (lookup-key doom-leader-map (kbd "w d"))
      "s-d s-w" (cmd! (kill-current-buffer)
                      (+workspace/close-window-or-workspace))
      "s-g" (lookup-key doom-leader-map (kbd "g g"))
      "s-," (lookup-key doom-leader-map (kbd "w w"))
      "s-<" (lookup-key doom-leader-map (kbd "w W"))
      "s-y" (lookup-key doom-leader-map (kbd "i y"))
      "s-{" (lookup-key doom-leader-map (kbd "b p"))
      "s-}" (lookup-key doom-leader-map (kbd "b n"))
      "s-p" (lookup-key global-map (kbd "C-~")) ; TODO if I'm keeping this, improve it to first switch focus to a/the popup window if one isn't focused already

      "s-u" (lookup-key doom-leader-map (kbd "u"))
      "s-U" #'negative-argument         ; Trying this out.
      (:map universal-argument-map
       "s-u" #'universal-argument-more)

      (:after evil-easymotion
       "s-a" (lookup-key evilem-map (kbd "SPC")))

      "s-." #'repeat

      "s-J" #'evil-scroll-down
      "s-K" #'evil-scroll-up

      (:prefix "s-d"
       "." #'repeat-complex-command

       "h" #'git-gutter:popup-hunk
       ;; "o" #'+macos/open-in-default-program ;; TODO consider a Guix alternative? Meh.
       "r" #'projectile-replace
       "t" #'tldr
       "s" #'org-save-all-org-buffers
       "a" #'link-hint-open-multiple-links
       ;; "b" (cmd! (evil-local-mode 'toggle)
       ;;           (when evil-local-mode (evil-normal-state)))
       (:prefix "c"
        "f" #'org-gcal-fetch
        "s" #'org-gcal-sync
        "p" #'org-gcal-post-at-point)))
#+end_src
**** Packages
***** All-the-icons Dired
#+begin_src elisp
(after! all-the-icons-dired
  (setq all-the-icons-dired-monochrome nil))
#+end_src
***** Avy
#+begin_src elisp
;; REVIEW Trying out not having this so I can use avy dispatch commands.
;; (after! avy
;;   (setq avy-single-candidate-jump t))
#+end_src
***** Clojure :lang:clojure:bindings:
#+begin_src elisp
(use-package! clojure-mode
  :defer t
  :init
  (setq clojure-refactor-map-prefix (kbd "s-M r")) ; Has to be set before clojure-mode loads. ; TODO temporary binding
  :config
  (set-ligatures! 'clojure-mode :lambda "fn"))
#+end_src
***** Cider :lang:clojure:persistence:
#+begin_src elisp
(after! cider
  (setq cider-repl-history-size biome--very-big
        cider-print-options '(("length" 100))))

;; TODO make sure this is still working after nesting in `after!'
(after! cider-repl
  (add-hook! 'cider-repl-mode-hook
             #'goto-address-prog-mode
             #'highlight-numbers-mode
             #'rainbow-delimiters-mode
             #'yas-minor-mode-on
             #'biome-sp-strict-h))
#+end_src
***** Clj Refactor :lang:clojure:bindings:
#+begin_src elisp
(after! clj-refactor
  (cljr-add-keybindings-with-prefix "s-M R")) ; TODO temporary binding
#+end_src
***** Counsel :completion:UI:
#+begin_src elisp
(after! counsel
  (setq counsel-yank-pop-separator "\n--------------------------------\n"))
#+end_src
***** Doom Modeline :UI:
#+begin_src elisp
(after! doom-modeline
  ;; (setq doom-modeline-checker-simple-format nil)
  (setq doom-modeline-major-mode-icon t)
  (setq doom-modeline-persp-name t))
#+end_src
***** Doom Themes :UI:
#+begin_src elisp
;; TODO get rid of this if I'm not going to try it out again
;; (after! doom-themes
;;   (doom-themes-visual-bell-config))
#+end_src
***** Emacs Lisp :lang:
#+begin_src elisp
(after! elisp-mode
  (setq-hook! 'emacs-lisp-mode-hook indent-tabs-mode nil))
#+end_src
***** Emojify :UI:
#+begin_src elisp
(after! emojify
  (setq emojify-display-style 'unicode))
#+end_src
***** Eshell :persistence:
#+begin_src elisp
(after! eshell
  (setq eshell-history-size biome--very-big)) ; Setting this to `nil' to inherit envvar HISTSIZE is another option.
#+end_src
***** Evil :UI:theming:
#+begin_src elisp
(after! evil
  (setq evil-default-cursor (lambda () (evil-set-cursor-color "#fdd94a"))
        evil-emacs-state-cursor (lambda () (evil-set-cursor-color "#ff9999"))))
#+end_src
***** Evil Org :org:bindings:
#+begin_src elisp
(after! evil-org
  (map! :map evil-org-mode-map
        :nv "C-j" #'outline-forward-same-level
        :nv "C-k" #'outline-backward-same-level))
#+end_src
***** Evil Multiedit
#+begin_src elisp
(after! evil-multiedit
  (setq evil-multiedit-follow-matches t))
#+end_src
***** Expand Region :bindings:
#+begin_src elisp
(use-package! expand-region
  :defer t
  :init
  (map! :nv "s-e" #'er/expand-region
        :nv "s-E" #'er/contract-region)
  :config
  (setq expand-region-fast-keys-enabled nil) ; My mapping is conventient enough and I don't want the repeat key to conflict with anything.
  ;; Copied from Doom config: ~/.config/emacs/modules/config/default/+emacs.el:12
  (defadvice! biome--quit-expand-region-a (&rest _)
    "Properly abort an expand-region region."
    :before '(evil-escape doom/escape)
    (when (memq last-command '(er/expand-region er/contract-region))
      (er/contract-region 0))))
#+end_src
***** Geiser :persistence:path:guix:
#+begin_src elisp
(use-package! geiser
  :defer t
  :init
  ;; It seems like it would be okay to not set variables in `:init' but hlissner does it this way for the Geiser package so I will too.
  (setq geiser-repl-current-project-function #'ignore) ; Reset this back to its default (don't have separate REPLs for projects) because it doesn't play nice with the Guix store.
  (setq geiser-repl-history-filename (concat doom-cache-dir "geiser-history")))
#+end_src
***** Highlight Indent Guides :lang:prog_mode:UI:
#+begin_src elisp
(use-package! highlight-indent-guides
  :defer t
  :init
  ;; I don't want indent guides on by default, remove all the Doom module's hooks.
  (remove-hook! '(prog-mode-hook
                  text-mode-hook
                  conf-mode-hook)
    #'highlight-indent-guides-mode))
#+end_src
***** Ivy :completion:bindings:UI:
#+begin_src elisp
(after! ivy
  (setq +ivy-buffer-preview t
        ivy-extra-directories nil
        ivy-count-format "(%d/%d) ")
  (dolist (i '(counsel-yank-pop
               counsel-evil-registers))
    (add-to-list 'ivy-height-alist `(,i . 10)))

  (map! :map ivy-minibuffer-map
        "s-J" #'ivy-scroll-up-command
        "s-K" #'ivy-scroll-down-command
        "C-r" #'ivy-reverse-i-search ; Doom overrides this, restore it.
        :map ivy-reverse-i-search-map
        "C-k" #'previous-line
        "s-D" #'ivy-reverse-i-search-kill)) ; TODO temporary binding
#+end_src
***** Ivy Hydra :completion:bindings:
#+begin_src elisp
(after! ivy-hydra
  (defhydra+ hydra-ivy ()
    ;; Doom overrides these imporant ivy hydra heads: ~/.config/emacs/modules/completion/ivy/autoload/hydras.el
    ("m" ivy-mark)
    ("u" ivy-unmark)
    ("t" ivy-toggle-marks)))
#+end_src
***** Lispy :lisp:
#+begin_src elisp
(use-package! lispy
  :defer t
  :init
  ;; Not using lispy, remove all the Doom module's hooks.
  (remove-hook! '(lisp-mode-hook
                  emacs-lisp-mode-hook
                  ielm-mode-hook
                  scheme-mode-hook
                  racket-mode-hook
                  hy-mode-hook
                  lfe-mode-hook
                  dune-mode-hook
                  clojure-mode-hook
                  fennel-mode-hook)
    #'lispy-mode)
  (remove-hook! 'eval-expression-minibuffer-setup-hook #'doom-init-lispy-in-eval-expression-h))
#+end_src
***** Lispyville :lisp:lang:prog_mode:bindings:
#+begin_src elisp
(use-package! lispyville
  :hook (prog-mode . lispyville-mode)
  :init
  (setq lispyville-key-theme nil) ; Prevent Doom module's invocation of `lispyville-set-key-theme' from doing anything.
  :config
  (lispyville-set-key-theme
   '(operators
     c-w
     c-u
     commentary))
  (map! :map lispyville-mode-map
        "s-C-j" #'lispyville-beginning-of-next-defun
        "s-C-k" #'lispyville-beginning-of-defun
        "s-C-," #'lispyville-end-of-defun
        "s-C-a" #'lispyville-drag-backward
        "s-C-g" #'lispyville-drag-forward
        "s-C-p" #'lispyville-prettify
        (:prefix "s-C-;"
         "R" #'lispyville-raise-list)))
#+end_src
***** Magit :UI:
#+begin_src elisp
(after! magit
  (setq git-commit-style-convention-checks '(non-empty-second-line))
  (setq magit-revision-show-gravatars '("^Author:     " . "^Commit:     ")))
#+end_src
***** Man :guix:
#+begin_src elisp :noweb yes
(after! man
  (prependq! Man-header-file-path
             (-concat (-map (lambda (p)
                              (concat p "/include"))
                            '(<<guix-extra-profiles>>))
                      '("<<guix-home-profile>>/include"))))
#+end_src
***** Org :org:UI:path:
#+begin_src elisp
(after! org
  (setq org-agenda-files `(,biome--org-dir
                           ,biome--org-gcal-dir
                           ,(concat biome--org-dir "/projects"))
        org-log-done 'time
        org-priority-lowest ?E
        org-priority-default ?C
        org-priority-faces `((?A . ,(doom-color 'red))
                             (?B . ,(doom-color 'orange))
                             (?C . ,(doom-color 'blue))
                             (?D . ,(doom-color 'yellow))
                             (?E . ,(doom-color 'green)))))
#+end_src
***** Org Gcal :user:secret:persistence:path:
#+begin_src elisp
(after! org-gcal
  (setq org-gcal-client-id "446729771716-pp79934q99aro2h8v3iki1fejcodbdoo.apps.googleusercontent.com"
        org-gcal-client-secret (-> (auth-source-search :host org-gcal-client-id) car (plist-get :secret) funcall)
        org-gcal-fetch-file-alist `((user-mail-address . ,(concat biome--org-gcal-dir "/" user-mail-address ".org"))
                                    ("addressbook%23contacts@group.v.calendar.google.com" . ,(concat biome--org-gcal-dir "/contacts.org"))
                                    ("en.usa%23holiday@group.v.calendar.google.com" . ,(concat biome--org-gcal-dir "/holidays.org")))
        org-gcal-recurring-events-mode 'nested))
#+end_src
***** Org Persist :persistence:path:
#+begin_src elisp
(use-package! org-persist
  :defer t
  :init
  (setq org-persist-directory (concat doom-cache-dir "org-persist/")))
#+end_src
***** Paren :UI:
#+begin_src elisp
(after! paren
  (setq! show-paren-delay 0))
#+end_src
***** Prog Mode :lang:prog_mode:
#+begin_src elisp
(add-hook! 'prog-mode-hook #'biome-sp-strict-h)
#+end_src
***** Rainbow Delimiters :UI:theming:
#+begin_src elisp
(after! rainbow-delimiters
  (setq rainbow-delimiters-max-face-count 8)) ; TODO make sure this is working and I didn't need to put it in an `:init'`or anything
#+end_src
***** Recentf :persistence:
#+begin_src elisp
(after! recentf
  (setq recentf-max-saved-items 500))
#+end_src
***** Smartparens :bindings:
#+begin_src elisp
(after! smartparens
  (map! :map smartparens-mode-map
        "s-C-h" #'sp-backward-sexp
        "s-C-l" #'sp-forward-sexp
        "s-C-u" #'sp-backward-up-sexp
        "s-C-o" #'sp-up-sexp
        :gn "s-C-m" #'sp-backward-down-sexp ; Bind in normal mode explicitly to override the Doom mapping in ~/.config/emacs/modules/config/default/config.el:447
        "s-C-." #'sp-down-sexp
        "s-C-c" #'sp-splice-sexp
        "s-C-s" #'sp-splice-sexp-killing-backward
        "s-C-f" #'sp-splice-sexp-killing-forward
        "s-C-x" #'sp-backward-slurp-sexp
        "s-C-v" #'sp-forward-slurp-sexp
        "s-C-w" #'sp-backward-barf-sexp
        "s-C-r" #'sp-forward-barf-sexp
        (:prefix "s-C-;"
         "(" #'sp-wrap-round
         "[" #'sp-wrap-square
         "{" #'sp-wrap-curly
         "s" #'sp-split-sexp
         "j" #'sp-join-sexp
         "r" #'sp-raise-sexp
         "c" #'sp-convolute-sexp
         "w" #'sp-rewrap-sexp)))
#+end_src
****** Hook :bindings:
#+begin_src elisp
(defun biome-sp-strict-h ()
  (add-hook! 'smartparens-enabled-hook :local
             #'turn-on-smartparens-strict-mode
             (defun biome-modify-sp-strict-mode-map-h ()
               (map! :map smartparens-strict-mode-map
                     :i "DEL" #'sp-backward-delete-char))))
#+end_src
***** Tldr :persistence:path:
#+begin_src elisp
(use-package! tldr
  :defer t
  :config
  (setq tldr-directory-path (concat doom-etc-dir "tldr/")))
#+end_src
***** Tramp :path:guix:
Make tramp work on Guix. Tramp is used locally to do sudo from inside Emacs so include my user-specific paths too.
#+begin_src elisp :noweb yes
(after! tramp
  (prependq! tramp-remote-path
             (-concat (-map (lambda (p)
                              (concat p "/bin"))
                            '(<<guix-extra-profiles>>))
                      '("<<guix-home-profile>>/bin"
                        "~/.config/guix/current/bin"
                        "~/.guix-profile/bin"
                        "~/.guix-profile/sbin"
                        "/run/current-system/profile/bin"
                        "/run/current-system/profile/sbin"))))
#+end_src
***** Transient :persistence:
#+begin_src elisp
(after! transient
  (setq transient-history-limit biome--very-big))
#+end_src
***** Undo Fu
#+begin_src elisp
(after! undo-fu
  (setq undo-fu-ignore-keyboard-quit t))
#+end_src
***** Undo Tree :UI:
- TODO am I commenting code, doing notangle, or using the org ~COMMENT~ keyword (https://orgmode.org/manual/Comment-Lines.html)?
#+begin_src elisp
;; (after! undo-tree
;;   (setq undo-tree-visualizer-timestamps t))
#+end_src
**** Guix System :guix:
- TODO The Guix repo offers some [[https://github.com/guix-mirror/guix/tree/master/etc/snippets][snippets]] and less importantly a copyright inserter I'd like to use ([[https://guix.gnu.org/manual/en/guix.html#The-Perfect-Setup][described here]]) but I don't know where if anywhere the repo code lives on my machine.
#+begin_src elisp
;; (let ((guix-source-path "???/guix"))

;;   (after! yasnippet
;;     (add-to-list 'yas-snippet-dirs (concat guix-source-path "/etc/snippets")))

;;   (after! skeleton
;;     (load-file (concat guix-source-path "/etc/copyright.el")))

;;   (after! copyright
;;     (setq copyright-names-regexp (format "%s <%s>" user-full-name user-mail-address))))
#+end_src
**** Projects
***** Hyperdrive :path:
#+begin_src elisp
(pushnew! safe-local-variable-values
          '(cider-preferred-build-tool . shadow-cljs)
          '(cider-default-cljs-repl . shadow)
          '(cider-shadow-default-options . ":app")
          '(cider-offer-to-open-cljs-app-in-browser . nil)
          '(cider-clojure-cli-global-options . "-A:dev")
          '(eval . (setenv "DATOMIC_APP_INFO_MAP" "{:app-name \"neutrino\"}"))
          '(eval . (setenv "DATOMIC_ENV_MAP" "{:env :dev}"))
          '(cider-clojure-cli-global-options . nil))

(prodigy-define-service
  :name "Amplify Mock"
  :command "amplify"
  :args '("mock")
  :cwd "~/projects/Krush/hyperdrive/apps/singularity"
  :kill-process-buffer-on-stop t)

(prodigy-define-service
  :name "Datomic Access (exogenesis)"
  :command "bash"
  :args '("datomic" "client" "access" "exogenesis")
  :cwd "~/projects/Krush/hyperdrive/ion/team"
  :kill-process-buffer-on-stop t)
#+end_src
***** Massrealty :path:
#+begin_src elisp
;; (pushnew! safe-local-variable-values
;;           '(ssh-deploy-root-remote . "/ssh:massrealty@35.196.144.73:/home/massrealty/deploy/homes/public_html/")
;;           '(ssh-deploy-automatically-detect-remote-changes . t))

;; (after! org-gcal
;;   (add-to-list 'org-gcal-fetch-file-alist `("krzysztof@massrealty.com" . ,(concat biome--org-gcal-dir "/krzysztof@massrealty.com.org")) 'append))
#+end_src
**** WIP
#+begin_src elisp
(after! org
  (add-to-list 'org-agenda-files (concat biome--org-dir "/spring_cleaning") 'append))

;; (map! "s-b" (cmd!
;;              ;; (message "chainging margin")
;;              ;; (message "%s" (selected-window))
;;              (set-window-margins (selected-window) nil (if (cdr (window-margins))
;;                                                            nil 12))))

;; Run this only when not on EXWM (probably not strictly necessary have this condition)
;; (add-to-list 'initial-frame-alist '(fullscreen . fullboth))

(map! "s-A" #'counsel-linux-app)

(map! :leader
      "s-," (lookup-key doom-leader-map (kbd "<")))

(after! company
  (map! (:map company-active-map
         "s-[" #'company-show-doc-buffer ; Currently opens Help, it would be better if I made it use Helpful.
         "s-]" #'company-show-location)))

(after! evil-org
  (map! :map evil-org-mode-map
        (:prefix "g"
         :nv "{" #'evil-backward-paragraph
         :nv "}" #'evil-forward-paragraph)))

;; TODO Maybe do this if popping to the side is too annoying
;; (after! geiser-repl
;;   (setq geiser-repl-use-other-window nil))
#+end_src
***** Dotfiles auto-tangle :path:
- TODO Might be easier to do this with file-local variables.
#+begin_src elisp
;; (setq biome--dotfiles-dir "~/projects/dotfiles")

;; (add-hook! 'org-mode-hook
;;   (defun biome-add-org-autotangle-after-save-hook-h ()
;;     (add-hook! 'after-save-hook :local
;;       (defun biome-autotangle-h ()
;;         (when (file-in-directory-p buffer-file-name biome--dotfiles-dir)
;;           ;; TODO ensure there aren't files in the output directory that no longer correspond to the org file. Just wipe it?
;;           (let ((org-confirm-babel-evaluate nil))
;;             (org-babel-tangle)))))))
#+end_src
***** Scheme :lang:
#+begin_src elisp
(after! scheme
  (setq-hook! 'scheme-mode-hook indent-tabs-mode nil))
#+end_src
***** Guix :guix:
****** Common :UI:
#+begin_src elisp
(after! guix
  (set-popup-rules!
    '(("^\\*Guix" :height 0.5))))
#+end_src
****** Devel :lang:
#+begin_src elisp
(use-package! guix-devel
  :hook (scheme-mode . guix-devel-mode))
#+end_src
****** Popup :bindings:
#+begin_src elisp
(use-package! guix-popup
  :defer t
  :init
  (map! :leader
        "a" #'guix))  ; TODO temporary binding?
#+end_src
****** Prettify :UI:
#+begin_src elisp
(use-package! guix-prettify
  :hook (doom-first-buffer . global-guix-prettify-mode))
#+end_src
***** Dired-X :UI:hidden:
#+begin_src elisp
(use-package! dired-x
  :defer t
  :init
  ;; Don't hide things by default. I can't just remove the Doom module's hook or its whole dired-x `use-package!' won't get run, so instead add another hook for `dired-omit-mode' at the end of the hooks list to toggle it off.
  (add-hook! 'dired-mode-hook :append
    (defun biome-disable-dired-omit-mode-h ()
      (dired-omit-mode -1))))
#+end_src
***** Counsel :UI:completion:hidden:
#+begin_src elisp
(after! counsel
  (setq counsel-find-file-ignore-regexp nil)) ; I may want to instead just toggle off `ivy-use-ignore' on invoking `counsel-find-file' so I have the option of switching ignoring back as-needed.
#+end_src
***** Projects
****** Dotfiles
#+begin_src elisp
(pushnew! safe-local-variable-values
          '(eval . (with-eval-after-load 'geiser-guile
                     (let ((root-dir
                            (file-name-directory
                             (locate-dominating-file default-directory ".dir-locals.el"))))
                       (make-local-variable 'geiser-guile-load-path)
                       (add-to-list 'geiser-guile-load-path root-dir)))))
#+end_src
*** Packages
#+begin_src elisp :tangle (in-tangle-dir "packages.el")
;; -*- no-byte-compile: t; -*-

(package! bluetooth :pin "147d4690087049c6647b5222ee40baa5002b7586") ; TODO just maybe make this dependent on my "bluetooth feature"
(package! dash :pin "da167c51e9fd167a48d06c7c0ee8e3ac7abd9718") ; TODO make this be introduced by my doom config (where I need it)?
(package! expand-region :pin "95a773bd8f557cbd43d3b2dab2fa4417ec5927ab")
(package! tldr :pin "d3fd2a809a266c005915026799121c78e8b358f0")
(package! trashed :pin "23e782f78d9adf6b5479a01bfac90b2cfbf729fe")
(package! symon :pin "8dd8b6df49b03cd7d31b85aedbe9dd08fb922335")

(package! guix :pin "c9aef52121b458297e70bb50f49f7276b4a8d759")
(package! build-farm :pin "5c268a3c235ace0d79ef1ec82c440120317e06f5") ; REVIEW trying out
(package! guix-packaging ; REVIEW trying out
  :recipe (:host github
           :repo "ryanprior/emacs-guix-packaging"
           :files (:defaults "snippets"))
  :pin "d843088252467db3c8a09de40ae9a62050196a0e")

;; TODO these should probably be introduced by my exwm desktop environment org section or something
(package! exwm :pin "833e5d89e7fc12e79766454ae9982cffeb7e4f5f")
(package! desktop-environment :pin "2c3e0750c11485931f447ea82f80bc90ae07aeba")

;; TODO this should probably be specific to the krush/hyperdrive/afterburner(?) project
;; (package! graphql-mode :pin "2371316a750b807de941184d49ca19d277ecadcd")
#+end_src
*** Theme :UI:theming:
- TODO make the elisp sections subheadings? Pros: more org-mode-y. Cons: Further distances the code from doom-one, there will be a trailing closing paren in a source block all by itself at the end since some of the sections are in an outer sexp.
#+begin_src elisp :tangle (in-tangle-dir "themes/doom-nuclear-theme.el")
;;; doom-nuclear-theme.el --- inspired by Atom One Dark -*- lexical-binding: t; no-byte-compile: t; -*-
;;
;; Copyright (C) 2016-2021 Henrik Lissner
;;
;; Author: Henrik Lissner <https://github.com/hlissner>
;; Created: December 6, 2020
;; Version: 2.0.0
;; Keywords: custom themes, faces
;; Homepage: https://github.com/hlissner/emacs-doom-themes
;; Package-Requires: ((emacs "25.1") (cl-lib "0.5") (doom-themes "2.2.1"))
;;
;;; Commentary:
;;
;; Inspired by Atom's One Dark color scheme.
;;
;;; Code:

(require 'doom-themes)


;;
;;; Variables

(defgroup nuclear-theme nil
  "Options for the `doom-nuclear' theme."
  :group 'doom-themes)

(defcustom nuclear-brighter-modeline nil
  "If non-nil, more vivid colors will be used to style the mode-line."
  :group 'nuclear-theme
  :type 'boolean)

(defcustom nuclear-brighter-comments nil
  "If non-nil, comments will be highlighted in more vivid colors."
  :group 'nuclear-theme
  :type 'boolean)

(defcustom nuclear-padded-modeline doom-themes-padded-modeline
  "If non-nil, adds a 4px padding to the mode-line.
Can be an integer to determine the exact padding."
  :group 'nuclear-theme
  :type '(choice integer boolean))


;;
;;; Theme definition

(def-doom-theme doom-nuclear
  "A dark theme inspired by Atom One Dark."

  ;; name        default   256           16
  ((bg         '("#282c34" "black"       "black" ))
   (fg         '("#DEE2F8" "#bfbfbf"     "brightwhite"  ))

   ;; These are off-color variants of bg/fg, used primarily for `solaire-mode',
   ;; but can also be useful as a basis for subtle highlights (e.g. for hl-line
   ;; or region), especially when paired with the `doom-darken', `doom-lighten',
   ;; and `doom-blend' helper functions.
   (bg-alt     '("#21242b" "black"       "black"        ))
   (fg-alt     '("#5B6268" "#2d2d2d"     "white"        ))

   ;; These should represent a spectrum from bg to fg, where base0 is a starker
   ;; bg and base8 is a starker fg. For example, if bg is light grey and fg is
   ;; dark grey, base0 should be white and base8 should be black.
   (base0      '("#1B2229" "black"       "black"        ))
   (base1      '("#1c1f24" "#1e1e1e"     "brightblack"  ))
   (base2      '("#202328" "#2e2e2e"     "brightblack"  ))
   (base3      '("#23272e" "#262626"     "brightblack"  ))
   (base4      '("#3f444a" "#3f3f3f"     "brightblack"  ))
   (base5      '("#5B6268" "#525252"     "brightblack"  ))
   (base6      '("#73797e" "#6b6b6b"     "brightblack"  ))
   (base7      '("#9ca0a4" "#979797"     "brightblack"  ))
   (base8      '("#DFDFDF" "#dfdfdf"     "white"        ))

   (grey       base4)
   (red        '("#FB8578" "#ff6655" "red"          ))
   (orange     '("#FDCE5F" "#dd8844" "brightred"    ))
   (green      '("#9FED9C" "#99bb66" "green"        ))
   (teal       '("#4db5bd" "#44b9b1" "brightgreen"  ))
   (yellow     '("#EDDC91" "#ECBE7B" "yellow"       ))
   (blue       '("#7DB9FE" "#51afef" "brightblue"   ))
   (dark-blue  '("#5F68DE" "#2257A0" "blue"         ))
   (magenta    '("#E29BF7" "#c678dd" "brightmagenta"))
   (violet     '("#AEB9F3" "#a9a1e1" "magenta"      ))
   (cyan       '("#75E0F9" "#46D9FF" "brightcyan"   ))
   (dark-cyan  '("#5699AF" "#5699AF" "cyan"         ))

   ;; These are the "universal syntax classes" that doom-themes establishes.
   ;; These *must* be included in every doom themes, or your theme will throw an
   ;; error, as they are used in the base theme defined in doom-themes-base.
   (highlight      "#8496FF")
   (vertical-bar   (doom-darken base1 0.1))
   (selection      dark-blue)
   (builtin        blue)
   (comments       (if nuclear-brighter-comments dark-cyan "#63677F"))
   (doc-comments   (doom-lighten (if nuclear-brighter-comments dark-cyan base5) 0.25))
   (constants      yellow)
   (functions      blue)
   (keywords       magenta)
   (methods        violet)
   (operators      cyan)
   (type           orange)
   (strings        green)
   (variables      red)
   (numbers        violet)
   (region         `(,(doom-lighten (car bg-alt) 0.15) ,@(doom-lighten (cdr base1) 0.35)))
   (error          red)
   (warning        yellow)
   (success        green)
   (vc-modified    orange)
   (vc-added       green)
   (vc-deleted     red)

   ;; These are extra color variables used only in this theme; i.e. they aren't
   ;; mandatory for derived themes.
   (modeline-fg              fg)
   (modeline-fg-alt          base5)
   (modeline-bg              (if nuclear-brighter-modeline
                                 (doom-darken blue 0.45)
                               (doom-darken bg-alt 0.1)))
   (modeline-bg-alt          (if nuclear-brighter-modeline
                                 (doom-darken blue 0.475)
                               `(,(doom-darken (car bg-alt) 0.15) ,@(cdr bg))))
   (modeline-bg-inactive     `(,(car bg-alt) ,@(cdr base1)))
   (modeline-bg-inactive-alt `(,(doom-darken (car bg-alt) 0.1) ,@(cdr bg)))

   (-modeline-pad
    (when nuclear-padded-modeline
      (if (integerp nuclear-padded-modeline) nuclear-padded-modeline 4))))


  ;;;; Base theme face overrides
  (((line-number &override) :foreground base4)
   ((line-number-current-line &override) :foreground violet)
   ((font-lock-comment-face &override)
    :background (if nuclear-brighter-comments (doom-lighten bg 0.05)))
   (font-lock-comment-delimiter-face :foreground "#939abd")
   (font-lock-doc-face
    :inherit 'font-lock-comment-face
    :foreground cyan)
   (mode-line
    :background modeline-bg :foreground modeline-fg
    :box (if -modeline-pad `(:line-width ,-modeline-pad :color ,modeline-bg)))
   (mode-line-inactive
    :background modeline-bg-inactive :foreground modeline-fg-alt
    :box (if -modeline-pad `(:line-width ,-modeline-pad :color ,modeline-bg-inactive)))
   (mode-line-emphasis :foreground (if nuclear-brighter-modeline base8 highlight))

   ;;;; clojure-mode
   (clojure-interop-method-face :foreground cyan)
   (clojure-character-face :foreground violet :weight 'bold)
   ;;;; css-mode <built-in> / scss-mode
   (css-proprietary-property :foreground orange)
   (css-property             :foreground green)
   (css-selector             :foreground blue)
   ;;;; doom-modeline
   (doom-modeline-bar :background (if nuclear-brighter-modeline modeline-bg highlight))
   (doom-modeline-buffer-file :inherit 'mode-line-buffer-id :weight 'bold)
   (doom-modeline-buffer-path :inherit 'mode-line-emphasis :weight 'bold)
   (doom-modeline-buffer-project-root :foreground green :weight 'bold)
   ;;;; elscreen
   (elscreen-tab-other-screen-face :background "#353a42" :foreground "#1e2022")
   ;;;; ivy
   (ivy-current-match :background dark-blue :distant-foreground base0 :weight 'normal)
   ;;;; LaTeX-mode
   (font-latex-math-face :foreground green)
   ;;;; markdown-mode
   (markdown-markup-face :foreground base5)
   (markdown-header-face :inherit 'bold :foreground red)
   ((markdown-code-face &override) :background (doom-lighten base3 0.05))
   ;;;; rainbow-delimiters
   (rainbow-delimiters-depth-1-face :foreground fg)
   (rainbow-delimiters-depth-2-face :foreground magenta)
   (rainbow-delimiters-depth-3-face :foreground blue)
   (rainbow-delimiters-depth-4-face :foreground cyan)
   (rainbow-delimiters-depth-5-face :foreground green)
   (rainbow-delimiters-depth-6-face :foreground yellow)
   (rainbow-delimiters-depth-7-face :foreground orange)
   (rainbow-delimiters-depth-8-face :foreground red)
   ;;;; rjsx-mode
   (rjsx-tag :foreground red)
   (rjsx-attr :foreground orange)
   ;;;; solaire-mode
   (solaire-mode-line-face
    :inherit 'mode-line
    :background modeline-bg-alt
    :box (if -modeline-pad `(:line-width ,-modeline-pad :color ,modeline-bg-alt)))
   (solaire-mode-line-inactive-face
    :inherit 'mode-line-inactive
    :background modeline-bg-inactive-alt
    :box (if -modeline-pad `(:line-width ,-modeline-pad :color ,modeline-bg-inactive-alt))))

  ;;;; Base theme variable overrides-
  ())

;;; doom-nuclear-theme.el ends here
#+end_src
** Spartan :UI:
:PROPERTIES:
:tangle-dir+: spartan
:END:
#+begin_src scheme :tangle (in-tangle-dir "core.scm") :noweb yes
(define-module (spartan core)
  #:use-module (guix build-system trivial)
  #:use-module (guix gexp)
  #:use-module ((gnu packages bash) #:select (bash))
  #:use-module ((gnu packages dunst) #:select (dunst))
  #:use-module ((gnu packages emacs) #:select (emacs))
  #:use-module ((gnu packages fonts) #:select (font-google-noto))
  #:use-module ((gnu packages freedesktop) #:select (udiskie))
  ;; #:use-module ((gnu packages gnome-xyz) #:select (papirus-icon-theme))
  #:use-module ((gnu packages glib) #:select (dbus))
  #:use-module ((gnu packages pulseaudio) #:select (pasystray pavucontrol))
  #:use-module ((gnu packages xorg) #:select (xhost xset))
  #:use-module ((gnu packages xdisorg) #:select (redshift xss-lock xsettingsd))
  ;; #:use-module (ebullient packages dracula-theme)
  #:use-module (ebullient utils))

(define-public spartan
  (private-package
   (name "spartan")
   (build-system trivial-build-system)
   (native-inputs
    `(("startup-script.sh" ,(local-file "startup-script.sh"))
      ("xsettingsd.conf" ,(local-file "xsettingsd.conf"))
      ("desktop.el" ,(local-file "desktop.el"))
      ("dunstrc" ,(local-file "dunstrc"))))
   (inputs
    `(("bash" ,bash) ; TODO `bash-minimal' might be okay/preferable here
      ("xhost" ,xhost)
      ("xset" ,xset)
      ("xss-lock" ,xss-lock)
      ("xsettingsd" ,xsettingsd)
      ("dbus" ,dbus)
      ("emacs" ,emacs)
      ("dunst" ,dunst)
      ("pasystray" ,pasystray)
      ("redshift:gtk" ,redshift "gtk")
      ("udiskie" ,udiskie)))
   ;; TODO much later, see if there's a way to make any of these not propagated.
   (propagated-inputs
    `(("font-google-noto" ,font-google-noto)
      ;; ("dracula-theme" ,dracula-theme)
      ;; ("papirus-icon-theme" ,papirus-icon-theme)
      ("pavucontrol" ,pavucontrol)))
   (arguments
    '(#:modules ((guix build utils))
      #:builder
      (begin
        (use-modules (guix build utils))
        (let* ((out (assoc-ref %outputs "out"))
               (get-input (lambda (k)
                            (assoc-ref %build-inputs k)))
               (cmd (lambda* (input #:optional (executable input))
                      (string-append (get-input input) "/bin/" executable)))
               (install-input (lambda* (input-file #:optional (name (basename input-file)))
                                (let ((newfile (string-append out "/" name)))
                                  (mkdir-p (dirname newfile))
                                  (copy-file (get-input input-file) newfile)
                                  newfile))))
          (let ((desktop-el-file (install-input "desktop.el"))
                (dunstrc-file (install-input "dunstrc")))
            ;; `emacs-substitute-sexps' might be useful here if my needs get more sophisticated.
            (substitute* desktop-el-file
              (("(dunstctl|dunst)" all) (case (string->symbol all)
                                          ((dunst) (string-append (cmd "dunst") " -config " dunstrc-file))
                                          ((dunstctl) (cmd "dunst" "dunstctl"))))
              (("pasystray") (cmd "pasystray"))
              (("redshift-gtk") (cmd "redshift:gtk" "redshift-gtk"))
              (("udiskie") (cmd "udiskie")))
            (let ((executable (install-input "startup-script.sh" "/bin/<<spartan-exe>>"))
                  (xsettingsd-conf-file (install-input "xsettingsd.conf")))
              (substitute* executable
                (("^xhost") (cmd "xhost"))
                (("^xsettingsd") (string-append (cmd "xsettingsd") " --config=" xsettingsd-conf-file))
                (("^xset") (cmd "xset"))
                (("^xss-lock") (cmd "xss-lock"))
                (("dbus-launch") (cmd "dbus" "dbus-launch"))
                (("emacs") (cmd "emacs"))
                (("doom") "~/.config/emacs/bin/doom") ; TODO replace with reference to my eventual Emacs Doom package. I should be able to reverse the order of this substution and the emacs one too if the final path doesn't contain the "emacs" string.
                (("desktop\\.el") desktop-el-file))
              (patch-shebang executable (list (string-append (get-input "bash") "/bin")))
              (chmod executable #o555))))
        #t)))))
#+end_src
*** Startup script
#+begin_src sh :tangle (in-tangle-dir "startup-script.sh")
#!/bin/sh
xhost +SI:localuser:$USER
export _JAVA_AWT_WM_NONREPARENTING=1
xsettingsd &
xset r rate 300 30 # TODO tweak?
xss-lock -- slock &
doom env
exec dbus-launch --exit-with-session emacs -mm -l desktop.el # --debug-init
#+end_src
**** Xsettings :theming:
#+begin_src conf :tangle (in-tangle-dir "xsettingsd.conf")
# TODO these
Net/EnableEventSounds 1
Net/EnableInputFeedbackSounds 1

Xft/Antialias 1
Xft/Hinting 1
Xft/HintStyle "hintfull"
Xft/DPI 196608
# Xft/DPI 184320 # TODO I do like the chromium interface size better at this dpi
# Xft/DPI 225280

# Xft/RGBA "rgb"

# Xft/Autohint 0 # TODO donno if the casing is right or if it matters



# Gtk/ToolbarIconSize "large"
# Net/ApplicationPreferDarkTheme 1
# Gtk/FontName "Cantarell 11"
# Gtk/MonospaceFontName "Fira Mono 10"
Gtk/CursorThemeName "Adwaita"
Gtk/CursorThemeSize 48

# TODO theme
# - before doing any more wait until I've picked a browser and have installed more apps like e.g. VLC
# - make sure my browser reads the device theme preference as dark
# - if I don't like dracula try another theme or maybe patch it with my emacs colors (perhaps some other theme would be a better base?)
# - look at dracula / other theme I choose in Gnome to see if it looks "right"
# Net/ThemeName "Dracula"
# TODO icon theme
# Donno about these new papirus icons, daviwil and hlissner seem to like them but I'm not sure I do (the Files icons and particularly the systray ones, can I change just those?). Maybe they'll look better once Dracula is enabled? Maybe a wrong / lower-resolution version of the icons is being used and I need to set up where they're looked for?
# Net/IconThemeName "Papirus-Dark"
# seems like this is the default, at least for dracula
# Gtk/DecorationLayout "menu:minimize,maximize,close"
#+end_src
*** Emacs config
:PROPERTIES:
:header-args+: :tangle (in-tangle-dir "desktop.el")
:END:
#+begin_src elisp
;;; -*- lexical-binding: t; -*-
;; TODO rename efs to biome
;; TODO at end, make sure that all exwm mappings' functions are sharp quoted
;; TODO ~setq!~ for exwm vars with custom setters? Can/should I do them in an ~after!~ block then?
#+end_src
**** Battery
#+begin_src elisp
(use-package! battery
  :config
  (display-battery-mode 1))
#+end_src
**** Desktop Environment :bindings:path:
#+begin_src elisp
(use-package! desktop-environment
  :after exwm
  :config
  (setq desktop-environment-volume-get-command "pactl list sinks | grep '^[[:space:]]Volume:' | head -n 1 | tail -n 1 | sed -e 's,.* \([0-9][0-9]*\)%.*,\1,'"
        desktop-environment-volume-set-command "pactl set-sink-volume @DEFAULT_SINK@ %s"
        desktop-environment-volume-toggle-command "pactl set-sink-mute @DEFAULT_SINK@ toggle" ; TODO at end: if whatever I end up doing here doesn't already display an echo aread messge then do it myself
        desktop-environment-volume-normal-increment "+5%"
        desktop-environment-volume-normal-decrement "-5%"
        desktop-environment-keyboard-backlight-normal-increment 26
        desktop-environment-keyboard-backlight-normal-decrement -26
        desktop-environment-screenshot-directory "~/desktop") ; TODO I had this as `(or (getenv "XDG_DESKTOP_DIR") "~")' but that won't work, xdg user dirs aren't sourced. I could call the shell command `xdg-user-dir DESKTOP' or pass the value in.
  ;; These are set into the exwm global keymap when the mode is enabled (this can be changed) perform modifications before doing so.
  (map! :map desktop-environment-mode-map
        "s-l" nil
        "<XF86KbdBrightnessUp>" #'desktop-environment-keyboard-backlight-increment
        "<XF86KbdBrightnessDown>" #'desktop-environment-keyboard-backlight-decrement
        "<XF86LaunchB>" (lookup-key desktop-environment-mode-map (kbd "<print>"))
        "S-<XF86LaunchB>" (lookup-key desktop-environment-mode-map (kbd "S-<print>")))
  (desktop-environment-mode))
#+end_src
**** EXWM :bindings:
#+begin_src elisp
(defun efs/run-in-background (command)
  (let ((command-parts (split-string command "[ ]+")))
    (apply #'call-process `(,(car command-parts) nil 0 nil ,@(cdr command-parts)))))

(defun efs/exwm-init-hook ()
  (efs/run-in-background "dunst")
  (efs/run-in-background "nm-applet")
  (efs/run-in-background "pasystray")
  (efs/run-in-background "redshift-gtk -l 47:-123")
  (efs/run-in-background "udiskie -t"))

(defun efs/exwm-update-class ()
  (exwm-workspace-rename-buffer exwm-class-name))

(defun efs/exwm-update-title ()
  (exwm-workspace-rename-buffer
   (pcase exwm-class-name
     ("Chromium-browser" (format "Chromium: %s" exwm-title)) ; TODO get rid of preceding or trailing "Chromium"
     (_ exwm-title))))

(defun biome--shell-cmd (command)
  (start-process-shell-command command nil command))

(use-package! exwm
  :config
  ;; When window "class" updates, use it to set the buffer name
  (add-hook 'exwm-update-class-hook #'efs/exwm-update-class)

  ;; When window title updates, use it to set the buffer name
  (add-hook 'exwm-update-title-hook #'efs/exwm-update-title)

  ;; When EXWM starts up, do some extra configuration
  (add-hook 'exwm-init-hook #'efs/exwm-init-hook)

  ;; NOTE: Uncomment the following two options if you want window buffers
  ;;       to be available on all workspaces!

  ;; Automatically move EXWM buffer to current workspace when selected
  (setq exwm-layout-show-all-buffers t)

  ;; Display all EXWM buffers in every workspace buffer list
  (setq exwm-workspace-show-all-buffers t)

  ;; NOTE: Uncomment this option if you want to detach the minibuffer!
  ;; Detach the minibuffer (show it with exwm-workspace-toggle-minibuffer)
  ;;(setq exwm-workspace-minibuffer-position 'top)

  ;; Load the system tray before exwm-init
  (require 'exwm-systemtray)
  (setq exwm-systemtray-height 32) ; daviwil says explicity setting a system tray height can help prevent issues with icons not showing up.
  (setq exwm-systemtray-icon-gap 8)
  (exwm-systemtray-enable)

  ;; TODO might one or both of these fix chromium not being focused when I switch to it? What other effects might there be? Note that this doesn't seem to be problem on some other apps like gnome-terminal, perhaps there's I can set up an exwm local hook for chromium or something.
  ;; Window focus should follow the mouse pointer
  ;; (setq mouse-autoselect-window t
  ;;       focus-follows-mouse t)

  ;; These keys should always pass through to Emacs
  (setq exwm-input-prefix-keys
        '(?\C-x
          ;; ?\C-u
          ;; ?\C-h
          ?\M-x
          ?\M-`
          ?\M-&
          ?\M-:
          ;; ?\C-\M-j  ;; Buffer list
          ?\s-\ ; TODO I might want this in exwm global keys
          ?\s-, ; TODO I might want this in exwm global keys
          ))
  ;; (setq exwm-input-prefix-keys nil)

  ;; (setq exwm-input-simulation-keys
  ;;         '(([?\C-b] . [left])
  ;;           ([?\C-f] . [right])
  ;;           ([?\C-p] . [up])
  ;;           ([?\C-n] . [down])
  ;;           ([?\C-a] . [home])
  ;;           ([?\C-e] . [end])
  ;;           ([?\M-v] . [prior])
  ;;           ([?\C-v] . [next])
  ;;           ([?\C-d] . [delete])
  ;;           ([?\C-k] . [S-end delete])))
  (setq exwm-input-simulation-keys
        '(([?\s-c] . [C-c])))

  ;; TODO might want to do some local simulation keys too

  ;; TODO maybe find a way to alias localleader key to the commands in exwm-mode-map under C-c?
  ;; TODO probably use `map!' instead of `define-key'
  ;; (define-key exwm-mode-map [?\s-\M-q] 'exwm-input-send-next-key) ; TODO see if I can reverse the order of super and meta

  ;; Set up global key bindings.  These always work, no matter the input state!
  ;; Keep in mind that changing this list after EXWM initializes has no effect.
  ;; TODO maybe setq! would work though?
  (setq exwm-input-global-keys
        `(([?\s-q] . exwm-reset)

          ([?\s-Q] . exwm-input-release-keyboard)

          ;; Move between windows
          ([s-left] . windmove-left)
          ([s-right] . windmove-right)
          ([s-up] . windmove-up)
          ([s-down] . windmove-down)

          ([?\s-t] . evil-switch-to-windows-last-buffer)
          ;; ([?\s-\ ] . doom-leader-map)

          ;; Launch applications via shell command
          ([?\s-&] . (lambda (command)
                       (interactive (list (read-shell-command "$ ")))
                       (biome--shell-cmd command)))

          (,(kbd "<XF86LaunchA>") . ,(cmd! (biome--shell-cmd "dunstctl close")))
          (,(kbd "S-<XF86LaunchA>") . ,(cmd! (biome--shell-cmd "dunstctl close-all")))
          (,(kbd "C-<XF86LaunchA>") . ,(cmd! (biome--shell-cmd "dunstctl history-pop")))
          (,(kbd "M-<XF86LaunchA>") . ,(cmd! (biome--shell-cmd "dunstctl action")))))

  ;; TODO why is exwm-input-set-key used like this, daviwil uses it in his dotfiles too. The docs say to only use it interactively.
  (exwm-input-set-key (kbd "s-A") 'counsel-linux-app)


  (add-hook 'exwm-mode-hook #'doom-mark-buffer-as-real-h)

  ;; Copied from online, not super sure what it does but it makes me feel safer. "Allow persp-mode to restore window configurations involving exwm buffers by only changing names of visible buffers." https://github.com/hlissner/doom-emacs/pull/4004/files#issuecomment-703164464
  (defun exwm--update-utf8-title-advice (oldfun id &optional force)
    (when (get-buffer-window (exwm--id->buffer id))
      (funcall oldfun id force)))
  (advice-add #'exwm--update-utf8-title :around #'exwm--update-utf8-title-advice)


  (exwm-enable))
#+end_src
***** Dunst :theming:
#+begin_src conf :tangle (in-tangle-dir "dunstrc")
[global]
    geometry = "500x10-200+50"
    transparency = 10
    separator_color = frame
    padding = 15
    horizontal_padding = 15
    text_icon_padding = 15
    frame_width = 2
    frame_color = "#89AAEB"
    idle_threshold = 120
    font = Cantarell 20 # TODO Depending on how I end up doing fonts, set this to a default variable-width font that picks up my system setting or change this to my preferred font
    line_height = 2
    markup = full
    format = "<b>%s</b>\n%b"
    show_age_threshold = 60
    word_wrap = yes
    icon_position = left
    min_icon_size = 40
    max_icon_size = 40
    # icon_path = /usr/share/icons/Adwaita/96x96/status:/usr/share/icons/Adwaita/96x96/emblems # TODO should I add more paths or something?
    # TODO browser = qutebrowser
    corner_radius = 16
    mouse_right_click = do_action

[urgency_low]
    background = "#1c1f26"
    foreground = "#9ca0a4"
    timeout = 10

[urgency_normal]
    background = "#1c1f26"
    foreground = "#ffffff"
    timeout = 10

[urgency_critical]
    background = "#900000"
    foreground = "#ffffff"
    frame_color = "#ff0000"
    timeout = 0
#+end_src
**** Time
#+begin_src elisp
(use-package! time
  :config
  (setq display-time-day-and-date t)
  ;; (setq display-time-24hr-format t)
  (display-time-mode 1))
#+end_src
** WIP emacs
*** doom-emacs-temp
- TODO probably "export" the ~doom~ program to user profile
#+begin_src scheme :tangle (in-tangle-dir "doom-emacs-temp.scm")
(define-module (doom-emacs-temp)
  #:use-module (guix packages)
  #:use-module (guix build-system trivial)
  #:use-module ((guix licenses) #:prefix license:)
  #:use-module ((gnu packages base) #:select (coreutils))
  ;; #:use-module ((gnu packages emacs) #:select (emacs))
  #:use-module ((gnu packages llvm) #:select (clang))
  #:use-module ((gnu packages rust-apps) #:select (fd ripgrep))
  #:use-module ((gnu packages version-control) #:select (git)))

(define-public doom-emacs-temp
  (package
    (name "doom-emacs-temp")
    (version "0")
    (source #f)
    ;; TODO Ideally these wouldn't be propagated inputs. Instead of tracking down usages of these and doing `substitute' everywhere maybe `wrap-prgram' is an option? However maybe there are other things in these inputs than just binaries Doom depends on or it has parts outside of emacs that recquire them?
    (propagated-inputs
     `(;; Required
       ;; ("emacs" ,emacs) ; TODO uncomment and wrap usage(s) with `package-input-rewriting`
       ("git" ,git)
       ("ripgrep" ,ripgrep)
       ;; Optional
       ("coreutils" ,coreutils) ; TODO might not be necessary because emacs Guix package already adds "coreutils/bin" to PATH with `wrap-program'
       ("fd" ,fd)
       ("clang" ,clang))) ; TODO I still don't know what this is for. Notably hlissner doesn't install clang, nor gcc, in his emacs "module" in his dotfiles.
    (build-system trivial-build-system)
    (arguments
     '(#:modules ((guix build utils))
       #:builder
       (begin
         (use-modules (guix build utils))
         (mkdir-p (string-append (assoc-ref %outputs "out") "/asdf"))
         (with-output-to-file (string-append (assoc-ref %outputs "out") "/asdf/asdf.txt")
           (lambda _
             (display "asdffffffffffff")))
         #t)))
    (synopsis "An Emacs framework for the stubborn martian hacker")
    (description synopsis)
    (home-page "https://github.com/hlissner/doom-emacs")
    (license license:expat)))
#+end_src
*** emacs-desktop-environment-temp
#+begin_src scheme :tangle (in-tangle-dir "emacs-desktop-environment-temp.scm")
;; (define-module (emacs-desktop-environment-temp)
;;   #:use-module (guix packages)
;;   #:use-module ((gnu packages emacs-xyz) #:select (emacs-desktop-environment))
;;   #:use-module ((gnu packages linux) #:select (brightnessctl))
;;   #:use-module ((gnu packages music) #:select (playerctl))
;;   #:use-module ((gnu packages xdisorg) #:select (scrot)))

;; (define-public emacs-desktop-environment-temp
;;   (package (inherit emacs-desktop-environment)
;;     (inputs
;;      `(,@(package-inputs emacs-desktop-environment) ; Just in case (there aren't any inputs at the time of this writing)
;;        ("brightnessctl" ,brightnessctl)
;;        ("playerctl" ,playerctl)
;;        ("scrot" ,scrot)))
;;     (arguments
;;     '(#:phases
;;       (modify-phases %standard-phases
;;         (add-after 'unpack 'patch-executables
;;           (lambda* (#:key inputs #:allow-other-keys)
;;             (let ((cmd (lambda (input)
;;                          (string-append (assoc-ref inputs input) "/bin/" input))))
;;               (substitute* "desktop-environment.el"
;;                 (("brightnessctl") (cmd "brightnessctl"))
;;                 (("playerctl") (cmd "playerctl"))
;;                 (("scrot") (cmd "scrot"))))
;;             #t)))))))

(define-module (emacs-desktop-environment-temp)
  #:use-module (guix packages)
  #:use-module (guix build-system trivial)
  #:use-module ((gnu packages linux) #:select (brightnessctl))
  #:use-module ((gnu packages music) #:select (playerctl))
  #:use-module ((gnu packages xdisorg) #:select (scrot)))

(define-public emacs-desktop-environment-temp
  (package
    (name "emacs-desktop-environment-temp")
    (version "0")
    (source #f)
    (propagated-inputs
     `(("brightnessctl" ,brightnessctl)
       ("playerctl" ,playerctl)
       ("scrot" ,scrot)))
    (build-system trivial-build-system)
    (arguments
     '(#:modules ((guix build utils))
       #:builder
       (begin
         (use-modules (guix build utils))
         (mkdir-p (string-append (assoc-ref %outputs "out") "/qwer"))
         (with-output-to-file (string-append (assoc-ref %outputs "out") "/qwer/qwer.txt")
           (lambda _
             (display "qwerrrrrrr")))
         #t)))
    (synopsis #f)
    (description synopsis)
    (home-page #f)
    (license #f)))
#+end_src
*** Emacs Application Framework
#+begin_src scheme :tangle (in-tangle-dir "emacs-application-framework.scm")
;; (use-modules (guix build-system emacs)
;;              (guix git-download)
;;              (guix packages)
;;              ((guix licenses) #:prefix license:))

;; (let ((commit "5c99dc6962fbe2f95033678d82b6dc1414460c0a")
;;       (revision "0"))
;;   (package
;;     (name "emacs-application-framework")
;;     (version (git-version "0.5" revision commit))
;;     (source (origin
;;               (method git-fetch)
;;               (uri (git-reference
;;                     (url "https://github.com/manateelazycat/emacs-application-framework")
;;                     (commit commit)))
;;               (file-name (git-file-name name version))
;;               (sha256
;;                (base32
;;                 "TODO"))))
;;     (build-system emacs-build-system)
;;     (native-inputs
;;      `(("emacs-ert-runner" ,emacs-ert-runner)))
;;     (arguments
;;      `(#:tests? #t
;;        #:test-command '("ert-runner")
;;        #:modules ((guix build emacs-build-system)
;;                   (guix build utils)
;;                   (guix build emacs-utils)
;;                   (srfi srfi-1))
;;        #:phases
;;        (modify-phases %standard-phases
;;          (add-after 'unpack 'move-themes
;;            (lambda _
;;              ;; Move the source files to the top level, which is in the
;;              ;; EMACSLOADPATH.
;;              (for-each (lambda (f)
;;                          (rename-file f (basename f)))
;;                        (find-files "./themes" ".*\\.el$"))
;;              #t)))))
;;     (synopsis "Emacs Application Framework (EAF)")
;;     (description "GUI application framework for Emacs that revolutionizes its multimedia and graphical capabilities to ultimately Live in Emacs.")
;;     (home-page "https://github.com/manateelazycat/emacs-application-framework")
;;     (license license:gpl3+)))
#+end_src
* Packages
:PROPERTIES:
:tangle-dir+: ebullient/packages
:END:
** Dracula Theme
#+begin_src scheme :tangle (in-tangle-dir "dracula-theme.scm")
(define-module (ebullient packages dracula-theme)
  #:use-module (guix git-download)
  #:use-module (guix packages)
  #:use-module ((gnu packages gnome-xyz) #:select (nordic-theme)))

(define-public dracula-theme
  (let ((commit "ceec1c102c5e16810a58d04f08dba0c4116f61dd")
        (revision "0"))
    (package (inherit nordic-theme)
      (name "dracula-theme")
      (version (git-version "2.0" revision commit))
      (source
       (origin
         (method git-fetch)
         (uri (git-reference
               (url "https://github.com/dracula/gtk")
               (commit commit)))
         (sha256
          (base32
           "1rbwyhipv086b58gc8fw4r0y5zg79rv2i9lx02b5pg0khgf61mf2"))))
      ;; TODO ideally don't copypasta the `#:exclude' part from nordic-theme. Then again maybe don't bother inheriting at all (just add the `build-system' and `license' fields)
      (arguments
       `(#:install-plan
         `(("." "share/themes/Dracula"
            #:exclude ("README.md" "LICENSE" "Art/" "package.json"
                       "package-lock.json" "Gulpfile.js")))))
      (home-page "https://github.com/dracula/gtk")
      (synopsis "A flat and light theme with a modern look")
      (description synopsis))))
#+end_src
** xf86-input-mtrack
#+begin_src scheme :tangle (in-tangle-dir "xf86-input-mtrack.scm")
(define-module (ebullient packages xf86-input-mtrack)
  #:use-module (guix build-system gnu)
  #:use-module (guix git-download)
  #:use-module ((guix licenses) #:prefix license:)
  #:use-module (guix packages)
  #:use-module ((gnu packages pkg-config) #:select (pkg-config))
  #:use-module ((gnu packages xorg) #:select (xorg-server inputproto xproto))
  #:use-module ((gnu packages xdisorg) #:select (mtdev)))

(define-public xf86-input-mtrack
  (let ((commit "124b80f3913e44cc7fdc1ac36a639252f7c4bf1b")
        (revision "0"))
    (package
      (name "xf86-input-mtrack")
      (version (git-version "0.5.1" revision commit))
      (source (origin
                (method git-fetch)
                (uri (git-reference
                      (url "https://github.com/p2rkw/xf86-input-mtrack")
                      (commit commit)))
                (sha256
                 (base32
                  "0zl2mi4dsyji23dk43693mwkm5n4b335gfkpbx16009z52qgj9mi"))))
      (build-system gnu-build-system)
      (native-inputs
       `(("pkg-config" ,pkg-config)))
      (inputs
       `(("xorg-server" ,xorg-server)
         ("inputproto" ,inputproto)
         ("xproto" ,xproto)
         ("mtdev" ,mtdev)))
      (synopsis "Multitouch trackpad driver")
      (description "An Xorg driver for multitouch trackpads. Supports any trackpad whose kernel driver uses the slotted multitouch protocol.")
      (home-page "https://github.com/p2rkw/xf86-input-mtrack")
      (license license:gpl2+))))
#+end_src
* Utils
:PROPERTIES:
:tangle-dir+: ebullient
:END:
#+begin_src scheme :tangle (in-tangle-dir "utils.scm")
(define-module (ebullient utils)
  #:use-module (guix packages))

(define barebones-package
  (package
    (name #f)
    (version "0")
    (source #f)
    (build-system #f)
    (synopsis name)
    (description synopsis)
    (home-page #f)
    (license #f)))

(define-syntax-rule (private-package body ...)
  (package
    (inherit barebones-package)
    body ...))
#+end_src
* Dev
** Emacs directory-local variables
#+begin_src elisp :tangle .dir-locals.el
((nil
  (eval . (with-eval-after-load 'geiser-guile
            (let ((root-dir
                   (file-name-directory
                    (locate-dominating-file default-directory ".dir-locals.el"))))
              (make-local-variable 'geiser-guile-load-path)
              (add-to-list 'geiser-guile-load-path root-dir))))))
#+end_src
