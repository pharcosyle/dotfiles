#+TITLE: Dotfiles
#+PROPERTY: header-args :mkdirp yes
#+PROPERTY: tangle-dir gen

* Meta
#+begin_src elisp
(defun tangle-dir* ()
  (or
   (-> (org-entry-get (point) "tangle-dir" 'inherit)
       (split-string " ")
       (string-join "/"))
   ;; (default-directory)
   ))

(defun get-tangle-dir ()
  (expand-file-name (tangle-dir*)))

(defun in-tangle-dir (sub-path)
  (expand-file-name sub-path (tangle-dir*)))
#+end_src
** Git
#+begin_src gitignore :tangle (in-tangle-dir ".gitignore")
*
#+end_src
* Common
#+name: user-name
#+begin_src org
pharcosyle
#+end_src
#+name: user-full-name
#+begin_src org
Krzysztof Baranowski
#+end_src
#+name: user-email
#+begin_src org
pharcosyle@gmail.com
#+end_src
#+name: spartan-executable
#+begin_src org
spartan
#+end_src
* Installation Guide
** Create bootable USB
Download (or create) a Guix installation ISO
- I'm using the [[https://github.com/SystemCrafters/guix-installer/releases/latest][System Crafters Guix Installer]] since it's kept up-to-date which should speed things up a bit.
- Run ~lsblk~ to find the usb device.
#+begin_src sh
iso_file=guix-system-install-1.3.0.x86_64-linux.iso
usb_device=/dev/sdc
dd if=$iso_file of=$usb_device status=progress bs=4M
sync
#+end_src
** Install
Boot from the installation medium, select your language and country, and select "Install using the shell based process" when prompted.
*** Keyboard layout
This messed up the keyboard when I tried it on mac, not doing ~loadkeys~ at all was fine.
#+begin_src sh
# keysfile=mac-us
# loadkeys mac-us
#+end_src
*** Networking
#+begin_src sh
# List network interfaces and find one to use.
ifconfig -a

# Is this necessary if the interface is already activated?
interface=usb0
ifconfig $interface up

dhclient -v $interface

# Test that networking is up and working.
ping -c 3 gnu.org
#+end_src
*** Partitioning
#+begin_src sh
# Check out the current block devices and partitions if you want.
lsblk

device=/dev/sda

# Make two partitions, partition types should be "EFI system partition" and "Linux x86-64 root (/)". For EFI I'm gonna do 1GB to be on the safe side, second should be remainder of free space.
cfdisk $device
parted $device set 1 esp on

efi_system_partition="$device"1
efi_label=genesis

mkfs.fat -F32 -n $efi_label $efi_system_partition

root_partition="$device"2
root_label=firmament
crypt_name=ciphered
crypt_mapping=/dev/mapper/$crypt_name

cryptsetup luksFormat $root_partition
cryptsetup open --type luks $root_partition $crypt_name

mkfs.btrfs -L $root_label $crypt_mapping
#+end_src
*** Set up subvolumes
#+begin_src sh
# I don't know if the type argument is necessary but that's how Andrew Tropin had it.
mount -t btrfs LABEL=$root_label /mnt

btrfs subvolume create /mnt/root
btrfs subvolume create /mnt/boot
btrfs subvolume create /mnt/guix-store
btrfs subvolume create /mnt/guix-var
btrfs subvolume create /mnt/log
btrfs subvolume create /mnt/home
btrfs subvolume create /mnt/persist

# Take an empty readonly snapshot of the root subvolume (might be useful later for rolling back or comparison)
btrfs subvolume snapshot -r /mnt/root /mnt/root-blank

umount /mnt
#+end_src
*** Mount
NB: ~$crypt_mapping~ can/"should" be ~LABEL=$root_label~
#+begin_src sh
mount -o subvol=root,compress=zstd,autodefrag $crypt_mapping /mnt

mkdir /mnt/boot
mount -o subvol=boot,compress=zstd,autodefrag $crypt_mapping /mnt/boot
mkdir -p /mnt/gnu/store
mount -o subvol=guix-store,compress=zstd,autodefrag,noatime $crypt_mapping /mnt/gnu/store
mkdir -p /mnt/var/guix
mount -o subvol=guix-var,compress=zstd,autodefrag $crypt_mapping /mnt/var/guix
mkdir -p /mnt/var/log
mount -o subvol=log,compress=zstd,autodefrag $crypt_mapping /mnt/var/log
mkdir /mnt/home
mount -o subvol=home,compress=zstd,autodefrag $crypt_mapping /mnt/home
mkdir /mnt/.persist
mount -o subvol=persist,compress=zstd,autodefrag $crypt_mapping /mnt/.persist

mkdir -p /mnt/boot/efi
mount LABEL=$efi_label /mnt/boot/efi
#+end_src
*** Proceeding with installation
#+begin_src sh
herd start cow-store /mnt
#+end_src
*** System configuration
#+begin_src sh
# Grab my dotfiles, from github if I put them up at some point or maybe from a USB or another computer with `woof`, into the current directory (the one I'm already in, not `/mnt`).
# git clone https://github.com/pharcosyle/dotfiles
# guix environment --ad-hoc woof -- woof -U
# ...also the penitent-tangent channel if I'm stil referencing it locally.
# Important: `woof` didn't work for me over the local network, I had to have my other computer offer it over the public internet with localtunnel.

mkdir -p ~/.config/guix
cp ~/Projects/dotfiles/gen/home/channels.scm ~/.config/guix
guix pull
hash guix

# Find the LUKS UUID to update it in the system config. Make sure to update in the dotfiles upstream later.
cryptsetup luksUUID $root_partition

cd ~/Projects/dotfiles/gen/system
guix system --load-path=. init frostfire.scm /mnt
#+end_src
*** Post-installation
#+begin_src sh
# Reboot the system, take out the installation medium, and login as root when faced with a login prompt.

# Set the password for the root account.
passwd
# Set the password for my user.
my_user=pharcosyle
passwd $my_user

# Log out and log in to my user account.

# Grab my dotfiles again.

# Ensure my channels file is in `~/.config/guix` and update my channels.
guix pull

# Run a system reconfigure, home reconfigure, install manifests, and deploy `home-state.git`. Copy over all my old data.
#+end_src
* System
:PROPERTIES:
:tangle-dir+: system
:END:
** ~operating-system~
*** Empty OS
#+begin_src scheme :tangle (in-tangle-dir "empty-os.scm") :noweb yes
(define-module (empty-os)
  #:use-module ((gnu system) #:select (operating-system))
  #:use-module ((gnu system file-systems) #:select (%base-file-systems)))

(define-public empty-os
  (operating-system
    (host-name #f)
    (timezone #f)
    (bootloader #f)
    (services '())
    (file-systems %base-file-systems)))
#+end_src
*** Base OS
#+begin_src scheme :tangle (in-tangle-dir "base-os.scm")
(define-module (base-os)
  #:use-module ((gnu system) #:select (operating-system operating-system-packages operating-system-user-services))
  #:use-module ((gnu services) #:select (service simple-service))
  #:use-module ((gnu services base) #:select (udev-service-type))
  #:use-module ((gnu services desktop) #:select (gnome-desktop-service-type bluetooth-service %desktop-services))
  #:use-module ((gnu services xorg) #:select (xorg-configuration set-xorg-configuration %default-xorg-modules))
  #:use-module ((gnu packages) #:select (specification->package))
  #:use-module ((gnu packages linux) #:select (brightnessctl))
  #:use-module ((ice-9 rdelim) #:select (read-string))
  #:use-module ((penitent-tangent packages xf86-input-mtrack) :select (xf86-input-mtrack))
  #:use-module ((spartan-wm) #:select (spartan-wm))
  #:export (base-os))

(define* (base-os os kbl #:key (bluetooth? #t))
  (operating-system
    (inherit os)
    (timezone "America/Los_Angeles")
    (keyboard-layout kbl)
    (packages
      (append
        (list (specification->package "nss-certs")
              (specification->package "xf86-input-libinput")
              (specification->package "xf86-input-mtrack")
              spartan-wm)
        (operating-system-packages os)))
    (services
     (append
      (list (service gnome-desktop-service-type)
             (set-xorg-configuration
              (xorg-configuration
               (modules (cons* xf86-input-mtrack
                               %default-xorg-modules))
               (keyboard-layout keyboard-layout)
               (extra-config (list (with-input-from-file "xorg.conf" read-string))))) ; TODO tried `#~#$(local-file "xorg.conf")' but it didn't work, I don't think xorg.conf is protected from garbage collection. Also the path isn't relative to this file like local-file would be (I think) it'll only work if I run the reconfigure command from the generated files directory. Update: I forget what the problem was exactly but would rde's `slurp-file-gexp' work?
             (simple-service 'my-brightnessctl-udev-rules udev-service-type (list brightnessctl)))
      (if bluetooth?
          (list (bluetooth-service #:auto-enable? #t)) '())
      %desktop-services
      (operating-system-user-services os)))))
#+end_src
*** Boot
#+begin_src scheme :tangle (in-tangle-dir "boot.scm")
(define-module (boot)
  #:use-module ((gnu system) #:select (operating-system operating-system-file-systems))
  #:use-module ((gnu bootloader) #:select (bootloader-configuration))
  #:use-module ((gnu bootloader grub) #:select (grub-efi-bootloader))
  #:use-module ((gnu system file-systems) #:select (file-system file-system-label)))

(define-public (boot os target label kbl)
  (operating-system
    (inherit os)
    (bootloader (bootloader-configuration
                  (bootloader grub-efi-bootloader)
                  (targets `(,target))
                  (timeout 1)
                  (keyboard-layout kbl)))
    (file-systems
     (cons* (file-system
              (device (file-system-label label))
              (mount-point target)
              (type "vfat"))
            (operating-system-file-systems os)))))
#+end_src
*** Linux Nonfree
#+begin_src scheme :tangle (in-tangle-dir "linux-nonfree.scm")
(define-module (linux-nonfree)
  #:use-module ((gnu system) #:select (operating-system operating-system-firmware operating-system-user-services))
  #:use-module ((nongnu system linux-initrd) #:select (microcode-initrd))
  #:use-module ((nongnu packages linux) #:select (linux linux-firmware))
  #:use-module ((linux-nonfree-substitutes) #:select (with-linux-nonfree-substitutes)))

(define-public (linux-nonfree os)
  (operating-system
    (inherit os)
    (kernel linux)
    (initrd microcode-initrd)
    (firmware (cons* linux-firmware
                     (operating-system-firmware os)))
    (services (with-linux-nonfree-substitutes
               (operating-system-user-services os)))))
#+end_src
**** Substitutes
#+begin_src scheme :tangle (in-tangle-dir "linux-nonfree-substitutes.scm")
(define-module (linux-nonfree-substitutes)
  #:use-module ((gnu services) #:select (modify-services))
  #:use-module ((gnu services base) #:select (guix-service-type guix-configuration %default-authorized-guix-keys))
  #:use-module ((guix gexp) #:select (local-file))
  #:use-module ((guix store) #:select (%default-substitute-urls)))

(define-public (with-linux-nonfree-substitutes services)
  (modify-services services
    (guix-service-type config =>
                       (guix-configuration
                        (inherit config)
                        (substitute-urls
                          (append %default-substitute-urls
                                  (list "https://mirror.brielmaier.net")))
                        (authorized-keys
                          (append %default-authorized-guix-keys
                                  (list (local-file "mirror.brielmaier.net.pub"))))))))
#+end_src
***** Public Key
#+begin_src scheme :tangle (in-tangle-dir "mirror.brielmaier.net.pub")
(public-key
  (ecc
    (curve Ed25519)
    (q #7514F8D729DB1935470A581CE3851ED9FD6F1F9BAFE1D8BEC77A931ADB7A4337#)))
#+end_src
*** Disk Encryption
#+begin_src scheme :tangle (in-tangle-dir "disk-encryption.scm")
(define-module (disk-encryption)
  #:use-module ((gnu system) #:select (operating-system operating-system-mapped-devices))
  #:use-module ((gnu system file-systems) #:select (uuid))
  #:use-module ((gnu system mapped-devices) #:select (mapped-device luks-device-mapping)))

(define-public (encrypted-device source-uuid target-name)
  (mapped-device
    (source (uuid source-uuid))
    (target target-name)
    (type luks-device-mapping)))

(define-public (disk-encryption os encrypted-device)
  (operating-system
    (inherit os)
    (mapped-devices
     (cons* encrypted-device
            (operating-system-mapped-devices os)))))
#+end_src
*** Stateless
#+begin_src scheme :tangle (in-tangle-dir "stateless.scm")
(define-module (stateless)
  #:use-module ((gnu services) #:select (service))
  #:use-module ((gnu system) #:select (operating-system operating-system-initrd operating-system-user-services))
  #:use-module ((stateless-service) #:select (stateless-service-type))
  #:export (stateless))

(define* (stateless os persist-dir #:key (bluetooth? #t))
  (operating-system
    (inherit os)
    (initrd (lambda (file-systems . rest)
              (apply (operating-system-initrd os) file-systems
                     #:volatile-root? #t
                     rest)))
    (services
     (append
      (operating-system-user-services os)
      ;; Stateless service should come after base/desktop services so its state gets installed before theirs during activation.
      (list
       (service stateless-service-type
                `(#:persist-dir ,persist-dir
                  #:paths ,(append
                            '("/etc/machine-id"
                              "/var/lib/random-seed"
                              "/etc/NetworkManager/system-connections"
                              "/var/lib/NetworkManager/secret_key"
                              "/etc/guix/signing-key.pub"
                              "/etc/guix/signing-key.sec")
                            (if bluetooth?
                                (list "/var/lib/bluetooth") '())))))))))
#+end_src
**** Service
#+begin_src scheme :tangle (in-tangle-dir "stateless-service.scm")
(define-module (stateless-service)
  #:use-module ((gnu packages gnupg) #:select (guile-gcrypt))
  #:use-module ((gnu services) #:select (service-type service-extension boot-service-type activation-service-type))
  #:use-module ((guix gexp) #:select (gexp with-extensions with-imported-modules))
  #:use-module ((guix modules) #:select (source-module-closure)))

(define (populate-gexp config)
  (with-extensions (list guile-gcrypt)
    (with-imported-modules (source-module-closure
                            '((gnu build install)))
      #~(begin
          (use-modules ((gnu build install) #:select (populate-root-file-system)))

          (define* (populate #:key persist-dir #:allow-other-keys)
            (let ((system-link (readlink "/var/guix/profiles/system"))
                  (system-1-link (readlink "/var/guix/profiles/system-1-link")))
              (populate-root-file-system system-1-link ""
                                         #:extras `(("/var/guix/profiles/system" -> ,system-link))))
            ;; I'd like to do this during activation with the rest of the state but I can't get the activation service to run before account-service and I don't want to overwrite any changes it makes to these files.
            (for-each (lambda (path)
                        (copy-file (string-append persist-dir path) path))
                      '("/etc/group"
                        "/etc/passwd"
                        "/etc/shadow")))

          (apply populate '#$config)))))

(define (activate-state-gexp config)
  #~(begin
      (use-modules ((ice-9 match) #:select (match)))

      (define* (activate-state #:key persist-dir paths)

        (define (install path)
          (let loop ((components (string-tokenize path (char-set-complement (char-set #\/))))
                     (base persist-dir)
                     (target-base ""))
            (match components
              ((head tail ...)
               (let* ((path (string-append base "/" head))
                      (target-path (string-append target-base "/" head)))
                 (if (null? tail)
                     ;; The Guix code makes a point of doing stuff like this atomically. I don't really know why but I will too.
                     (let ((pivot (string-append target-path ".new")))
                       (symlink path pivot)
                       (rename-file pivot target-path))
                     (begin
                       (catch 'system-error
                         (lambda ()
                           (mkdir target-path))
                         (lambda args
                           (unless (= EEXIST (system-error-errno args))
                             (apply throw args))))
                       (let ((st (lstat path)))
                         (chown target-path (stat:uid st) (stat:gid st))
                         (chmod target-path (stat:perms st)))
                       (loop tail path target-path))))))))

        (for-each install paths))

      (apply activate-state '#$config)))

(define-public stateless-service-type
  (service-type (name 'stateless)
                (extensions
                 (list (service-extension boot-service-type
                                          populate-gexp)
                       (service-extension activation-service-type
                                          activate-state-gexp)))))
#+end_src
*** Macbook
I'm not sure if this requires [[Linux Nonfree][Linux Nonfree]] and/or if the blacklist refers to kernel modules that are only in the nonfree linux kernel (i.e., not linux-libre)
#+begin_src scheme :tangle (in-tangle-dir "macbook.scm")
(define-module (macbook)
  #:use-module ((gnu system) #:select (operating-system operating-system-firmware operating-system-user-kernel-arguments operating-system-kernel-loadable-modules))
  #:use-module ((gnu system keyboard) #:select (keyboard-layout))
  #:use-module ((nongnu packages linux) #:select (broadcom-bt-firmware broadcom-sta))
  #:use-module ((srfi srfi-1) #:select (any))
  #:export (macbook))

(define (with-blacklist kernel-args new)

  (define (update-list pred l f)
    (map (lambda (x)
           (if (pred x) (f x) x))
         l))

  (define (blacklist? ka)
    (string-prefix? "modprobe.blacklist" ka))

  (if (any blacklist? kernel-args)
      (update-list blacklist? kernel-args (lambda (blacklist)
                                            (string-append blacklist "," new)))
      (cons* (string-append "modprobe.blacklist=" new) kernel-args)))

(define* (macbook os #:key (bluetooth? #t))
  (operating-system
    (inherit os)
    (kernel-arguments (with-blacklist (operating-system-user-kernel-arguments os)
                                      "b43,b43legacy,ssb,bcm43xx,brcm80211,brcmfmac,brcmsmac,bcma"))
    (kernel-loadable-modules (cons* broadcom-sta
                                    (operating-system-kernel-loadable-modules os)))
    (firmware (if bluetooth?
                  (cons* broadcom-bt-firmware
                         (operating-system-firmware os))
                  (operating-system-firmware os)))))

(define-public macbook-kbl
  (keyboard-layout "us" #:model "macbook78"))
#+end_src
*** Users
#+begin_src scheme :tangle (in-tangle-dir "users.scm")
(define-module (users)
  #:use-module ((gnu system) #:select (operating-system operating-system-users))
  #:use-module ((gnu system accounts) #:select (user-account))
  #:export (users))

;; TODO `input' group necessary for mtrack (at present, maybe there's a way around
;; this. Libinput doesn't need it, for example, but maybe it's "built in" or
;; something. Also I'd ideally like the touchpad to work on the gdm login screen.)
(define* (user-groups #:optional bluetooth?)
  (append '("netdev" "audio" "video" "input")
          (if bluetooth? (list "lp") '())))

(define (admin-groups bluetooth?)
  (cons* "wheel" (user-groups bluetooth?)))

(define (main-accounts user-name user-full-name bluetooth?)
  (list
   (user-account
     (name user-name)
     (comment user-full-name)
     (group "users")
     (supplementary-groups (admin-groups bluetooth?)))
   (user-account
     (name "pcoulson")
     (comment "Phil Coulson")
     (group "users")
     (supplementary-groups (admin-groups bluetooth?)))))

(define (guest-account)
  (user-account
    (name "gandalf")
    (comment "Speak Friend and Enter")
    (group "users")
    (supplementary-groups (user-groups))
    (password (crypt "mellon" "toosimple"))))

(define* (users os user-name user-full-name #:key (bluetooth? #t) (guest? #t))
  (operating-system
    (inherit os)
    (users (append (append (main-accounts user-name user-full-name bluetooth?)
                           (if guest? (list (guest-account)) '()))
                   (operating-system-users os)))))
#+end_src
*** Frostfire
#+begin_src scheme :tangle (in-tangle-dir "frostfire.scm")
(define-module (frostfire)
  #:use-module ((gnu system) #:select (operating-system operating-system-file-systems))
  #:use-module ((gnu system file-systems) #:select (file-system file-system-label))
  #:use-module ((ice-9 match) #:select (match-lambda))
  #:export (frostfire))

(define* (frostfire os host-name label subvols-spec #:key dependencies)
  (operating-system
    (inherit os)
    (host-name host-name)
    (file-systems
      (append
       (map (match-lambda
              ((subvol mount-point)
               (file-system
                 (device (file-system-label label))
                 (mount-point mount-point)
                 (type "btrfs")
                 (options (string-append "subvol=" subvol ",compress=zstd,autodefrag"))
                 (needed-for-boot? (if (member subvol '("guix-var" "log" "persist")) #t #f))
                 (dependencies (or dependencies '())))))
            (apply (lambda* (#:key root boot guix-store guix-var log home persist persist-path)
                     `((,root "/")
                       (,boot "/boot")
                       (,guix-store "/gnu/store")
                       (,guix-var "/var/guix")
                       (,log "/var/log")
                       (,home "/home")
                       (,persist ,persist-path)))
                   subvols-spec))
       (operating-system-file-systems os)))))
#+end_src
*** Frostfire OS
#+begin_src scheme :tangle (in-tangle-dir "frostfire-os.scm") :noweb yes
(define-module (frostfire-os)
  #:use-module ((empty-os) #:select (empty-os))
  #:use-module ((base-os) #:select (base-os))
  #:use-module ((boot) #:select (boot))
  #:use-module ((linux-nonfree) #:select (linux-nonfree))
  #:use-module ((disk-encryption) #:select (disk-encryption encrypted-device))
  #:use-module ((stateless) #:select (stateless))
  #:use-module ((macbook) #:select (macbook macbook-kbl))
  #:use-module ((users) #:select (users))
  #:use-module ((frostfire) #:select (frostfire)))

(define-syntax ->
  (syntax-rules ()
    ((_ value) value)
    ((_ value (f1 . body) next ...) (-> (f1 value . body) next ...))
    ((_ value f1 next ...) (-> (f1 value) next ...))))

(let ((kbl macbook-kbl)
      (ciphered (encrypted-device "bdda56af-6ca0-4953-bc13-d5af8715e0e5" "ciphered"))
      (persist-path "/.persist"))
  (-> empty-os
      (base-os kbl)
      (boot "/boot/efi"
            "genesis"
            kbl)
      linux-nonfree
      (disk-encryption ciphered)
      (stateless persist-path)
      macbook
      (users "<<user-name>>"
             "<<user-full-name>>")
      (frostfire "frostfire"
                 "firmament"
                 `(#:root "root-blank"
                   #:boot "boot"
                   #:guix-store "guix-store"
                   #:guix-var "guix-var"
                   #:log "log"
                   #:home "home"
                   #:persist "persist"
                   #:persist-path ,persist-path)
                 #:dependencies (list ciphered))))
#+end_src
#+begin_src sh :results output silent :dir (get-tangle-dir) :async
sudo guix system --load-path=. reconfigure frostfire-os.scm
#+end_src
** Xorg config
#+begin_src conf :tangle (in-tangle-dir "xorg.conf")
Section "InputClass"
  Identifier      "Keyboards"
  Driver          "libinput"
  MatchIsKeyboard "on"
EndSection
Section "InputClass"
  Identifier      "Touchpads"
  Driver          "mtrack"
  MatchIsTouchpad "on"
EndSection
#+end_src
** Spartan WM
#+begin_src scheme :tangle (in-tangle-dir "spartan-wm.scm") :noweb yes
(define-module (spartan-wm)
  #:use-module ((guix packages) #:select (package))
  #:use-module ((guix build-system trivial) #:select (trivial-build-system)))

(define-public spartan-wm
  (package
   (name "spartan-wm")
   (version "0")
   (synopsis "Spartan Window Manager")
   (source #f)
   (build-system trivial-build-system)
   (arguments
    `(#:modules ((guix build utils))
      #:builder
      (begin
        (use-modules ((guix build utils) #:select (mkdir-p make-desktop-entry-file)))
        (let* ((out (assoc-ref %outputs "out"))
               (xsessions (string-append out "/share/xsessions")))
          (mkdir-p xsessions)
          (make-desktop-entry-file
           (string-append xsessions "/" ,name ".desktop")
           #:name "Spartan WM"
           #:comment ,synopsis
           #:exec "<<spartan-executable>>"))
        #t)))
   (description synopsis)
   (home-page #f)
   (license #f)))
#+end_src
* Home
:PROPERTIES:
:tangle-dir+: home
:END:
#+name: guix-home-profile
#+begin_src sh
~/.guix-home/profile
#+end_src
#+name: guix-extra-profiles-path
#+begin_src sh
~/.guix-extra-profiles
#+end_src
** ~home-environment~
*** Solitude
- TODO direnv
  RDE and upstream Guix Home have incompatibly diverged for the moment, comment the direnv use-module and the `home-bash-direnv-service-type` usage line back in when they're back in sync.
#+begin_src scheme :tangle (in-tangle-dir "solitude.scm") :noweb yes
(define-module (solitude)
  #:use-module ((gnu home) #:select (home-environment))
  #:use-module ((gnu home services) #:select (home-files-service-type))
  ;; #:use-module (gnu home services mcron)
  #:use-module ((gnu home services shells) #:select (home-bash-service-type home-bash-configuration))
  ;; #:use-module (gnu home-services gnupg)
  ;; #:use-module (gnu home-services ssh)
  ;; #:use-module ((gnu home-services shellutils) #:select (home-bash-direnv-service-type))
  #:use-module ((gnu home-services version-control) #:select (home-git-service-type home-git-configuration))
  #:use-module ((gnu services) #:select (service simple-service))
  #:use-module ((gnu packages) #:select (specification->package))
  ;; #:use-module (gnu packages linux)
  ;; #:use-module (gnu packages admin)
  ;; #:use-module (gnu packages gnupg)
  ;; #:use-module (gnu system keyboard)
  #:use-module ((guix gexp) #:select (file-append local-file))


  #:use-module ((guix packages) #:select (package-input-rewriting))
  #:use-module ((gnu packages emacs) #:select (emacs emacs-minimal emacs-no-x))
  #:use-module ((flat packages emacs) #:select (emacs-native-comp))


  #:use-module ((initialization core) #:select (initialization))
  #:use-module ((spartan core) #:select (spartan))

  #:use-module ((doom-emacs-temp) #:select (doom-emacs-temp))
  #:use-module ((emacs-desktop-environment-temp) #:select (emacs-desktop-environment-temp))
  #:use-module ((gnu packages gtk) #:select (gtk+)))

(define emacs-variant emacs-native-comp)

; TODO Guix Home has an emacs service with a parameter `rebuild-elisp-packages?` that accomplishes I think the same thing as this but it's based on `substitute-keyword-arguments` instead of `package-input-rewriting`. How doe these approaches compare?
(define with-emacs-variant
  (package-input-rewriting `((,emacs . ,emacs-variant)
                             (,emacs-minimal . ,emacs-variant)
                             (,emacs-no-x . ,emacs-variant))))

(define solitude
  (home-environment
   ;; (packages (list htop))
   (packages (list ;; emacs-variant ; TODO add this back when I can do so without eating up all my inodes (update: or do I want it in a manifest instead? Or better yet, since [if I recall] the only thing I needed the "direct" access to the emacs program for was running `doom upgrade` just make it a non-propagated input to my eventual Doom guix package. That is, if I even end up running `doom upgrade` after packaging Doom). Also delete bastille manifest
                   (with-emacs-variant spartan)
                   (with-emacs-variant doom-emacs-temp)
                   ;; TODO temp emacs stuff
                   (with-emacs-variant emacs-desktop-environment-temp) ; TODO donno where this should really go
                   ;; (list gtk+ "bin") ; For `gtk-launch' for counsel-linux-app ; TODO make this an input to a/the counsel package ; TODO using this package massively increases the number of used inodes and build time, figure out why later
                   (specification->package "font-adobe-source-code-pro"))) ; TODO (propagated) dependency of Doom config, move it somewhere when I figure out how I'm doing Emacs/Doom guix configuration.
   (services
    (list
     (simple-service 'my-channels
                     home-files-service-type
                     (list `("config/guix/channels.scm"
                             ,(local-file "channels.scm"))))
     (service home-bash-service-type
              (home-bash-configuration
               (environment-variables
                `(("VISUAL" . ,(file-append emacs-variant "/bin/emacsclient"))
                  ("EDITOR" . "$VISUAL")
                  ("LESSHISTFILE" . "$XDG_CACHE_HOME/.lesshst")))
               (bash-profile
                `(,(local-file "bash_profile")
                  ,(file-append initialization "/script.sh"))))) ; This shouldn't really be in the bash profile but I can't find a good way to run a script post-login.
     (service home-git-service-type
              (home-git-configuration
               (config
                `((user
                   ((name . "<<user-full-name>>")
                    (email . "<<user-email>>")))
                  ;; (http "https://weak.example.com"
                  ;;   ((ssl-verify . #f)))
                  ;; (gpg
                  ;;  ((program . ,(file-append gnupg "/bin/gpg"))))
                  ;; (sendmail
                  ;;  ((annotate . #t)))
                  ))))
     (simple-service 'my-doomdir
                     home-files-service-type
                     (list `("config/doom"
                             ,(local-file "doom" #:recursive? #t))))
     ;; (service home-bash-direnv-service-type)
     ;; (service home-keyboard-service-type
     ;;          (keyboard-layout "us,ru" "dvorak,"
     ;;                           #:options '("grp:win_space_toggle" "ctrl:nocaps")))
     ;; (service home-fontconfig-service-type)
     ;; (simple-service 'my-fontconfig-config-file
     ;;                 home-files-service-type
     ;;                 (list `("config/fontconfig/fonts.conf"
     ;;                         ,(plain-file "fonts.conf" %my-fontconfig-config-file))))
     ;; (service home-ssh-service-type
     ;;          (home-ssh-configuration
     ;;           (extra-config
     ;;            (list
     ;;             (ssh-host "savannah"
     ;;                       '((compression . #f)))))))
     ;; (service home-gnupg-service-type
     ;;          (home-gnupg-configuration
     ;;           (gpg-agent-config
     ;;            (home-gpg-agent-configuration
     ;;             (ssh-agent? #t)))))
     ;; (service home-state-service-type
     ;;          (append
     ;;           (list
     ;;            (state-rsync "/home/bob/tmp/example-rsync-state/"
     ;;                         "abcdw@olorin.lan:/var/services/homes/abcdw/tmp-state/")
     ;;            (state-git "/home/bob/tmp/talkes/"
     ;;                       "git@git.sr.ht:~abcdw/rde"))))
     ))))

solitude
#+end_src
#+begin_src sh :results output silent :dir (get-tangle-dir) :async
guix home --load-path=. reconfigure solitude.scm
#+end_src
** Bash profile
:PROPERTIES:
:header-args+: :tangle (in-tangle-dir "bash_profile")
:END:
*** Use Guix extra profiles
#+begin_src sh :noweb yes
gepp="<<guix-extra-profiles-path>>"
GUIX_EXTRA_PROFILES="${gepp/#\~/$HOME}"

for i in $GUIX_EXTRA_PROFILES/*; do
  profile=$i/$(basename "$i")
  if [ -f "$profile"/etc/profile ]; then
    GUIX_PROFILE="$profile"
    . "$GUIX_PROFILE"/etc/profile
  fi

  # Emulate guix-home setup-environment file (and thus `/etc/profile` as well). Regarding MANPATH and INFOPATH in particular, see https://guix.gnu.org/en/cookbook/en/guix-cookbook.html#Required-packages
  case $XDG_DATA_DIRS in
    ,*"$profile"/share*) ;;
    ,*) export XDG_DATA_DIRS="$profile"/share:$XDG_DATA_DIRS ;;
  esac
  case $MANPATH in
    ,*"$profile"/share/man*) ;;
    ,*) export MANPATH="$profile"/share/man:$MANPATH
  esac
  case $INFOPATH in
    ,*"$profile"/share/info*) ;;
    ,*) export INFOPATH="$profile"/share/info:$INFOPATH ;;
  esac
  case $XDG_CONFIG_DIRS in
    ,*"$profile"/etc/xdg*) ;;
    ,*) export XDG_CONFIG_DIRS="$profile"/etc/xdg:$XDG_CONFIG_DIRS ;;
  esac
  case $XCURSOR_PATH in
    ,*"$profile"/share/icons*) ;;
    ,*) export XCURSOR_PATH="$profile"/share/icons:$XCURSOR_PATH ;;
  esac

  unset profile
done
#+end_src
** Initialization
:PROPERTIES:
:tangle-dir+: initialization
:END:
#+begin_src scheme :tangle (in-tangle-dir "core.scm")
(define-module (initialization core)
  #:use-module ((guix packages) #:select (package))
  #:use-module ((guix gexp) #:select (local-file))
  #:use-module ((guix build-system trivial) #:select (trivial-build-system))
  #:use-module ((gnu packages xorg) #:select (xinput xkbcomp xrandr)))

(define-public initialization
  (package
    (name "Initialization")
    (version "0")
    (source #f)
    (native-inputs
     `(("script.sh" ,(local-file "script.sh"))))
    (inputs
     `(("xkbcomp" ,xkbcomp)
       ("xkb-source" ,(local-file "current_setxkbmap_print.xkb"))
       ("xkb-custom" ,(local-file "xkb_custom" #:recursive? #t))
       ("xinput" ,xinput)
       ("xrandr" ,xrandr)))
    (build-system trivial-build-system)
    (arguments
    '(#:modules ((guix build utils))
      #:builder
      (begin
        (use-modules ((guix build utils) #:select (mkdir-p substitute*)))
        (let* ((out (assoc-ref %outputs "out"))
               (get-input (lambda (k)
                            (assoc-ref %build-inputs k)))
               (cmd (lambda* (input #:optional (executable input))
                      (string-append (get-input input) "/bin/" executable)))
               (install-input (lambda* (input-file #:optional (name (basename input-file)))
                                (let ((newfile (string-append out "/" name)))
                                  (mkdir-p (dirname newfile))
                                  (copy-file (get-input input-file) newfile)
                                  newfile))))
          (let ((script-file (install-input "script.sh")))
            (substitute* script-file
              (("xkbcomp") (cmd "xkbcomp"))
              (("xkb_source=" all) (string-append all (get-input "xkb-source")))
              (("xkb_custom=" all) (string-append all (get-input "xkb-custom")))
              (("xinput") (cmd "xinput"))
              (("xrandr") (cmd "xrandr")))))
        #t)))
    (synopsis #f)
    (description #f)
    (home-page #f)
    (license #f)))
#+end_src
*** Script
#+begin_src sh :tangle (in-tangle-dir "script.sh")
xkb_custom=
xkb_source=
xkbcomp -I$xkb_custom $xkb_source $DISPLAY

trackpad_set ()
{
  xinput set-prop "bcm5974" "$@"
}
trackpad_set "Device Accel Profile" 2
trackpad_set "Trackpad Sensitivity" 0.08
trackpad_set "Trackpad Edge Sizes" 15, 15, 15, 15 # TODO make the sides smaller (like macOS). Maybe turn the top and bottom down a bit too.
trackpad_set "Trackpad Scroll Settings" 150, 10, 0 # TODO trying this out, doesn't seem to do anything in chromium, maybe a full restart?
trackpad_set "Trackpad Scroll Coasting" 0.05 200
trackpad_set "Trackpad Scroll Buttons" 5, 4, 7, 6 # Invert vertical and horizontal scrolling.
trackpad_set "Trackpad Drag Settings" 0, 350, 40, 200, 500 # First value disables, others are defaults.
# Three-finger dragging
trackpad_set "Trackpad Swipe Settings" 1, 0, 1000
trackpad_set "Trackpad Swipe Buttons" 1, 1, 1, 1
# Trying out
trackpad_set "Trackpad Swipe Settings" 1, 0, 1500
trackpad_set "Trackpad Palm Detection" 1, 0
trackpad_set "Trackpad Palm Size" 30
# trackpad_set "Trackpad Scroll Settings" 250, 10, 0
trackpad_set "Trackpad Hold1Move1 Stationary Settings" 20, 0 # First value is the default, second value disables. # TODO I think?
trackpad_set "Trackpad Edge Scroll Settings" 105, 20, 0, 0, 0, 0, 0 # First three values are defaults, last four disable. # TODO I think? Otherwise disable by just setting the distance really high?

xrandr --fb 2724x1800 --output eDP-1 --transform 1,0,-156,0,1,0,0,0,1
#+end_src
*** XKB
- TODO I'm using "C" for the xkb syntax currently, what should it be / is there a value for "no language"? Don't do this until the end.
**** current_setxkbmap_print
#+begin_src c :tangle (in-tangle-dir "current_setxkbmap_print.xkb")
xkb_keymap {
	xkb_keycodes  { include "evdev+aliases(qwerty)"	};
	xkb_types     { include "complete+numpad(mac)"	};
	xkb_compat    { include "complete"	};
	xkb_symbols   { include "pc+macintosh_vndr/us+inet(evdev)+ctrl(nocaps)+shift(both_capslock)+mysymbols(semicolon_to_control)"	};
	xkb_geometry  { include "macintosh(macbook78)"	};
};
#+end_src
**** Custom
#+begin_src c :tangle (in-tangle-dir "xkb_custom/symbols/mysymbols")
partial modifier_keys
xkb_symbols "semicolon_to_control" {
    key <AC10> { [ Control_R, colon ] };
    modifier_map Control { <AC10> };
};
#+end_src
** Guix extra profiles
:PROPERTIES:
:tangle-dir+: manifests
:END:
#+name: install-profiles
#+begin_src sh :results output silent :dir (get-tangle-dir) :noweb yes :async
gepp="<<guix-extra-profiles-path>>"
GUIX_EXTRA_PROFILES="${gepp/#\~/$HOME}"

profiles=$*
if [[ $# -eq 0 ]]; then
    profiles="*";
fi

for profile in $profiles; do
  profileName=$(basename $profile .scm)
  profilePath="$GUIX_EXTRA_PROFILES/$profileName"
  mkdir -p $profilePath
  guix package --profile="$profilePath/$profileName" --manifest="$profileName.scm"
done
#+end_src
#+call: install-profiles[:cmdline ...]()

#+name: upgrade-profiles
#+begin_src sh :results output silent :dir (get-tangle-dir) :noweb yes :async
gepp="<<guix-extra-profiles-path>>"
GUIX_EXTRA_PROFILES="${gepp/#\~/$HOME}"

profiles=$*
if [[ $# -eq 0 ]]; then
    profiles="$GUIX_EXTRA_PROFILES/*";
fi

for profile in $profiles; do
  profileName=$(basename $profile)
  profilePath="$GUIX_EXTRA_PROFILES/$profileName"
  guix package --profile="$profilePath/$profileName" --manifest="$profileName.scm"
done
#+end_src
#+call: upgrade-profiles[:cmdline ...]()
*** Manifests
#+name: guix-extra-profile-path
#+begin_src sh :var profileName="" :noweb yes
echo "<<guix-extra-profiles-path>>/$profileName/$profileName"
#+end_src
**** multiverse
#+begin_src scheme :tangle (in-tangle-dir "multiverse.scm")
(specifications->manifest
 '("ungoogled-chromium"
   "protonvpn-cli"
   "btrfs-progs"

   ;; General
   "zip"
   "unzip"
   ;; "openssh" ; TODO Might want this at some point for command line ssh'ing and the like.

   ;; Apps
   ;; "gimp" ; TODO maybe. Or just install as-needed with `guix environment`
   ))
#+end_src
#+begin_src elisp :noweb-ref guix-extra-profiles :noweb-sep " " :noweb yes
"<<guix-extra-profile-path("multiverse")>>"
#+end_src
**** bastille
#+begin_src scheme :tangle (in-tangle-dir "bastille.scm")
;; TODO Getting rid of this (either putting it in "multiverse" manifest or in solitude). Make it a reference to emacs-variant.
(specifications->manifest
 '("emacs-native-comp"))
#+end_src
#+begin_src elisp :noweb-ref guix-extra-profiles :noweb-sep " " :noweb yes
"<<guix-extra-profile-path("bastille")>>"
#+end_src
** Channels
#+begin_src scheme :tangle (in-tangle-dir "channels.scm")
(cons* (channel
        (name 'penitent-tangent)
        (url "file:///home/pharcosyle/Projects/penitent-tangent"))
       (channel
        (name 'flat)
        (url "https://github.com/flatwhatson/guix-channel.git")
        (introduction
         (make-channel-introduction
          "33f86a4b48205c0dc19d7c036c85393f0766f806"
          (openpgp-fingerprint
           "736A C00E 1254 378B A982  7AF6 9DBE 8265 81B6 4490"))))
       (channel
        (name 'rde)
        (url "https://git.sr.ht/~abcdw/rde")
        (introduction
         (make-channel-introduction
          "257cebd587b66e4d865b3537a9a88cccd7107c95"
          (openpgp-fingerprint
           "2841 9AC6 5038 7440 C7E9  2FFA 2208 D209 58C1 DEB0"))))
       (channel
        (name 'nonguix)
        (url "https://gitlab.com/nonguix/nonguix")
        (introduction
         (make-channel-introduction
          "897c1a470da759236cc11798f4e0a5f7d4d59fbc"
          (openpgp-fingerprint
           "2A39 3FFF 68F4 EF7A 3D29  12AF 6F51 20A0 22FB B2D5"))))
       %default-channels)

;; (append (channel
;;          (name 'penitent-tangent)
;;          (url "file:///home/pharcosyle/Projects/penitent-tangent"))
;;         (channel
;;          (name 'flat)
;;          (url "https://github.com/flatwhatson/guix-channel.git")
;;          (introduction
;;           (make-channel-introduction
;;            "33f86a4b48205c0dc19d7c036c85393f0766f806"
;;            (openpgp-fingerprint
;;             "736A C00E 1254 378B A982  7AF6 9DBE 8265 81B6 4490")))
;;          (commit "7b8353ebbcf486e3344924d1cac0fa7ba47c371d"))
;;         (channel
;;          (name 'rde)
;;          (url "https://git.sr.ht/~abcdw/rde")
;;          (introduction
;;           (make-channel-introduction
;;            "257cebd587b66e4d865b3537a9a88cccd7107c95"
;;            (openpgp-fingerprint
;;             "2841 9AC6 5038 7440 C7E9  2FFA 2208 D209 58C1 DEB0")))
;;          (commit "930b9aa377cd4b2fbf43e39b2583df27b70f8ad0"))
;;         (channel
;;          (name 'nonguix)
;;          (url "https://gitlab.com/nonguix/nonguix")
;;          (introduction
;;           (make-channel-introduction
;;            "897c1a470da759236cc11798f4e0a5f7d4d59fbc"
;;            (openpgp-fingerprint
;;             "2A39 3FFF 68F4 EF7A 3D29  12AF 6F51 20A0 22FB B2D5")))
;;          (commit "706d8af5b111d85902280f1154dc4fad683b5281"))
;;         (channel
;;          (name 'guix)
;;          (url "https://git.savannah.gnu.org/git/guix.git")
;;          (introduction
;;           (make-channel-introduction
;;            "9edb3f66fd807b096b48283debdcddccfea34bad"
;;            (openpgp-fingerprint
;;             "BBB0 2DDF 2CEA F6A8 0D1D  E643 A2A0 6DF2 A33A 54FA")))
;;          (commit "20dfda3d9ebb14b72ed33fed940ee3a1f030c99a")))
#+end_src
** Doom
:PROPERTIES:
:tangle-dir+: doom
:END:
*** Init
:PROPERTIES:
:header-args+: :tangle (in-tangle-dir "init.el")
:END:
**** Header
#+begin_src elisp
;;; -*- lexical-binding: t; -*-
#+end_src
**** ~doom!~ block
#+begin_src elisp
(doom! :completion
       company
       (ivy +icons)

       :ui
       doom
       doom-dashboard
       (emoji +unicode)
       hl-todo
       hydra
       indent-guides
       (ligatures +extra)
       modeline
       nav-flash
       ophints
       (popup +defaults +all)
       treemacs
       vc-gutter
       vi-tilde-fringe
       window-select
       workspaces

       :editor
       (evil +everywhere)
       file-templates
       fold
       format
       lispy
       multiple-cursors
       rotate-text
       snippets
       word-wrap

       :emacs
       (dired +icons)
       electric
       (ibuffer +icons)
       undo
       vc

       :term
       eshell
       vterm

       :checkers
       syntax

       :tools
       direnv
       (eval +overlay)
       lookup
       (magit +forge)
       (pass +auth)
       pdf
       prodigy
       rgb
       taskrunner

       :lang
       clojure
       data
       emacs-lisp
       json
       javascript
       markdown
       nix
       (org +journal)
       rest
       (scheme +guile)
       sh
       web
       yaml ; TODO this should probably be specific to the krush/hyperdrive/afterburner(?) project

       :app
       calendar

       :config
       (default +bindings +smartparens))
#+end_src
*** Config
:PROPERTIES:
:header-args+: :tangle (in-tangle-dir "config.el")
:END:
**** Header
#+begin_src elisp
;;; -*- lexical-binding: t; -*-
#+end_src
**** Requires
#+begin_src elisp
(use-package! dash)
#+end_src
**** Personal Info :user:
#+begin_src elisp :noweb yes
(setq user-full-name "<<user-full-name>>"
      user-mail-address "<<user-email>>")
#+end_src
**** Locals :path:
#+begin_src elisp
(defconst biome--org-dir (concat org-directory "~/org"))
(defconst biome--org-gcal-dir (concat biome--org-dir "/gcal"))

(defconst biome--very-big 1000000)
#+end_src
**** General :UI:path:
#+begin_src elisp
;; hlissner says this must be set before org loads. I'm not sure if this is a requirement of org-mode but the Doom org config certainly does a lot of gymnastics with this variable so I'll just set this exactly like the example config does.
(setq org-directory biome--org-dir)

(setq scroll-margin 10
      save-interprogram-paste-before-kill t)

;; I like having line numbers on but hlissner says they're slow so I might want to disable them at some point. Keep in mind I use them to determine what lines are continuation lines so I might have to make the right fringe bigger if I do this and set visual-line-fringe-indicators.
;; (setq display-line-numbers-type nil)
#+end_src
***** Doom resets
#+begin_src elisp
(setq-default indent-tabs-mode t)

;; I'd like to have this on but in the Doom code it says it's more efficient not to.
;; (setq-default cursor-in-non-selected-windows t)
#+end_src
**** Doom
***** UI :UI:theming:
#+begin_src elisp
(setq doom-theme 'doom-nuclear
      doom-font (font-spec :family "Source Code Pro" :size 24))
#+end_src
***** Leader/Localleader :bindings:
#+begin_src elisp
(setq doom-leader-alt-key "s-SPC"
      doom-localleader-key "s-m"
      doom-localleader-alt-key "s-m")
#+end_src
**** Keybindings :bindings:
#+begin_src elisp
(setq help-char (string-to-char "\C-_"))
#+end_src
***** Translations
#+begin_src elisp
(defun biome--trans (&rest rest)
  (-each (-partition 2 rest)
    (-lambda ((to from))
      (define-key key-translation-map (kbd to) (kbd from)))))

(biome--trans "C-h" "DEL"
              "C-?" "C-h"

              "s-i" "<tab>"
              "s-I" "<backtab>"

              "s-h" "<left>"
              "s-j" "<down>"
              "s-k" "<up>"
              "s-l" "<right>")
#+end_src
***** General
#+begin_src elisp
(defalias 'original-yank-pop #'yank-pop)

;; REVIEW Some of these should be in `:after' (or their respective package) sections but I'm not totally certain where I want to put bindings yet and I'm lazy.
(map! "s-V" #'original-yank-pop

      "s-SPC" doom-leader-map

      ;; Copied from Doom MacOS bindings: ~/.config/emacs/modules/config/default/config.el:263
      "s-`" #'other-frame
      "s-n" #'+default/new-buffer
      "s-z" #'undo
      "s-Z" #'redo
      "s-c" (if (featurep 'evil) #'evil-yank #'copy-region-as-kill)
      "s-v" #'yank
      "s-s" #'save-buffer
      "s-x" #'execute-extended-command
      :v "s-x" #'kill-region
      "s-/" (cmd! (save-excursion (comment-line 1)))
      :n "s-/" #'evilnc-comment-or-uncomment-lines
      :v "s-/" #'evilnc-comment-operator

      "s-t" (lookup-key doom-leader-map (kbd "`"))
      "s-f" (cl-flet ((f (lookup-key doom-leader-map (kbd "s b"))))
              ;; `swiper' hangs initially when `visual-line-mode' is active. Plus Doom defaults to having `visual-line-mode' enabled in text-mode (and derived) buffers where it makes more sense to not search linewise.
              (cmd! (if visual-line-mode
                        (letf! ((#'swiper #'swiper-isearch))
                          (f))
                      (f))))
      "s-r" (lookup-key doom-leader-map (kbd "f r"))
      "s-w" (lookup-key doom-leader-map (kbd "b k"))
      "s-d w" (lookup-key doom-leader-map (kbd "w d"))
      "s-d s-w" (cmd! (kill-current-buffer)
                      (+workspace/close-window-or-workspace))
      "s-g" (lookup-key doom-leader-map (kbd "g g"))
      "s-," (lookup-key doom-leader-map (kbd "w w"))
      "s-<" (lookup-key doom-leader-map (kbd "w W"))
      "s-y" (lookup-key doom-leader-map (kbd "i y"))
      "s-{" (lookup-key doom-leader-map (kbd "b p"))
      "s-}" (lookup-key doom-leader-map (kbd "b n"))
      "s-p" (lookup-key global-map (kbd "C-~")) ; TODO if I'm keeping this, improve it to first switch focus to a/the popup window if one isn't focused already

      "s-u" (lookup-key doom-leader-map (kbd "u"))
      "s-U" #'negative-argument         ; Trying this out.
      (:map universal-argument-map
       "s-u" #'universal-argument-more)

      (:after evil-easymotion
       "s-a" (lookup-key evilem-map (kbd "SPC")))

      "s-." #'repeat

      "s-J" #'evil-scroll-down
      "s-K" #'evil-scroll-up

      (:prefix "s-d"
       "." #'repeat-complex-command

       "h" #'git-gutter:popup-hunk
       ;; "o" #'+macos/open-in-default-program ;; TODO consider a Guix alternative? Meh.
       "r" #'projectile-replace
       "t" #'tldr
       "s" #'org-save-all-org-buffers
       "a" #'link-hint-open-multiple-links
       ;; "b" (cmd! (evil-local-mode 'toggle)
       ;;           (when evil-local-mode (evil-normal-state)))
       (:prefix "c"
        "f" #'org-gcal-fetch
        "s" #'org-gcal-sync
        "p" #'org-gcal-post-at-point)))
#+end_src
**** Packages
***** All-the-icons Dired
#+begin_src elisp
(after! all-the-icons-dired
  (setq all-the-icons-dired-monochrome nil))
#+end_src
***** Avy
#+begin_src elisp
(after! avy
  (setq avy-single-candidate-jump t))
#+end_src
***** Battery :UI:
#+begin_src elisp
(use-package! battery
  :config
  (display-battery-mode 1))
#+end_src
***** Clojure :lang:clojure:bindings:
#+begin_src elisp :tangle (in-tangle-dir "init.el")
(use-package-hook! clojure-mode
  :post-init
  (setq clojure-refactor-map-prefix (kbd "s-M r"))) ; Has to be set before clojure-mode loads so don't put this in a hook. ; TODO temporary binding ; TODO did I already try putting this in a use-package `:init' section?
#+end_src
#+begin_src elisp
(after! clojure-mode
  (set-ligatures! 'clojure-mode :lambda "fn"))
#+end_src
***** Cider :lang:clojure:persistence:
#+begin_src elisp
(after! cider
  (setq cider-repl-history-size biome--very-big
        cider-print-options '(("length" 100))))

;; TODO make sure this is still working after nesting in `after!'
(after! cider-repl
  (add-hook! 'cider-repl-mode-hook
             #'goto-address-prog-mode
             #'highlight-numbers-mode
             #'rainbow-delimiters-mode
             #'yas-minor-mode-on
             #'biome--sp-strict-h))
#+end_src
***** Clj Refactor :lang:clojure:bindings:
#+begin_src elisp
(after! clj-refactor
  ;; TODO make sure this is still working after nesting in `after!'
  (add-hook! 'clj-refactor-mode-hook
    (cljr-add-keybindings-with-prefix "s-M R"))) ; TODO temporary binding
#+end_src
***** Counsel :completion:UI:
#+begin_src elisp
(after! counsel
  (setq counsel-yank-pop-separator "\n--------------------------------\n"))
#+end_src
***** Doom Modeline :UI:
#+begin_src elisp
(after! doom-modeline
  ;; (setq doom-modeline-checker-simple-format nil)
  (setq doom-modeline-major-mode-icon t)
  (setq doom-modeline-persp-name t))
#+end_src
***** Doom Themes :UI:
#+begin_src elisp
;; TODO get rid of this if I'm not going to try it out again
;; (after! doom-themes
;;   (doom-themes-visual-bell-config))
#+end_src
***** Emacs Lisp :lang:
#+begin_src elisp
(after! elisp-mode
  (setq-hook! 'emacs-lisp-mode-hook indent-tabs-mode nil))
#+end_src
***** Emojify :UI:
#+begin_src elisp
(after! emojify
  (setq emojify-display-style 'unicode))
#+end_src
***** Eshell :persistence:
#+begin_src elisp
(after! eshell
  (setq eshell-history-size biome--very-big)) ; Setting this to `nil' to inherit envvar HISTSIZE is another option.
#+end_src
***** Evil :UI:theming:
#+begin_src elisp
(after! evil
  (setq evil-default-cursor (lambda () (evil-set-cursor-color "#fdd94a"))
        evil-emacs-state-cursor (lambda () (evil-set-cursor-color "#ff9999"))))
#+end_src
***** Evil Org :org:bindings:
#+begin_src elisp
(after! evil-org
  (map! :map evil-org-mode-map
        :nv "C-j" #'outline-forward-same-level
        :nv "C-k" #'outline-backward-same-level))
#+end_src
***** Evil Multiedit
#+begin_src elisp
(after! evil-multiedit
  (setq evil-multiedit-follow-matches t))
#+end_src
***** Expand Region :bindings:
#+begin_src elisp
(use-package! expand-region
  :defer t
  :init
  (map! :nv "s-e" #'er/expand-region
        :nv "s-E" #'er/contract-region)
  :config
  (setq expand-region-fast-keys-enabled nil) ; My mapping is conventient enough and I don't want the repeat key to conflict with anything.
  ;; Copied from Doom config: ~/.config/emacs/modules/config/default/+emacs.el:12
  (defadvice! biome--quit-expand-region-a (&rest _)
    "Properly abort an expand-region region."
    :before '(evil-escape doom/escape)
    (when (memq last-command '(er/expand-region er/contract-region))
      (er/contract-region 0))))
#+end_src
***** Highlight Indent Guides :lang:prog_mode:UI:
#+begin_src elisp
;; I don't want indent guides on by default, remove all the Doom module's hooks.
(remove-hook! '(prog-mode-hook
                text-mode-hook
                conf-mode-hook)
  #'highlight-indent-guides-mode)
#+end_src
***** Ivy :completion:bindings:UI:
#+begin_src elisp
(after! ivy
  (setq +ivy-buffer-preview t
        ivy-extra-directories nil
        ivy-count-format "(%d/%d) ")
  (dolist (i '(counsel-yank-pop
               counsel-evil-registers))
    (add-to-list 'ivy-height-alist `(,i . 10)))

  (map! :map ivy-minibuffer-map
        "s-J" #'ivy-scroll-up-command
        "s-K" #'ivy-scroll-down-command
        "C-r" #'ivy-reverse-i-search ; Doom overrides this, restore it.
        :map ivy-reverse-i-search-map
        "C-k" #'previous-line
        "s-D" #'ivy-reverse-i-search-kill)) ; TODO temporary binding
#+end_src
***** Ivy Hydra :completion:bindings:
#+begin_src elisp
(after! ivy-hydra
  (defhydra+ hydra-ivy ()
    ;; Doom overrides these imporant ivy hydra heads: ~/.config/emacs/modules/completion/ivy/autoload/hydras.el
    ("m" ivy-mark)
    ("u" ivy-unmark)
    ("t" ivy-toggle-marks)))
#+end_src
***** Lispy :lisp:
#+begin_src elisp
;; Not using lispy, remove all the Doom module's hooks.
(remove-hook! '(lisp-mode-hook
                emacs-lisp-mode-hook
                ielm-mode-hook
                scheme-mode-hook
                racket-mode-hook
                hy-mode-hook
                lfe-mode-hook
                dune-mode-hook
                clojure-mode-hook
                fennel-mode-hook)
  #'lispy-mode)
(remove-hook! 'eval-expression-minibuffer-setup-hook #'doom-init-lispy-in-eval-expression-h)
#+end_src
***** Lispyville :lisp:lang:prog_mode:bindings:
#+begin_src elisp :tangle (in-tangle-dir "init.el")
(use-package-hook! lispyville
  :post-init
  (setq lispyville-key-theme nil))
#+end_src
#+begin_src elisp
(use-package! lispyville
  :hook (prog-mode . lispyville-mode)
  :config
  (lispyville-set-key-theme
   '(operators
     c-w
     c-u
     commentary))

  (map! :map lispyville-mode-map
        "s-C-j" #'lispyville-beginning-of-next-defun
        "s-C-k" #'lispyville-beginning-of-defun
        "s-C-," #'lispyville-end-of-defun
        "s-C-a" #'lispyville-drag-backward
        "s-C-g" #'lispyville-drag-forward
        "s-C-p" #'lispyville-prettify
        (:prefix "s-C-;"
         "R" #'lispyville-raise-list)))
#+end_src
***** Magit :UI:persistence:
#+begin_src elisp
(after! magit
  (setq magit-revision-show-gravatars '("^Author:     " . "^Commit:     "))
  (setq transient-history-limit biome--very-big))
#+end_src
***** Man :guix:
#+begin_src elisp :noweb yes
(after! man
  (prependq! Man-header-file-path
             (-concat (-map (lambda (p)
                              (concat p "/include"))
                            '(<<guix-extra-profiles>>))
                      '("<<guix-home-profile>>/include"))))
#+end_src
***** Org :org:UI:path:
#+begin_src elisp
(after! org
  (setq org-agenda-files `(,biome--org-dir
                           ,biome--org-gcal-dir
                           ,(concat biome--org-dir "/projects"))
        org-log-done 'time
        org-priority-lowest ?E
        org-priority-default ?C
        org-priority-faces `((?A . ,(doom-color 'red))
                             (?B . ,(doom-color 'orange))
                             (?C . ,(doom-color 'blue))
                             (?D . ,(doom-color 'yellow))
                             (?E . ,(doom-color 'green)))))
#+end_src
***** Org Gcal :user:secret:persistence:path:
#+begin_src elisp
(after! org-gcal
  (setq org-gcal-client-id "446729771716-pp79934q99aro2h8v3iki1fejcodbdoo.apps.googleusercontent.com"
        org-gcal-client-secret (-> (auth-source-search :host org-gcal-client-id) car (plist-get :secret) funcall)
        org-gcal-fetch-file-alist `((user-mail-address . ,(concat biome--org-gcal-dir "/" user-mail-address ".org"))
                                    ("addressbook%23contacts@group.v.calendar.google.com" . ,(concat biome--org-gcal-dir "/contacts.org"))
                                    ("en.usa%23holiday@group.v.calendar.google.com" . ,(concat biome--org-gcal-dir "/holidays.org")))
        org-gcal-recurring-events-mode 'nested))
#+end_src
***** Paren :UI:
#+begin_src elisp
(after! paren
  (setq! show-paren-delay 0))
#+end_src
***** Prog Mode :lang:prog_mode:
#+begin_src elisp
(add-hook! 'prog-mode-hook #'biome--sp-strict-h)
#+end_src
***** Rainbow Delimiters :UI:theming:
#+begin_src elisp
(after! rainbow-delimiters
  (setq rainbow-delimiters-max-face-count 8)) ; TODO make sure this is working and I didn't need to put it in an `:init'`or anything
#+end_src
***** Recentf :persistence:
#+begin_src elisp
(after! recentf
  (setq recentf-max-saved-items 500))
#+end_src
***** Smartparens :bindings:
#+begin_src elisp
(after! smartparens
  (map! :map smartparens-mode-map
        "s-C-h" #'sp-backward-sexp
        "s-C-l" #'sp-forward-sexp
        "s-C-u" #'sp-backward-up-sexp
        "s-C-o" #'sp-up-sexp
        :gn "s-C-m" #'sp-backward-down-sexp ; Bind in normal mode explicitly to override the Doom mapping in ~/.config/emacs/modules/config/default/config.el:447
        "s-C-." #'sp-down-sexp
        "s-C-c" #'sp-splice-sexp
        "s-C-s" #'sp-splice-sexp-killing-backward
        "s-C-f" #'sp-splice-sexp-killing-forward
        "s-C-x" #'sp-backward-slurp-sexp
        "s-C-v" #'sp-forward-slurp-sexp
        "s-C-w" #'sp-backward-barf-sexp
        "s-C-r" #'sp-forward-barf-sexp
        (:prefix "s-C-;"
         "(" #'sp-wrap-round
         "[" #'sp-wrap-square
         "{" #'sp-wrap-curly
         "s" #'sp-split-sexp
         "j" #'sp-join-sexp
         "r" #'sp-raise-sexp
         "c" #'sp-convolute-sexp
         "w" #'sp-rewrap-sexp)))
#+end_src
****** Hook :bindings:
#+begin_src elisp
(defun biome--sp-strict-h ()
  (add-hook! 'smartparens-enabled-hook :local
             #'turn-on-smartparens-strict-mode
             (lambda ()
               (map! :map smartparens-strict-mode-map
                     :i "DEL" #'sp-backward-delete-char))))
#+end_src
***** Time :UI:
#+begin_src elisp
(use-package! time
  :config
  (setq display-time-day-and-date t)
  ;; (setq display-time-24hr-format t)
  (display-time-mode 1))
#+end_src
***** Tldr :persistence:path:
#+begin_src elisp
(use-package! tldr
  :defer t
  :config
  (setq tldr-directory-path (concat doom-etc-dir "tldr/")))
#+end_src
***** Tramp :path:guix:
Make tramp work on Guix. Tramp is used locally to do sudo from inside Emacs so include my user-specific paths too.
#+begin_src elisp :noweb yes
(after! tramp
  (prependq! tramp-remote-path
             (-concat (-map (lambda (p)
                              (concat p "/bin"))
                            '(<<guix-extra-profiles>>))
                      '("<<guix-home-profile>>/bin"
                        "~/.config/guix/current/bin"
                        "~/.guix-profile/bin"
                        "~/.guix-profile/sbin"
                        "/run/current-system/profile/bin"
                        "/run/current-system/profile/sbin"))))
#+end_src
***** Undo Fu
#+begin_src elisp
(after! undo-fu
  (setq undo-fu-ignore-keyboard-quit t))
#+end_src
***** Undo Tree :UI:
- TODO am I commenting code, doing notangle, or using the org ~COMMENT~ keyword (https://orgmode.org/manual/Comment-Lines.html)?
#+begin_src elisp
;; (after! undo-tree
;;   (setq undo-tree-visualizer-timestamps t))
#+end_src
**** Projects
***** Hyperdrive :path:
#+begin_src elisp
(pushnew! safe-local-variable-values
          '(cider-preferred-build-tool . shadow-cljs)
          '(cider-default-cljs-repl . shadow)
          '(cider-shadow-default-options . ":app")
          '(cider-offer-to-open-cljs-app-in-browser . nil)
          '(cider-clojure-cli-global-options . "-A:dev")
          '(eval . (setenv "DATOMIC_APP_INFO_MAP" "{:app-name \"neutrino\"}"))
          '(eval . (setenv "DATOMIC_ENV_MAP" "{:env :dev}"))
          '(cider-clojure-cli-global-options . nil))

(prodigy-define-service
  :name "Amplify Mock"
  :command "amplify"
  :args '("mock")
  :cwd "~/Projects/Krush/hyperdrive/apps/singularity"
  :kill-process-buffer-on-stop t)

(prodigy-define-service
  :name "Datomic Access (exogenesis)"
  :command "bash"
  :args '("datomic" "client" "access" "exogenesis")
  :cwd "~/Projects/Krush/hyperdrive/ion/team"
  :kill-process-buffer-on-stop t)
#+end_src
***** Massrealty :path:
#+begin_src elisp
;; (pushnew! safe-local-variable-values
;;           '(ssh-deploy-root-remote . "/ssh:massrealty@35.196.144.73:/home/massrealty/deploy/homes/public_html/")
;;           '(ssh-deploy-automatically-detect-remote-changes . t))

;; (after! org-gcal
;;   (add-to-list 'org-gcal-fetch-file-alist `("krzysztof@massrealty.com" . ,(concat biome--org-gcal-dir "/krzysztof@massrealty.com.org")) 'append))
#+end_src
**** WIP
#+begin_src elisp
(after! org
  (add-to-list 'org-agenda-files (concat biome--org-dir "/spring_cleaning") 'append))

;; (map! "s-b" (cmd!
;;              ;; (message "chainging margin")
;;              ;; (message "%s" (selected-window))
;;              (set-window-margins (selected-window) nil (if (cdr (window-margins))
;;                                                            nil 12))))

;; Run this only when not on EXWM (probably not strictly necessary have this condition)
;; (add-to-list 'initial-frame-alist '(fullscreen . fullboth))

(map! "s-A" #'counsel-linux-app)

(map! :leader
      "s-," (lookup-key doom-leader-map (kbd "<")))

(after! company
  (map! (:map company-active-map
         "s-[" #'company-show-doc-buffer ; Currently opens Help, it would be better if I made it use Helpful.
         "s-]" #'company-show-location)))
#+end_src
***** Dotfiles auto-tangle :path:
- TODO Might be easier to do this with file-local variables.
#+begin_src elisp
;; (setq biome--dotfiles-dir "~/Projects/dotfiles")

;; (add-hook! 'org-mode-hook
;;   (add-hook! 'after-save-hook :local
;;     (when (file-in-directory-p buffer-file-name biome--dotfiles-dir)
;;       ;; TODO ensure there aren't files in the output directory that no longer correspond to the org file. Just wipe it?
;;       (let ((org-confirm-babel-evaluate nil))
;;         (org-babel-tangle)))))
#+end_src
***** Scheme :lang:
#+begin_src elisp
(after! scheme
  (setq-hook! 'scheme-mode-hook indent-tabs-mode nil))
#+end_src
***** Guix :guix:
#+begin_src elisp
(after! (guix-devel scheme)
  (add-hook! 'scheme-mode-hook #'guix-devel-mode))

(after! guix-prettify
  (global-guix-prettify-mode))
#+end_src
*** Packages
#+begin_src elisp :tangle (in-tangle-dir "packages.el")
;; -*- no-byte-compile: t; -*-

(package! bluetooth :pin "147d4690087049c6647b5222ee40baa5002b7586") ; TODO just maybe make this dependent on my "bluetooth feature"
(package! dash :pin "da167c51e9fd167a48d06c7c0ee8e3ac7abd9718") ; TODO make this be introduced by my doom config (where I need it)?
(package! expand-region :pin "95a773bd8f557cbd43d3b2dab2fa4417ec5927ab")
(package! guix :pin "c9aef52121b458297e70bb50f49f7276b4a8d759")
(package! tldr :pin "d3fd2a809a266c005915026799121c78e8b358f0")
(package! trashed :pin "23e782f78d9adf6b5479a01bfac90b2cfbf729fe")
(package! symon :pin "8dd8b6df49b03cd7d31b85aedbe9dd08fb922335")

;; TODO these should probably be introduced by my exwm desktop environment org section or something
(package! exwm :pin "833e5d89e7fc12e79766454ae9982cffeb7e4f5f")
(package! desktop-environment :pin "2c3e0750c11485931f447ea82f80bc90ae07aeba")

;; TODO this should probably be specific to the krush/hyperdrive/afterburner(?) project
;; (package! graphql-mode :pin "2371316a750b807de941184d49ca19d277ecadcd")
#+end_src
*** Theme :UI:theming:
- TODO make the elisp sections subheadings? Pros: more org-mode-y. Cons: Further distances the code from doom-one, there will be a trailing closing paren in a source block all by itself at the end since some of the sections are in an outer sexp.
#+begin_src elisp :tangle (in-tangle-dir "themes/doom-nuclear-theme.el")
;;; doom-nuclear-theme.el --- inspired by Atom One Dark -*- lexical-binding: t; no-byte-compile: t; -*-
;;
;; Copyright (C) 2016-2021 Henrik Lissner
;;
;; Author: Henrik Lissner <https://github.com/hlissner>
;; Created: December 6, 2020
;; Version: 2.0.0
;; Keywords: custom themes, faces
;; Homepage: https://github.com/hlissner/emacs-doom-themes
;; Package-Requires: ((emacs "25.1") (cl-lib "0.5") (doom-themes "2.2.1"))
;;
;;; Commentary:
;;
;; Inspired by Atom's One Dark color scheme.
;;
;;; Code:

(require 'doom-themes)


;;
;;; Variables

(defgroup nuclear-theme nil
  "Options for the `doom-nuclear' theme."
  :group 'doom-themes)

(defcustom nuclear-brighter-modeline nil
  "If non-nil, more vivid colors will be used to style the mode-line."
  :group 'nuclear-theme
  :type 'boolean)

(defcustom nuclear-brighter-comments nil
  "If non-nil, comments will be highlighted in more vivid colors."
  :group 'nuclear-theme
  :type 'boolean)

(defcustom nuclear-padded-modeline doom-themes-padded-modeline
  "If non-nil, adds a 4px padding to the mode-line.
Can be an integer to determine the exact padding."
  :group 'nuclear-theme
  :type '(choice integer boolean))


;;
;;; Theme definition

(def-doom-theme doom-nuclear
  "A dark theme inspired by Atom One Dark."

  ;; name        default   256           16
  ((bg         '("#282c34" "black"       "black" ))
   (fg         '("#DEE2F8" "#bfbfbf"     "brightwhite"  ))

   ;; These are off-color variants of bg/fg, used primarily for `solaire-mode',
   ;; but can also be useful as a basis for subtle highlights (e.g. for hl-line
   ;; or region), especially when paired with the `doom-darken', `doom-lighten',
   ;; and `doom-blend' helper functions.
   (bg-alt     '("#21242b" "black"       "black"        ))
   (fg-alt     '("#5B6268" "#2d2d2d"     "white"        ))

   ;; These should represent a spectrum from bg to fg, where base0 is a starker
   ;; bg and base8 is a starker fg. For example, if bg is light grey and fg is
   ;; dark grey, base0 should be white and base8 should be black.
   (base0      '("#1B2229" "black"       "black"        ))
   (base1      '("#1c1f24" "#1e1e1e"     "brightblack"  ))
   (base2      '("#202328" "#2e2e2e"     "brightblack"  ))
   (base3      '("#23272e" "#262626"     "brightblack"  ))
   (base4      '("#3f444a" "#3f3f3f"     "brightblack"  ))
   (base5      '("#5B6268" "#525252"     "brightblack"  ))
   (base6      '("#73797e" "#6b6b6b"     "brightblack"  ))
   (base7      '("#9ca0a4" "#979797"     "brightblack"  ))
   (base8      '("#DFDFDF" "#dfdfdf"     "white"        ))

   (grey       base4)
   (red        '("#FB8578" "#ff6655" "red"          ))
   (orange     '("#FDCE5F" "#dd8844" "brightred"    ))
   (green      '("#9FED9C" "#99bb66" "green"        ))
   (teal       '("#4db5bd" "#44b9b1" "brightgreen"  ))
   (yellow     '("#EDDC91" "#ECBE7B" "yellow"       ))
   (blue       '("#7DB9FE" "#51afef" "brightblue"   ))
   (dark-blue  '("#5F68DE" "#2257A0" "blue"         ))
   (magenta    '("#E29BF7" "#c678dd" "brightmagenta"))
   (violet     '("#AEB9F3" "#a9a1e1" "magenta"      ))
   (cyan       '("#75E0F9" "#46D9FF" "brightcyan"   ))
   (dark-cyan  '("#5699AF" "#5699AF" "cyan"         ))

   ;; These are the "universal syntax classes" that doom-themes establishes.
   ;; These *must* be included in every doom themes, or your theme will throw an
   ;; error, as they are used in the base theme defined in doom-themes-base.
   (highlight      "#8496FF")
   (vertical-bar   (doom-darken base1 0.1))
   (selection      dark-blue)
   (builtin        blue)
   (comments       (if nuclear-brighter-comments dark-cyan "#63677F"))
   (doc-comments   (doom-lighten (if nuclear-brighter-comments dark-cyan base5) 0.25))
   (constants      yellow)
   (functions      blue)
   (keywords       magenta)
   (methods        violet)
   (operators      cyan)
   (type           orange)
   (strings        green)
   (variables      red)
   (numbers        violet)
   (region         `(,(doom-lighten (car bg-alt) 0.15) ,@(doom-lighten (cdr base1) 0.35)))
   (error          red)
   (warning        yellow)
   (success        green)
   (vc-modified    orange)
   (vc-added       green)
   (vc-deleted     red)

   ;; These are extra color variables used only in this theme; i.e. they aren't
   ;; mandatory for derived themes.
   (modeline-fg              fg)
   (modeline-fg-alt          base5)
   (modeline-bg              (if nuclear-brighter-modeline
                                 (doom-darken blue 0.45)
                               (doom-darken bg-alt 0.1)))
   (modeline-bg-alt          (if nuclear-brighter-modeline
                                 (doom-darken blue 0.475)
                               `(,(doom-darken (car bg-alt) 0.15) ,@(cdr bg))))
   (modeline-bg-inactive     `(,(car bg-alt) ,@(cdr base1)))
   (modeline-bg-inactive-alt `(,(doom-darken (car bg-alt) 0.1) ,@(cdr bg)))

   (-modeline-pad
    (when nuclear-padded-modeline
      (if (integerp nuclear-padded-modeline) nuclear-padded-modeline 4))))


  ;;;; Base theme face overrides
  (((line-number &override) :foreground base4)
   ((line-number-current-line &override) :foreground violet)
   ((font-lock-comment-face &override)
    :background (if nuclear-brighter-comments (doom-lighten bg 0.05)))
   (font-lock-comment-delimiter-face :foreground "#939abd")
   (font-lock-doc-face
    :inherit 'font-lock-comment-face
    :foreground cyan)
   (mode-line
    :background modeline-bg :foreground modeline-fg
    :box (if -modeline-pad `(:line-width ,-modeline-pad :color ,modeline-bg)))
   (mode-line-inactive
    :background modeline-bg-inactive :foreground modeline-fg-alt
    :box (if -modeline-pad `(:line-width ,-modeline-pad :color ,modeline-bg-inactive)))
   (mode-line-emphasis :foreground (if nuclear-brighter-modeline base8 highlight))

   ;;;; clojure-mode
   (clojure-interop-method-face :foreground cyan)
   (clojure-character-face :foreground violet :weight 'bold)
   ;;;; css-mode <built-in> / scss-mode
   (css-proprietary-property :foreground orange)
   (css-property             :foreground green)
   (css-selector             :foreground blue)
   ;;;; doom-modeline
   (doom-modeline-bar :background (if nuclear-brighter-modeline modeline-bg highlight))
   (doom-modeline-buffer-file :inherit 'mode-line-buffer-id :weight 'bold)
   (doom-modeline-buffer-path :inherit 'mode-line-emphasis :weight 'bold)
   (doom-modeline-buffer-project-root :foreground green :weight 'bold)
   ;;;; elscreen
   (elscreen-tab-other-screen-face :background "#353a42" :foreground "#1e2022")
   ;;;; ivy
   (ivy-current-match :background dark-blue :distant-foreground base0 :weight 'normal)
   ;;;; LaTeX-mode
   (font-latex-math-face :foreground green)
   ;;;; markdown-mode
   (markdown-markup-face :foreground base5)
   (markdown-header-face :inherit 'bold :foreground red)
   ((markdown-code-face &override) :background (doom-lighten base3 0.05))
   ;;;; rainbow-delimiters
   (rainbow-delimiters-depth-1-face :foreground fg)
   (rainbow-delimiters-depth-2-face :foreground magenta)
   (rainbow-delimiters-depth-3-face :foreground blue)
   (rainbow-delimiters-depth-4-face :foreground cyan)
   (rainbow-delimiters-depth-5-face :foreground green)
   (rainbow-delimiters-depth-6-face :foreground yellow)
   (rainbow-delimiters-depth-7-face :foreground orange)
   (rainbow-delimiters-depth-8-face :foreground red)
   ;;;; rjsx-mode
   (rjsx-tag :foreground red)
   (rjsx-attr :foreground orange)
   ;;;; solaire-mode
   (solaire-mode-line-face
    :inherit 'mode-line
    :background modeline-bg-alt
    :box (if -modeline-pad `(:line-width ,-modeline-pad :color ,modeline-bg-alt)))
   (solaire-mode-line-inactive-face
    :inherit 'mode-line-inactive
    :background modeline-bg-inactive-alt
    :box (if -modeline-pad `(:line-width ,-modeline-pad :color ,modeline-bg-inactive-alt))))

  ;;;; Base theme variable overrides-
  ())

;;; doom-nuclear-theme.el ends here
#+end_src
** Spartan :UI:
:PROPERTIES:
:tangle-dir+: spartan
:END:
#+begin_src scheme :tangle (in-tangle-dir "core.scm") :noweb yes
(define-module (spartan core)
  #:use-module ((guix packages) #:select (package))
  #:use-module ((guix build-system trivial) #:select (trivial-build-system))
  #:use-module ((guix gexp) #:select (local-file))
  #:use-module ((gnu packages bash) #:select (bash))
  #:use-module ((gnu packages dunst) #:select (dunst))
  #:use-module ((gnu packages emacs) #:select (emacs))
  #:use-module ((gnu packages fonts) #:select (font-google-noto))
  #:use-module ((gnu packages freedesktop) #:select (udiskie))
  ;; #:use-module ((gnu packages gnome-xyz) #:select (papirus-icon-theme))
  #:use-module ((gnu packages glib) #:select (dbus))
  #:use-module ((gnu packages pulseaudio) #:select (pasystray pavucontrol))
  #:use-module ((gnu packages xorg) #:select (xhost xset))
  #:use-module ((gnu packages xdisorg) #:select (redshift xss-lock xsettingsd))
  ;; #:use-module ((penitent-tangent packages dracula-theme) #:select (dracula-theme))
  )

(define-public spartan
  (package
   (name "spartan")
   (version "0")
   (source #f)
   (build-system trivial-build-system)
   ;; At the time of this writing `xsettingsd.conf` and `dunstrc` have no substitutions and could just be regular inputs.
   (native-inputs
    `(("startup-script.sh" ,(local-file "startup-script.sh"))
      ("xsettingsd.conf" ,(local-file "xsettingsd.conf"))
      ("desktop.el" ,(local-file "desktop.el"))
      ("dunstrc" ,(local-file "dunstrc"))))
   (inputs
    `(("bash" ,bash) ; TODO `bash-minimal' might be okay/preferable here
      ("xhost" ,xhost)
      ("xset" ,xset)
      ("xss-lock" ,xss-lock)
      ("xsettingsd" ,xsettingsd)
      ("dbus" ,dbus)
      ("emacs" ,emacs)
      ("dunst" ,dunst)
      ("pasystray" ,pasystray)
      ("redshift:gtk" ,redshift "gtk")
      ("udiskie" ,udiskie)))
   ;; TODO much later, see if there's a way to make any of these not propagated.
   (propagated-inputs
    `(("font-google-noto" ,font-google-noto)
      ;; ("dracula-theme" ,dracula-theme)
      ;; ("papirus-icon-theme" ,papirus-icon-theme)
      ("pavucontrol" ,pavucontrol)))
   (arguments
    '(#:modules ((guix build utils))
      #:builder
      (begin
        (use-modules ((guix build utils) #:select (mkdir-p patch-shebang substitute*)))
        (let* ((out (assoc-ref %outputs "out"))
               (get-input (lambda (k)
                            (assoc-ref %build-inputs k)))
               (cmd (lambda* (input #:optional (executable input))
                      (string-append (get-input input) "/bin/" executable)))
               (install-input (lambda* (input-file #:optional (name (basename input-file)))
                                (let ((newfile (string-append out "/" name)))
                                  (mkdir-p (dirname newfile))
                                  (copy-file (get-input input-file) newfile)
                                  newfile))))
          (let ((desktop-el-file (install-input "desktop.el"))
                (dunstrc-file (install-input "dunstrc")))
            ;; `emacs-substitute-sexps' might be useful here if my needs get more sophisticated.
            (substitute* desktop-el-file
              (("(dunstctl|dunst)" all) (case (string->symbol all)
                                          ((dunst) (string-append (cmd "dunst") " -config " dunstrc-file))
                                          ((dunstctl) (cmd "dunst" "dunstctl"))))
              (("pasystray") (cmd "pasystray"))
              (("redshift-gtk") (cmd "redshift:gtk" "redshift-gtk"))
              (("udiskie") (cmd "udiskie")))
            (let ((executable (install-input "startup-script.sh" "/bin/<<spartan-executable>>"))
                  (xsettingsd-conf-file (install-input "xsettingsd.conf")))
              (substitute* executable
                (("^xhost") (cmd "xhost"))
                (("^xsettingsd") (string-append (cmd "xsettingsd") " --config=" xsettingsd-conf-file))
                (("^xset") (cmd "xset"))
                (("^xss-lock") (cmd "xss-lock"))
                (("dbus-launch") (cmd "dbus" "dbus-launch"))
                (("emacs") (cmd "emacs"))
                (("doom") "~/.config/emacs/bin/doom") ; TODO replace with reference to my eventual Emacs Doom package. I should be able to reverse the order of this substution and the emacs one too if the final path doesn't contain the "emacs" string.
                (("desktop\\.el") desktop-el-file))
              (patch-shebang executable (list (string-append (get-input "bash") "/bin")))
              (chmod executable #o555))))
        #t)))
   (synopsis "Spartan")
   (description synopsis)
   (home-page #f)
   (license #f)))
#+end_src
*** Startup script
#+begin_src sh :tangle (in-tangle-dir "startup-script.sh")
#!/bin/sh
xhost +SI:localuser:$USER
export _JAVA_AWT_WM_NONREPARENTING=1
xsettingsd &
xset r rate 300 30 # TODO tweak?
xss-lock -- slock &
doom env
exec dbus-launch --exit-with-session emacs -mm -l desktop.el # --debug-init
#+end_src
**** Xsettings :theming:
#+begin_src conf :tangle (in-tangle-dir "xsettingsd.conf")
# TODO these
Net/EnableEventSounds 1
Net/EnableInputFeedbackSounds 1

Xft/Antialias 1
Xft/Hinting 1
Xft/HintStyle "hintfull"
Xft/DPI 196608
# Xft/DPI 184320 # TODO I do like the chromium interface size better at this dpi
# Xft/DPI 225280

# Xft/RGBA "rgb"

# Xft/Autohint 0 # TODO donno if the casing is right or if it matters



# Gtk/ToolbarIconSize "large"
# Net/ApplicationPreferDarkTheme 1
# Gtk/FontName "Cantarell 11"
# Gtk/MonospaceFontName "Fira Mono 10"
Gtk/CursorThemeName "Adwaita"
Gtk/CursorThemeSize 48

# TODO theme
# - before doing any more wait until I've picked a browser and have installed more apps like e.g. VLC
# - make sure my browser reads the device theme preference as dark
# - if I don't like dracula try another theme or maybe patch it with my emacs colors (perhaps some other theme would be a better base?)
# - look at dracula / other theme I choose in Gnome to see if it looks "right"
# Net/ThemeName "Dracula"
# TODO icon theme
# Donno about these new papirus icons, daviwil and hlissner seem to like them but I'm not sure I do (the Files icons and particularly the systray ones, can I change just those?). Maybe they'll look better once Dracula is enabled? Maybe a wrong / lower-resolution version of the icons is being used and I need to set up where they're looked for?
# Net/IconThemeName "Papirus-Dark"
# seems like this is the default, at least for dracula
# Gtk/DecorationLayout "menu:minimize,maximize,close"
#+end_src
*** desktop.el
:PROPERTIES:
:header-args+: :tangle (in-tangle-dir "desktop.el")
:END:
#+begin_src elisp
;;; -*- lexical-binding: t; -*-
;; TODO rename efs to biome
;; TODO at end, make sure that all exwm mappings' functions are sharp quoted
;; TODO ~setq!~ for exwm vars with custom setters? Can/should I do them in an ~after!~ block then?
#+end_src
**** EXWM :bindings:
#+begin_src elisp
(defun efs/run-in-background (command)
  (let ((command-parts (split-string command "[ ]+")))
    (apply #'call-process `(,(car command-parts) nil 0 nil ,@(cdr command-parts)))))

(defun efs/exwm-init-hook ()
  (efs/run-in-background "dunst")
  (efs/run-in-background "nm-applet")
  (efs/run-in-background "pasystray")
  (efs/run-in-background "redshift-gtk -l 47:-123")
  (efs/run-in-background "udiskie -t"))

(defun efs/exwm-update-class ()
  (exwm-workspace-rename-buffer exwm-class-name))

(defun efs/exwm-update-title ()
  (pcase exwm-class-name
    ("Chromium-browser" (exwm-workspace-rename-buffer (format "Chromium: %s" exwm-title))))) ; TODO get rid of preceding or trailing "Chromium"

(defun biome--shell-cmd (command)
  (start-process-shell-command command nil command))

(use-package! exwm
  :config
  ;; When window "class" updates, use it to set the buffer name
  (add-hook 'exwm-update-class-hook #'efs/exwm-update-class)

  ;; When window title updates, use it to set the buffer name
  (add-hook 'exwm-update-title-hook #'efs/exwm-update-title)

  ;; When EXWM starts up, do some extra configuration
  (add-hook 'exwm-init-hook #'efs/exwm-init-hook)

  ;; NOTE: Uncomment the following two options if you want window buffers
  ;;       to be available on all workspaces!

  ;; Automatically move EXWM buffer to current workspace when selected
  (setq exwm-layout-show-all-buffers t)

  ;; Display all EXWM buffers in every workspace buffer list
  (setq exwm-workspace-show-all-buffers t)

  ;; NOTE: Uncomment this option if you want to detach the minibuffer!
  ;; Detach the minibuffer (show it with exwm-workspace-toggle-minibuffer)
  ;;(setq exwm-workspace-minibuffer-position 'top)

  ;; Load the system tray before exwm-init
  (require 'exwm-systemtray)
  (setq exwm-systemtray-height 32) ; daviwil says explicity setting a system tray height can help prevent issues with icons not showing up.
  (setq exwm-systemtray-icon-gap 8)
  (exwm-systemtray-enable)

  ;; TODO might one or both of these fix chromium not being focused when I switch to it? What other effects might there be? Note that this doesn't seem to be problem on some other apps like gnome-terminal, perhaps there's I can set up an exwm local hook for chromium or something.
  ;; Window focus should follow the mouse pointer
  ;; (setq mouse-autoselect-window t
  ;;       focus-follows-mouse t)

  ;; These keys should always pass through to Emacs
  (setq exwm-input-prefix-keys
        '(?\C-x
          ;; ?\C-u
          ;; ?\C-h
          ?\M-x
          ?\M-`
          ?\M-&
          ?\M-:
          ;; ?\C-\M-j  ;; Buffer list
          ?\s-\ ; TODO I might want this in exwm global keys
          ?\s-, ; TODO I might want this in exwm global keys
          ))
  ;; (setq exwm-input-prefix-keys nil)

  ;; (setq exwm-input-simulation-keys
  ;;         '(([?\C-b] . [left])
  ;;           ([?\C-f] . [right])
  ;;           ([?\C-p] . [up])
  ;;           ([?\C-n] . [down])
  ;;           ([?\C-a] . [home])
  ;;           ([?\C-e] . [end])
  ;;           ([?\M-v] . [prior])
  ;;           ([?\C-v] . [next])
  ;;           ([?\C-d] . [delete])
  ;;           ([?\C-k] . [S-end delete])))
  (setq exwm-input-simulation-keys
        '(([?\s-c] . [C-c])))

  ;; TODO might want to do some local simulation keys too

  ;; TODO maybe find a way to alias localleader key to the commands in exwm-mode-map under C-c?
  ;; TODO probably use `map!' instead of `define-key'
  ;; (define-key exwm-mode-map [?\s-\M-q] 'exwm-input-send-next-key) ; TODO see if I can reverse the order of super and meta

  ;; Set up global key bindings.  These always work, no matter the input state!
  ;; Keep in mind that changing this list after EXWM initializes has no effect.
  ;; TODO maybe setq! would work though?
  (setq exwm-input-global-keys
        `(([?\s-q] . exwm-reset)

          ([?\s-Q] . exwm-input-release-keyboard)

          ;; Move between windows
          ([s-left] . windmove-left)
          ([s-right] . windmove-right)
          ([s-up] . windmove-up)
          ([s-down] . windmove-down)

          ([?\s-t] . evil-switch-to-windows-last-buffer)
          ;; ([?\s-\ ] . doom-leader-map)

          ;; Launch applications via shell command
          ([?\s-&] . (lambda (command)
                       (interactive (list (read-shell-command "$ ")))
                       (biome--shell-cmd command)))

          (,(kbd "<XF86LaunchA>") . ,(cmd! (biome--shell-cmd "dunstctl close")))
          (,(kbd "S-<XF86LaunchA>") . ,(cmd! (biome--shell-cmd "dunstctl close-all")))
          (,(kbd "C-<XF86LaunchA>") . ,(cmd! (biome--shell-cmd "dunstctl history-pop")))
          (,(kbd "M-<XF86LaunchA>") . ,(cmd! (biome--shell-cmd "dunstctl action")))))

  ;; TODO why is exwm-input-set-key used like this, daviwil uses it in his dotfiles too. The docs say to only use it interactively.
  (exwm-input-set-key (kbd "s-A") 'counsel-linux-app)

  (exwm-enable)

  ;; WIP
  (add-hook 'exwm-mode-hook #'doom-mark-buffer-as-real-h) ; FIXME If I'm keeping this remember that I have to do something special to make saving the perspective not flub. When I quit EXWM I'm seeing some persp-mode errors I think are because of this and it makes me nervous
  )
#+end_src
***** Dunst :theming:
#+begin_src conf :tangle (in-tangle-dir "dunstrc")
[global]
    geometry = "500x10-200+50"
    transparency = 10
    separator_color = frame
    padding = 15
    horizontal_padding = 15
    text_icon_padding = 15
    frame_width = 2
    frame_color = "#89AAEB"
    idle_threshold = 120
    font = Cantarell 20 # TODO Depending on how I end up doing fonts, set this to a default variable-width font that picks up my system setting or change this to my preferred font
    line_height = 2
    markup = full
    format = "<b>%s</b>\n%b"
    show_age_threshold = 60
    word_wrap = yes
    icon_position = left
    min_icon_size = 40
    max_icon_size = 40
    # icon_path = /usr/share/icons/Adwaita/96x96/status:/usr/share/icons/Adwaita/96x96/emblems # TODO should I add more paths or something?
    # TODO browser = qutebrowser
    corner_radius = 16
    mouse_right_click = do_action

[urgency_low]
    background = "#1c1f26"
    foreground = "#9ca0a4"
    timeout = 10

[urgency_normal]
    background = "#1c1f26"
    foreground = "#ffffff"
    timeout = 10

[urgency_critical]
    background = "#900000"
    foreground = "#ffffff"
    frame_color = "#ff0000"
    timeout = 0
#+end_src
**** Desktop Environment :bindings:
#+begin_src elisp
(use-package! desktop-environment
  :after exwm
  :config
  (setq desktop-environment-volume-get-command "pactl list sinks | grep '^[[:space:]]Volume:' | head -n 1 | tail -n 1 | sed -e 's,.* \([0-9][0-9]*\)%.*,\1,'"
        desktop-environment-volume-set-command "pactl set-sink-volume @DEFAULT_SINK@ %s"
        desktop-environment-volume-toggle-command "pactl set-sink-mute @DEFAULT_SINK@ toggle" ; TODO at end: if whatever I end up doing here doesn't already display an echo aread messge then do it myself
        desktop-environment-volume-normal-increment "+5%"
        desktop-environment-volume-normal-decrement "-5%"
        desktop-environment-keyboard-backlight-normal-increment 26
        desktop-environment-keyboard-backlight-normal-decrement -26)
  ;; These are set into the exwm global keymap when the mode is enabled (this can be changed) perform modifications before doing so.
  (map! :map desktop-environment-mode-map
        "s-l" nil
        "<XF86KbdBrightnessUp>" #'desktop-environment-keyboard-backlight-increment
        "<XF86KbdBrightnessDown>" #'desktop-environment-keyboard-backlight-decrement
        "<XF86LaunchB>" (lookup-key desktop-environment-mode-map (kbd "<print>"))
        "S-<XF86LaunchB>" (lookup-key desktop-environment-mode-map (kbd "S-<print>")))
  (desktop-environment-mode))
#+end_src
** emacs-temp
*** doom-emacs-temp
- TODO probably "export" the ~doom~ program to user profile
#+begin_src scheme :tangle (in-tangle-dir "doom-emacs-temp.scm")
(define-module (doom-emacs-temp)
  #:use-module ((guix packages) #:select (package))
  #:use-module ((guix build-system trivial) #:select (trivial-build-system))
  #:use-module ((guix licenses) #:prefix license:)
  #:use-module ((gnu packages base) #:select (coreutils))
  ;; #:use-module ((gnu packages emacs) #:select (emacs))
  #:use-module ((gnu packages llvm) #:select (clang))
  #:use-module ((gnu packages rust-apps) #:select (fd ripgrep))
  #:use-module ((gnu packages version-control) #:select (git)))

(define-public doom-emacs-temp
  (package
    (name "doom-emacs-temp")
    (version "0")
    (source #f)
    ;; TODO Ideally these wouldn't be propagated inputs
    (propagated-inputs
     `(;; Required
       ;; ("emacs" ,emacs) ; TODO uncomment and wrap usage(s) with `package-input-rewriting`
       ("git" ,git)
       ("ripgrep" ,ripgrep)
       ;; Optional
       ("coreutils" ,coreutils)
       ("fd" ,fd)
       ("clang" ,clang))) ; TODO I still don't know what this is for. Notably hlissner doesn't install clang, nor gcc, in his emacs "module" in his dotfiles.
      (build-system trivial-build-system)
    (arguments
    '(#:modules ((guix build utils))
      #:builder
      (begin
        (use-modules ((guix build utils) #:select (mkdir-p)))
        (mkdir-p (string-append (assoc-ref %outputs "out") "/asdf"))
        (with-output-to-file (string-append (assoc-ref %outputs "out") "/asdf/asdf.txt")
          (lambda _
            (display "asdffffffffffff")))
        #t)))
    (synopsis "An Emacs framework for the stubborn martian hacker")
    (description synopsis)
    (home-page "https://github.com/hlissner/doom-emacs")
    (license license:expat)))
#+end_src
*** emacs-desktop-environment-temp
#+begin_src scheme :tangle (in-tangle-dir "emacs-desktop-environment-temp.scm")
;; (define-module (emacs-desktop-environment-temp)
;;   #:use-module ((guix packages) #:select (package package-inputs))
;;   #:use-module ((gnu packages emacs-xyz) #:select (emacs-desktop-environment))
;;   #:use-module ((gnu packages linux) #:select (brightnessctl))
;;   #:use-module ((gnu packages music) #:select (playerctl))
;;   #:use-module ((gnu packages xdisorg) #:select (scrot)))

;; (define-public emacs-desktop-environment-temp
;;   (package (inherit emacs-desktop-environment)
;;     (inputs
;;      `(,@(package-inputs emacs-desktop-environment) ; Just in case (there aren't any inputs at the time of this writing)
;;        ("brightnessctl" ,brightnessctl)
;;        ("playerctl" ,playerctl)
;;        ("scrot" ,scrot)))
;;     (arguments
;;     '(#:phases
;;       (modify-phases %standard-phases
;;         (add-after 'unpack 'patch-executables
;;           (lambda* (#:key inputs #:allow-other-keys)
;;             (let ((cmd (lambda (input)
;;                          (string-append (assoc-ref inputs input) "/bin/" input))))
;;               (substitute* "desktop-environment.el"
;;                 (("brightnessctl") (cmd "brightnessctl"))
;;                 (("playerctl") (cmd "playerctl"))
;;                 (("scrot") (cmd "scrot"))))
;;             #t)))))))

(define-module (emacs-desktop-environment-temp)
  #:use-module ((guix packages) #:select (package))
  #:use-module ((guix build-system trivial) #:select (trivial-build-system))
  #:use-module ((gnu packages linux) #:select (brightnessctl))
  #:use-module ((gnu packages music) #:select (playerctl))
  #:use-module ((gnu packages xdisorg) #:select (scrot)))

(define-public emacs-desktop-environment-temp
  (package
    (name "emacs-desktop-environment-temp")
    (version "0")
    (source #f)
    (propagated-inputs
     `(("brightnessctl" ,brightnessctl)
       ("playerctl" ,playerctl)
       ("scrot" ,scrot)))
    (build-system trivial-build-system)
    (arguments
    '(#:modules ((guix build utils))
      #:builder
      (begin
        (use-modules ((guix build utils) #:select (mkdir-p)))
        (mkdir-p (string-append (assoc-ref %outputs "out") "/qwer"))
        (with-output-to-file (string-append (assoc-ref %outputs "out") "/qwer/qwer.txt")
          (lambda _
            (display "qwerrrrrrr")))
        #t)))
    (synopsis #f)
    (description synopsis)
    (home-page #f)
    (license #f)))
#+end_src
