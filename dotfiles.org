#+TITLE: Dotfiles
#+PROPERTY: header-args :mkdirp yes
#+PROPERTY: header-args:elisp :lexical t

* Meta
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "meta.el")
:END:
#+begin_src elisp
;;; -*- lexical-binding: t; -*-

(require 'dash)
;; FIXME
;; (require 'donnager-org)

(setq meta--base-dir ".")
#+end_src
** Path hierarchy
#+begin_src elisp
(defun meta-get-dir ()
  (concat meta--base-dir
          (when-let ((dirs (org-entry-get (point) "meta-dir" 'inherit)))
            (-> dirs (split-string " /") (string-join "/")))))

(defun meta-in-dir (sub-path)
  (concat (meta-get-dir) "/" sub-path))
#+end_src
** DB
#+begin_src elisp
(setq meta--table-refs
      '("db/schema-common"
        "db/systems-common"
        "db/feature-linux-nonfree"
        "db/feature-macbook"
        "db/systems-frostfire"
        "db/schema-whatever"
        "db/users-common"
        "db/users-system"
        "db/users-home"
        "db/palette"))

;; FIXME
;; (setq meta--database
;;       (db--load meta--table-refs))
#+end_src
** \
#+begin_src gitignore :tangle (meta-in-dir ".gitignore")
/meta.el
#+end_src
* Common
:PROPERTIES:
:meta-dir+: /ebullient
:END:
#+name: db/schema-common
| =:db/id=             | =:db/valueType=  | =:db/cardinality=    |
|----------------------+------------------+----------------------|
| :entity/channel-deps | :db.type/keyword | :db.cardinality/many |
| :system/features     | :db.type/keyword | :db.cardinality/many |
| :user/login-shell    | :db.type/keyword |                      |
| :user/sessions       | :db.type/keyword | :db.cardinality/many |

#+name: db/systems-common
| =:db/id=          | =:system/features=                              |
|-------------------+-------------------------------------------------|
| :system/frostfire | :feature/nix :feature/desktop :feature/pipewire |

#+name: db/users-common
| =:db/id=      | =:entity/channel-deps= | =:user/full-name=      | =:user/login-shell= | =:user/sessions=             |
|---------------+------------------------+------------------------+---------------------+------------------------------|
| :user/primary | :channel/nonguix       | Krzysztof Baranowski   | :shell/default      | :session/gnome :session/sway |
| :user/aux     | :channel/nonguix       | Phil Coulson           | :shell/default      | :session/gnome :session/sway |
| :user/guest   | :channel/nonguix       | Speak Friend and Enter | :shell/default      | :session/gnome               |

#+begin_src scheme :tangle (meta-in-dir "common.scm")
(define-module (ebullient common))

(define-public default-login-shell #:shell/bash)
#+end_src
** Channels
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "channels.scm")
:END:
#+begin_src scheme
(define-module (ebullient channels)
  #:use-module (guix channels)
  #:use-module ((srfi srfi-1) #:select (remove))
  #:export (get-channels
            guix
            nonguix))

(define* (get-channels #:rest cs)
  (append
   cs
   (remove (lambda (c)
             (member (channel-name c)
                     (map channel-name cs)))
           %default-channels)))
#+end_src
*** Definitions
#+begin_src scheme
(define guix %default-guix-channel)

(define nonguix
  (channel
   (name 'nonguix)
   (url "https://gitlab.com/nonguix/nonguix")
   (introduction
    (make-channel-introduction
     "897c1a470da759236cc11798f4e0a5f7d4d59fbc"
     (openpgp-fingerprint
      "2A39 3FFF 68F4 EF7A 3D29  12AF 6F51 20A0 22FB B2D5")))))

(define channel-map
  (kvm #:channel/guix guix
       #:channel/nonguix nonguix))
#+end_src
** \
#+begin_src sh :var name="" dir=""
guix time-machine \
	--load-path=. \
	--channels="$dir"/$name-channels \
	-- \
	describe --format=channels > "$dir"/$name-channels-lock
#+end_src

#+begin_src gitignore :tangle (meta-in-dir ".gitignore")
*
#+end_src
* Installation
** Create bootable USB
Download (or create) a Guix installation ISO
- I'm using the [[https://github.com/SystemCrafters/guix-installer/releases/latest][System Crafters Guix Installer]] since it's kept up-to-date which should speed things up a bit.
- Run ~lsblk~ to find the usb device.
#+begin_src sh
iso_file=guix-system-install-1.3.0.x86_64-linux.iso
usb_device=/dev/sdc
dd if=$iso_file of=$usb_device status=progress bs=4M
sync
#+end_src
** Install
Boot from the installation medium, select your language and country, and select "Install using the shell based process" when prompted.
*** Keyboard layout
This messed up the keyboard when I tried it on mac, not doing ~loadkeys~ at all was fine.
#+begin_src sh
# keysfile=mac-us
# loadkeys $keysfile
#+end_src
*** Networking
#+begin_src sh
# List network interfaces and find one to use.
ifconfig -a

# Is this necessary if the interface is already activated?
interface=usb0
ifconfig $interface up

dhclient -v $interface

# Test that networking is up and working.
ping -c 3 gnu.org
#+end_src
*** Partitioning
#+begin_src sh
# Check out the current block devices and partitions if you want.
lsblk

device=/dev/sda

# Make two partitions, partition types should be "EFI system partition" and "Linux x86-64 root (/)". For EFI I'm gonna do 1GB to be on the safe side, second should be remainder of free space.
cfdisk $device
parted $device set 1 esp on

efi_system_partition="$device"1
efi_label=genesis

mkfs.fat -F32 -n $efi_label $efi_system_partition

root_partition="$device"2
root_label=firmament
crypt_name=ciphered
crypt_mapping=/dev/mapper/$crypt_name

cryptsetup luksFormat $root_partition
cryptsetup open --type luks $root_partition $crypt_name

mkfs.btrfs -L $root_label $crypt_mapping
#+end_src
*** Set up subvolumes
#+begin_src sh
# I don't know if the type argument is necessary but that's how Andrew Tropin had it.
mount -t btrfs LABEL=$root_label /mnt

btrfs subvolume create /mnt/root
btrfs subvolume create /mnt/boot
btrfs subvolume create /mnt/guix-store
btrfs subvolume create /mnt/guix-var
btrfs subvolume create /mnt/log
btrfs subvolume create /mnt/home
btrfs subvolume create /mnt/persist
btrfs subvolume create /mnt/nix

# Take an empty readonly snapshot of the root subvolume (might be useful later for rolling back or comparison)
btrfs subvolume snapshot -r /mnt/root /mnt/root-blank

umount /mnt
#+end_src
*** Mount
NB: ~$crypt_mapping~ can/"should" be ~LABEL=$root_label~
#+begin_src sh
mount -o subvol=root,compress=zstd,autodefrag $crypt_mapping /mnt

mkdir /mnt/boot
mount -o subvol=boot,compress=zstd,autodefrag $crypt_mapping /mnt/boot
mkdir -p /mnt/gnu/store
mount -o subvol=guix-store,compress=zstd,autodefrag,noatime $crypt_mapping /mnt/gnu/store
mkdir -p /mnt/var/guix
mount -o subvol=guix-var,compress=zstd,autodefrag $crypt_mapping /mnt/var/guix
mkdir -p /mnt/var/log
mount -o subvol=log,compress=zstd,autodefrag $crypt_mapping /mnt/var/log
mkdir /mnt/home
mount -o subvol=home,compress=zstd,autodefrag $crypt_mapping /mnt/home
mkdir /mnt/.persist
mount -o subvol=persist,compress=zstd,autodefrag $crypt_mapping /mnt/.persist

mkdir -p /mnt/boot/efi
mount LABEL=$efi_label /mnt/boot/efi
#+end_src
*** Proceeding with installation
#+begin_src sh
herd start cow-store /mnt
#+end_src
*** System configuration
#+begin_src sh
# Grab my dotfiles, from github if I put them up at some point or maybe from a USB or another computer with `woof`, into the current directory (the one I'm already in, not `/mnt`).
# git clone https://github.com/pharcosyle/dotfiles
# guix environment --ad-hoc woof -- woof -U
# Important: `woof` didn't work for me over the local network, I had to have my other computer offer it over the public internet with localtunnel.

mkdir -p ~/.config/guix
cp ~/projects/dotfiles/ebullient/home/channels.scm ~/.config/guix
guix pull
hash guix

# Find the LUKS UUID to update it in the system config. Make sure to update in the dotfiles upstream later.
cryptsetup luksUUID $root_partition

cd ~/projects/dotfiles/ebullient
guix system --load-path=. init system/frostfire.scm /mnt
#+end_src
*** Post-installation
#+begin_src sh
# Reboot the system, take out the installation medium, and login as root when faced with a login prompt.

# Set the password for the root account.
passwd
# Set the password for my user.
my_user=pharcosyle
passwd $my_user

# Log out and log in to my user account.

# Grab my dotfiles again.

# Ensure my channels file is in `~/.config/guix` and update my channels.
guix pull

# Run a system reconfigure, home reconfigure, install manifests, and deploy `home-state.git`. Copy over all my old data.
#+end_src
* System
:PROPERTIES:
:meta-dir+: /ebullient/system
:END:
#+name: db/schema-whatever
| =:db/id=     | =:db/valueType=  |
|--------------+------------------|
| :user/admin? | :db.type/boolean |

#+name: db/users-system
| =:db/id=      | =:user/username= | =:user/admin?= | =:user/password= |
|---------------+------------------+----------------+------------------|
| :user/primary | pharcosyle       | true           |                  |
| :user/aux     | pcoulson         | true           |                  |
| :user/guest   | gandalf          |                | mellon           |

** Channels
#+begin_src scheme :tangle (meta-in-dir "channels.scm")
(define-module (ebullient system channels)
  #:use-module ((donnager client) #:prefix d:)
  #:use-module (ebullient channels)
  #:use-module (ebullient utils)
  #:export (get-system-channels
            system-channel-deps))

(define (get-system-channels cs)
  (apply get-channels cs))

(define (system-channel-deps system)
  (as-> system $
        (d:q $ '(#:system/features #:entity/channel-deps))
        (map (partial get system-channel-map) $)))

(define system-channel-map channel-map)
#+end_src
** Components
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "components.scm")
:END:
#+begin_src scheme
(define-module (ebullient system components)
  #:use-module ((guix modules) #:select (source-module-closure))
  #:use-module (guix gexp)
  #:use-module ((guix store) #:select (%default-substitute-urls))
  #:use-module (gnu bootloader)
  #:use-module (gnu bootloader grub)
  ;; #:use-module ((gnu packages bash) #:select (bash))
  #:use-module ((gnu packages certs) #:select (nss-certs))
  #:use-module ((gnu packages fonts) #:select (font-terminus))
  #:use-module ((gnu packages gnupg) #:select (guile-gcrypt))
  #:use-module ((gnu packages linux) #:select (brightnessctl pipewire-0.3))
  ;; #:use-module ((gnu packages shells) #:select (zsh))
  #:use-module ((gnu packages wm) #:select (sway swaylock))
  #:use-module (gnu services)
  #:use-module (gnu services base)
  #:use-module (gnu services desktop)
  #:use-module (gnu services nix)
  #:use-module (gnu services sound)
  #:use-module (gnu services xorg)
  #:use-module (gnu system)
  #:use-module (gnu system accounts)
  #:use-module (gnu system file-systems)
  #:use-module (gnu system keyboard)
  #:use-module (gnu system mapped-devices)
  #:use-module ((nongnu packages linux) #:select (linux linux-firmware broadcom-sta broadcom-bt-firmware))
  #:use-module ((nongnu system linux-initrd) #:select (microcode-initrd))
  #:use-module ((ice-9 match) #:select (match-lambda))
  #:use-module ((ice-9 rdelim) #:select (read-string))
  #:use-module ((srfi srfi-1) #:select (any remove iota))
  #:use-module (ebullient common)
  #:use-module (ebullient utils)
  #:export (barebones-os
            host-info
            grub-efi
            base-services+packages
            linux-nonfree
            disk-encryption
            stateless
            btrfs
            users
            nonguix-substitutes
            nix
            console-keyboard-layouts
            hidpi-console-font
            desktop-services
            gdm
            gnome-desktop
            wm
            sway-wm
            macbook-wireless
            macbook-kbl))
#+end_src
#+begin_src scheme
(define-syntax-rule (system-comp os field ...)
  (operating-system
    (inherit os)
    field ...))

(define-syntax define-system-comp
  (lambda (x)
    (syntax-case x ()
      ((_ (name arg ...) field ...)
       (with-syntax ((os (datum->syntax x 'os)))
         #'(define* (name os arg ...)
             (system-comp os field ...)))))))
#+end_src
*** Barebones OS
#+begin_src scheme
(define barebones-os
  (operating-system
    (host-name #f)
    (timezone #f)
    (bootloader #f)
    (services '())
    (file-systems %base-file-systems)))
#+end_src
*** Host info
#+begin_src scheme
(define-system-comp (host-info #:key host-name timezone locale)
  (host-name host-name)
  (timezone timezone)
  (locale locale))
#+end_src
*** Boot
**** Grub
...
**** Grub EFI
#+begin_src scheme
(define-system-comp (grub-efi #:key label target)
  (bootloader (bootloader-configuration
               (bootloader grub-efi-bootloader)
               (targets (list target))
               (timeout 1)))
  (file-systems
   (cons* (file-system
            (device (file-system-label label))
            (mount-point target)
            (type "vfat"))
          (operating-system-file-systems os))))
#+end_src
*** Base services and packages
#+begin_src scheme
(define-system-comp (base-services+packages)
  (packages
   (cons* nss-certs
          (operating-system-packages os)))
  (services
   (append %base-services
           (operating-system-user-services os))))
#+end_src
*** Linux nonfree
#+name: db/feature-linux-nonfree
| =:db/id=               | =:entity/channel-deps= |
|------------------------+------------------------|
| :feature/linux-nonfree | :channel/nonguix       |

#+begin_src scheme
(define-system-comp (linux-nonfree)
  (kernel linux)
  (initrd microcode-initrd)
  (firmware (cons* linux-firmware
                   (operating-system-firmware os))))
#+end_src
*** Disk encryption
#+begin_src scheme
(define* (disk-encryption os #:key source-uuid target encrypted-mount-points)
  (let ((encrypted-device (mapped-device
                           (source (uuid source-uuid))
                           (targets (list target))
                           (type luks-device-mapping))))
    (system-comp
     os
     (mapped-devices
      (cons* encrypted-device
             (operating-system-mapped-devices os)))
     (file-systems
      (map (lambda (fs)
             (if (member (file-system-mount-point fs) encrypted-mount-points)
                 (file-system
                   (inherit fs)
                   (dependencies (cons* encrypted-device
                                        (file-system-dependencies fs))))
                 fs))
           (operating-system-file-systems os))))))
#+end_src
*** Stateless
The stateless service should come after base/desktop services (potentially others as well) so its state gets installed before theirs during activation. To this end the ~stateless-service-type~ is appended, not prepended, to operating system services. It also modifies file systems so users of this component should include it at the end of their component chain.
#+begin_src scheme
(define-system-comp (stateless #:key persist-dir bluetooth?)
  (initrd (lambda (file-systems . rest)
            (apply (operating-system-initrd os) file-systems
                   #:volatile-root? #t
                   rest)))
  (file-systems
   (map (lambda (fs)
          (if (member (file-system-mount-point fs)
                      `("/var/guix"
                        "/var/log"
                        ,persist-dir))
              (file-system
                (inherit fs)
                (needed-for-boot? #t))
              fs))
        (operating-system-file-systems os)))
  (services
   (append
    (operating-system-user-services os)
    (list
     (service stateless-service-type
              `(#:persist-dir ,persist-dir
                #:paths ,(append
                          '("/etc/machine-id"
                            "/var/lib/random-seed"
                            "/etc/NetworkManager/system-connections"
                            "/var/lib/NetworkManager/secret_key"
                            "/etc/guix/signing-key.pub"
                            "/etc/guix/signing-key.sec")
                          (if bluetooth?
                              (list "/var/lib/bluetooth") '()))))))))
#+end_src
**** Service
#+begin_src scheme
(define save-or-restore-users+groups
  #~(lambda (persist-dir save-or-restore)
      (for-each (lambda (path)
                  (let ((files (list path (string-append persist-dir path))))
                    (apply copy-file (case save-or-restore
                                       ((#:restore) (reverse files))
                                       ((#:save) files)))))
                '("/etc/group"
                  "/etc/passwd"
                  "/etc/shadow"))))

(define (populate-gexp config)
  (with-extensions (list guile-gcrypt)
    (with-imported-modules (source-module-closure
                            '((gnu build install)))
      #~(begin
          (use-modules ((gnu build install) #:select (populate-root-file-system)))

          (define* (populate #:key persist-dir #:allow-other-keys)
            (let* ((system-path "/var/guix/profiles/system")
                   (system-1-path "/var/guix/profiles/system-1-link")
                   (system-1-exists? (file-exists? system-1-path))
                   (system-link (readlink system-path))
                   (system-1-link (if system-1-exists?
                                      (readlink system-1-path)
                                      system-link)))
              (populate-root-file-system system-1-link ""
                                         #:extras `((,system-path -> ,system-link)))
              (unless system-1-exists?
                (delete-file system-1-path)))
            (#$save-or-restore-users+groups persist-dir #:restore))

          (apply populate '#$config)))))

(define (activate-state-gexp config)
  #~(begin
      (use-modules ((ice-9 match) #:select (match)))

      (define* (activate-state #:key persist-dir paths)

        (define (install path)
          (let loop ((components (string-tokenize path (char-set-complement (char-set #\/))))
                     (base persist-dir)
                     (target-base ""))
            (match components
              ((head tail ...)
               (let* ((path (string-append base "/" head))
                      (target-path (string-append target-base "/" head)))
                 (if (null? tail)
                     ;; The Guix code makes a point of doing stuff like this atomically. I don't really know why but I will too.
                     (let ((pivot (string-append target-path ".new")))
                       (symlink path pivot)
                       (rename-file pivot target-path))
                     (begin
                       (catch 'system-error
                         (lambda ()
                           (mkdir target-path))
                         (lambda args
                           (unless (= EEXIST (system-error-errno args))
                             (apply throw args))))
                       (let ((st (lstat path)))
                         (chown target-path (stat:uid st) (stat:gid st))
                         (chmod target-path (stat:perms st)))
                       (loop tail path target-path))))))))

        (for-each install paths)
        (#$save-or-restore-users+groups persist-dir #:save))

      (apply activate-state '#$config)))

(define stateless-service-type
  (service-type
   (name 'stateless)
   (extensions
    (list (service-extension boot-service-type
                             populate-gexp)
          (service-extension activation-service-type
                             activate-state-gexp)))))
#+end_src
*** File systems
**** Ext4
...
**** Btrfs
#+begin_src scheme
(define-system-comp (btrfs #:key label subvols)
  (file-systems
   (append
    (map (match-lambda
           ((subvol mount-point)
            (file-system
              (device (file-system-label label))
              (mount-point mount-point)
              (type "btrfs")
              (options (string-append "subvol=" subvol ",compress=zstd,autodefrag")))))
         subvols)
    (operating-system-file-systems os))))
#+end_src
*** Users
#+begin_src scheme
(define* (account #:key name comment shell admin? password salt bluetooth?)
  (user-account
   (name name)
   (comment (or comment ""))
   (group "users")
   (supplementary-groups (append '("netdev" "audio" "video")
                                 (if admin? '("wheel") '())
                                 (if bluetooth? '("lp") '())))
   (shell (if (eq? shell default-login-shell)
              (default-shell)
              ;; (case shell
              ;;   ((#:shell/bash) (file-append bash "/bin/bash"))
              ;;   ((#:shell/zsh) (file-append zsh "/bin/zsh")))
              ))
   (password (if password
                 (crypt password salt)
                 #f))))

(define-system-comp (users #:key who bluetooth?)
  (users
   (append (map (lambda (user)
                  (apply account (-> user
                                     (massoc user #:bluetooth? bluetooth?)
                                     keyvals)))
                who)
           (operating-system-users os))))
#+end_src
*** Nonguix substitutes
#+begin_src scheme
(define-system-comp (nonguix-substitutes)
  (services
   (update-services
    (operating-system-user-services os)
    guix-service-type
    (lambda (config)
      (guix-configuration
       (inherit config)
       (substitute-urls
        (append (guix-configuration-substitute-urls config)
                (list "https://substitutes.nonguix.org")))
       (authorized-keys
        (append (guix-configuration-authorized-keys config)
                (list (local-file "substitutes.nonguix.org.pub")))))))))
#+end_src
**** Signing key
#+begin_src scheme :tangle (meta-in-dir "substitutes.nonguix.org.pub")
(public-key
 (ecc
  (curve Ed25519)
  (q #C1FD53E5D4CE971933EC50C9F307AE2171A2D3B52C804642A7A35F84F3A4EA98#)))
#+end_src
*** Nix
#+begin_src scheme
(define-system-comp (nix)
  (services
   (cons* (service nix-service-type)
          (operating-system-user-services os))))
#+end_src
*** Console
**** Console keyboard layouts
#+begin_src scheme
(define-system-comp (console-keyboard-layouts #:key keyboard-layout)
  (keyboard-layout keyboard-layout)
  (bootloader (bootloader-configuration
               (inherit (operating-system-bootloader os))
               (keyboard-layout keyboard-layout))))
#+end_src
**** HiDPI console font
#+begin_src scheme
(define-system-comp (hidpi-console-font)
  (services
   (update-services
    (operating-system-user-services os)
    console-font-service-type
    (lambda (config)
      (map (lambda (tty-and-font)
             (cons (car tty-and-font)
                   (file-append font-terminus "/share/consolefonts/ter-132n")))
           config)))))
#+end_src
*** Desktop
**** Desktop services
#+begin_src scheme
(define-system-comp (desktop-services #:key pipewire? bluetooth?)
  (services
   (as-> (operating-system-user-services os) $
     (append selective-desktop-services $)
     (if pipewire?
         (with-pipewire $) $)
     ;; (if bluetooth?
     ;;     (cons* (bluetooth-service #:auto-enable? #t) $))
     )))
#+end_src
***** Pipewire
#+begin_src scheme
(define (with-pipewire services)
  (as-> services $
    (remove-services $ (list pulseaudio-service-type
                             alsa-service-type))
    (cons* (udev-rules-service 'pipewire-add-udev-rules
                               pipewire-0.3)
           $)))
#+end_src
***** \
#+begin_src scheme
(define (remove-services services kinds)
  (remove (lambda (s)
            (member (service-kind s) kinds))
          services))

(define selective-desktop-services
  (remove-services %desktop-services
                   (append (map service-kind %base-services)
                           (list gdm-service-type
                                 screen-locker-service-type))))
#+end_src
**** Display managers
***** GDM
#+begin_src scheme
(define-system-comp (gdm #:key wayland? auto-login)
  (services
   (cons* (service gdm-service-type
                   (gdm-configuration
                    (auto-login? (if auto-login #t #f))
                    (default-user auto-login)
                    (wayland? wayland?)))
          (operating-system-user-services os))))
#+end_src
**** Desktop environments
***** Gnome
#+begin_src scheme
(define-system-comp (gnome-desktop)
  (services
   (cons* (service gnome-desktop-service-type)
          (operating-system-user-services os))))
#+end_src
**** Window managers
#+begin_src scheme
(define-system-comp (wm #:key package services)
  (packages
   (cons* package
          (operating-system-packages os)))
  (services
   (append services
           (operating-system-user-services os))))
#+end_src
***** Sway
#+begin_src scheme
(define* (sway-wm os #:key laptop?)
  (wm os
      #:package sway
      #:services (cons* swaylock-service
                        (if laptop?
                            (list brightnessctl-udev-rules) '()))))
#+end_src
**** Screen lockers
***** Swaylock
#+begin_src scheme
(define swaylock-service
  (screen-locker-service swaylock))
#+end_src
**** Backlight
***** Brightnessctl
#+begin_src scheme
(define brightnessctl-udev-rules
  (udev-rules-service 'brightnessctl-add-udev-rules brightnessctl))
#+end_src
*** Macbook
**** Wireless
I'm not sure if this requires the nonfree linux kernel and/or if the blacklist refers to kernel modules not present in linux-libre.

#+name: db/feature-macbook
| =:db/id=         | =:entity/channel-deps= |
|------------------+------------------------|
| :feature/macbook | :channel/nonguix       |

#+begin_src scheme
(define-system-comp (macbook-wireless #:key bluetooth?)
  (kernel-arguments (with-blacklist (operating-system-user-kernel-arguments os)
                                    "b43,b43legacy,ssb,bcm43xx,brcm80211,brcmfmac,brcmsmac,bcma"))
  (kernel-loadable-modules (cons* broadcom-sta
                                  (operating-system-kernel-loadable-modules os)))
  (firmware (append
             (if bluetooth? (list broadcom-bt-firmware) '())
             (operating-system-firmware os))))

(define (with-blacklist kernel-args new)

  (define blacklist-param "modprobe.blacklist")
  (define (blacklist? ka)
    (string-prefix? blacklist-param ka))

  (if (any blacklist? kernel-args)
      (update-list kernel-args blacklist? (lambda (blacklist)
                                            (string-append blacklist "," new)))
      (cons* (string-append blacklist-param "=" new) kernel-args)))
#+end_src
**** Keyboard layout
#+begin_src scheme
(define macbook-kbl
  (keyboard-layout "us" #:model "macbook78"))
#+end_src
** Base OS
#+begin_src scheme :tangle (meta-in-dir "base-os.scm")
(define-module (ebullient system base-os)
  #:use-module ((donnager client) #:prefix d:)
  #:use-module (ebullient system components)
  #:use-module (ebullient common)
  #:use-module (ebullient utils)
  #:export (base-os))

(define* (base-os #:key
                  system
                  host-name
                  accounts
                  luks-uuid
                  auto-login-account
                  kbl
                  console?
                  laptop?
                  bluetooth?)
  (let* ((feature?
          (let ((features (get (d:pull '(#:system/features) system) #:system/features)))
            (lambda (feat)
              (member feat features))))
         (linux-nonfree? (feature? #:feature/linux-nonfree))
         (disk-encryption? (feature? #:feature/disk-encryption))
         (stateless? (feature? #:feature/stateless))
         (nix? (feature? #:feature/nix))
         (desktop? (feature? #:feature/desktop))
         (laptop? (and desktop? laptop?))
         (macbook? (and laptop? (feature? #:feature/macbook)))
         (pipewire? (and desktop? (feature? #:feature/pipewire)))
         (bluetooth? (and desktop? bluetooth?))
         (kbl (or kbl
                  (if macbook?
                      macbook-kbl #f)))
         (auto-login (if disk-encryption?
                         (get (d:pull '(#:user/username) auto-login-account) #:user/username) #f))
         (who
          (->> accounts
               (apply d:pull-many '(*))
               (map (lambda (user)
                      (merge
                       (kvm #:name (get user #:user/username)
                            #:comment (get user #:user/full-name)
                            #:shell (let ((shell (get user #:user/login-shell)))
                                      (if (equal shell #:shell/default)
                                          default-login-shell shell))
                            #:admin? (get user #:user/admin?))
                       (let ((admin? (get user #:user/admin?))
                             (password (get user #:user/password)))
                         (if (and password (not admin?))
                             (kvm #:password password
                                  #:salt "toosimple")
                             (kvm))))))))
         (nonguix-substitutes?
          (let ((channel-deps (append
                               (d:q $ '(#:system/features #:entity/channel-deps) system)
                               (d:q-many $ '(#:entity/channel-deps) accounts))))
            (member #:channel/nonguix channel-deps)))
         (session?
          (let ((sessions
                 (->> accounts
                      (map (rpartial get #:user/sessions) (d:pull-many '(#:user/sessions)))
                      (apply append))))
            (lambda (s)
              (member s sessions))))
         gnome? (session? #:session/gnome)
         sway? (session? #:session/sway))
    (-> barebones-os
        (host-info #:host-name host-name
                   #:timezone "America/Los_Angeles"
                   #:locale "en_US.utf8")
        (grub-efi #:label "genesis"
                  #:target "/boot/efi")
        base-services+packages
        (users #:who who
               #:bluetooth? bluetooth?)
        (as-> $
          (if nonguix-substitutes?
              (nonguix-substitutes $) $)
          (if linux-nonfree?
              (linux-nonfree $) $)
          (if nix?
              (nix $) $)
          (if console?
              (-> $
                  (console-keyboard-layouts #:keyboard-layout kbl)
                  hidpi-console-font)
              $)
          (if desktop?
              (-> $
                  (desktop-services #:pipewire? pipewire?
                                    #:bluetooth? bluetooth?)
                  (gdm #:wayland? #t
                       #:auto-login auto-login)
                  (as-> $
                    (if gnome?
                        (gnome-desktop $) $)
                    (if sway?
                        (sway-wm $ #:laptop? laptop?) $)))
              $)
          (if macbook?
              (macbook-wireless $ #:bluetooth? bluetooth?) $)
          (let* ((persist-dir "/.persist")
                 (subvols
                  (append
                   `(("root-blank" "/")
                     ("boot" "/boot")
                     ("guix-store" "/gnu/store")
                     ("guix-var" "/var/guix")
                     ("log" "/var/log")
                     ("home" "/home")
                     ("persist" ,persist-dir))
                   (if nix? '(("nix" "/nix")) '()))))
            (-> $
                (btrfs #:label "firmament"
                       #:subvols subvols)
                (as-> $
                  (if disk-encryption?
                      (disk-encryption $ #:source-uuid luks-uuid
                                       #:target "ciphered"
                                       #:encrypted-mount-points (map cadr subvols))
                      $))
                (as-> $
                  (if stateless?
                      (stateless #:persist-dir persist-dir
                                 #:bluetooth? bluetooth?)
                      $))))))))
#+end_src
** Operating Systems
:PROPERTIES:
:meta-dir+: /os
:END:
*** Frostfire
#+name: db/systems-frostfire
| =:db/id=          | =:system/features=                                                                  |
|-------------------+-------------------------------------------------------------------------------------|
| :system/frostfire | :feature/linux-nonfree :feature/disk-encryption :feature/stateless :feature/macbook |

#+begin_src scheme :tangle (meta-in-dir "frostfire.scm") :noweb yes
(define-module (ebullient system os frostfire)
  #:use-module (ebullient system base-os))

(define-public os
  (base-os #:system #:system/frostfire
           #:host-name "frostfire"
           #:accounts '(#:user/primary
                        #:user/aux
                        #:user/guest)
           #:luks-uuid "<<frostfire-luks-uuid>>"
           ;; #:auto-login-account #:user/primary ; REVIEW Enable this later.
           #:console? #t
           #:laptop? #t
           #:bluetooth? #t))
#+end_src
**** Channel deps
#+begin_src scheme :tangle (meta-in-dir "frostfire-channels")
(use-modules (ebullient system channels))

(get-system-channels
 (system-channel-deps #:system/frostfire))
#+end_src
**** Channels lock :version:
#+begin_src scheme :tangle (meta-in-dir "frostfire-channels-lock")
(list (channel
        (name 'guix)
        (url "https://git.savannah.gnu.org/git/guix.git")
        (branch "master")
        (commit
          "85f026f36ae93ac3ce3fa50150848eab9b31b69f")
        (introduction
          (make-channel-introduction
            "9edb3f66fd807b096b48283debdcddccfea34bad"
            (openpgp-fingerprint
              "BBB0 2DDF 2CEA F6A8 0D1D  E643 A2A0 6DF2 A33A 54FA"))))
      (channel
        (name 'nonguix)
        (url "https://gitlab.com/nonguix/nonguix")
        (branch "master")
        (commit
          "35533c763a81365e14d0b58ad262e8f88c82872c")
        (introduction
          (make-channel-introduction
            "897c1a470da759236cc11798f4e0a5f7d4d59fbc"
            (openpgp-fingerprint
              "2A39 3FFF 68F4 EF7A 3D29  12AF 6F51 20A0 22FB B2D5")))))
#+end_src
**** LUKS UUID :external_state:
#+name: frostfire-luks-uuid
#+begin_src org
bdda56af-6ca0-4953-bc13-d5af8715e0e5
#+end_src
** \
#+begin_src sh :var os_name="" os_dir=(meta-get-dir)
sudo guix time-machine \
	--channels="$os_dir"/$os_name-channels-lock \
	-- \
	system \
	--load-path=. \
	--expression="(@ (ebullient system os $os_name) os)" \
	reconfigure
#+end_src
* Home
:PROPERTIES:
:meta-dir+: /ebullient/home
:END:
#+name: db/users-home
| =:db/id=      | =:entity/channel-deps= | =:user/email=            |
|---------------+------------------------+--------------------------|
| :user/primary | :channel/flat          | pharcosyle@gmail.com     |
| :user/aux     | :channel/flat          | pharcosyle+aux@gmail.com |

#+name: db/palette
| =:db/id=                 | =:color/hex= |
|--------------------------+--------------|
| :color/fg                | #dee2f8      |
| :color/highlight         | #8496ff      |
| :color/comments          | #63677f      |
| :color/comment-delimiter | #939abd      |
| :color/red               | #fb8578      |
| :color/orange            | #fdce5f      |
| :color/green             | #9fed9c      |
| :color/yellow            | #eddc91      |
| :color/blue              | #7db9fe      |
| :color/dark-blue         | #5f68de      |
| :color/magenta           | #e29bf7      |
| :color/violet            | #aeb9f3      |
| :color/cyan              | #75e0f9      |
| :color/gold              | #fdd94a      |
| :color/pink              | #ff9999      |

- FIXME remove this
#+name: palette
| Name              | Color   |
|-------------------+---------|
| fg                | #dee2f8 |
| highlight         | #8496ff |
| comments          | #63677f |
| comment-delimiter | #939abd |
| red               | #fb8578 |
| orange            | #fdce5f |
| green             | #9fed9c |
| yellow            | #eddc91 |
| blue              | #7db9fe |
| dark-blue         | #5f68de |
| magenta           | #e29bf7 |
| violet            | #aeb9f3 |
| cyan              | #75e0f9 |
| gold              | #fdd94a |
| pink              | #ff9999 |

#+name: guix-home-profile
#+begin_src sh
~/.guix-home/profile
#+end_src
#+name: guix-extra-profiles-path
#+begin_src sh
~/.guix-extra-profiles
#+end_src
** Channels
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "channels.scm")
:END:
#+begin_src scheme
(define-module (ebullient home channels)
  #:use-module (guix channels)
  #:use-module ((donnager client) #:prefix d:)
  #:use-module (ebullient channels)
  #:use-module (ebullient utils)
  #:export (get-home-channels
            user-channel-deps
            rde
            flat)
  #:re-export (guix
               nonguix))

(define (get-home-channels cs)
  (apply get-channels (if (member rde cs)
                          cs (cons rde cs))))

(define (user-channel-deps user)
  (as-> user $
        (get (d:pull '(#:entity/channel-deps) $) #:entity/channel-deps)
        (map (partial get home-channel-map) $)))
#+end_src
*** Definitions
#+begin_src scheme
(define rde
  (channel
   (name 'rde)
   (url "https://git.sr.ht/~abcdw/rde")
   (introduction
    (make-channel-introduction
     "257cebd587b66e4d865b3537a9a88cccd7107c95"
     (openpgp-fingerprint
      "2841 9AC6 5038 7440 C7E9  2FFA 2208 D209 58C1 DEB0")))))

(define flat
  (channel
   (name 'flat)
   (url "https://github.com/flatwhatson/guix-channel.git")
   (introduction
    (make-channel-introduction
     "33f86a4b48205c0dc19d7c036c85393f0766f806"
     (openpgp-fingerprint
      "736A C00E 1254 378B A982  7AF6 9DBE 8265 81B6 4490")))))
#+end_src
*** \
#+begin_src scheme
(define home-channel-map
  (merge channel-map
         (kvm #:channel/rde rde
              #:channel/flat flat)))
#+end_src
** Components
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "components.scm")
:END:
#+begin_src scheme
(define-module (ebullient home components)
  #:use-module (guix gexp)
  #:use-module (gnu home services)
  #:use-module (gnu home services mcron)
  #:use-module (gnu home services shells)
  #:use-module (gnu home services shepherd)
  #:use-module (gnu home services xdg)
  #:use-module (gnu home-services ssh)
  #:use-module (gnu home-services version-control)
  ;; #:use-module ((gnu packages bash) #:select (bash))
  #:use-module ((gnu packages fonts) #:select (font-fira-code))
  #:use-module ((gnu packages freedesktop) #:select (udiskie xdg-desktop-portal xdg-desktop-portal-wlr))
  #:use-module ((gnu packages gnome) #:select (network-manager-applet))
  #:use-module ((gnu packages linux) #:select (pipewire-0.3 wireplumber))
  #:use-module ((gnu packages package-management) #:select (flatpak))
  #:use-module ((gnu packages shells) #:select (zsh))
  #:use-module ((gnu packages shellutils) #:select (direnv))
  #:use-module ((gnu packages xdisorg) #:select (gammastep))
  #:use-module (gnu services)
  #:use-module (gnu services shepherd)
  #:use-module ((srfi srfi-1) #:select (append-map))
  #:use-module ((ebullient home doom-emacs) #:select (doom-emacs))
  #:use-module ((ebullient home emacs) #:select (emacs-29-pgtk+native-comp))
  #:use-module (ebullient utils)
  #:export (he-shells
            he-extra-profiles
            he-nix
            he-emacs
            he-doom
            he-direnv
            he-pipewire
            he-flatpak
            he-sway
            gammastep-service-type
            network-manager-service-type
            udiskie-service-type))
#+end_src
*** Shells
#+begin_src scheme
(define* (he-shells svcs #:key login-shell interactive-shell)
  (append
   (cons*
    (service (login-shell-service-type login-shell))
    (filter
     service?
     (let ((setup-shell? (lambda (shell)
                           (memq shell (list login-shell interactive shell)))))
       (list
        (when (setup-shell? #:shell/bash)
          (service home-bash-service-type
                   ;; (home-bash-configuration
                   ;;  (bash-profile
                   ;;   (list (local-file "bashrc"))))
                   ))
        (when (setup-shell? #:shell/zsh)
          (service home-zsh-service-type
                   (home-zsh-configuration
                    (zshrc
                     (list (local-file "zshrc"))))))
        (when-not (eq login-shell interactive-shell)
          (simple-service
           'set-shell
           home-environment-variables-service-type
           `(("SHELL" . ,(case interactive-shell
                           ;; ((#:shell/bash) (file-append bash "/bin/bash"))
                           ((#:shell/zsh) (file-append zsh "/bin/zsh")))))))))))
   svcs))
#+end_src
**** Login shell service
#+begin_src scheme
(define (he-login-shell-service-type shell)
  (service-type
   (name 'he-login-shell)
   (extensions
    (service-extension
     (case shell
       ((#:shell/bash) home-bash-service-type)
       ;; ((#:shell/zsh) home-zsh-service-type)
       )
     identity))
   (compose identity)
   (extend
    (lambda (initial extensions)
      (let* ((config (cons* initial extensions))
             (field (lambda (k)
                      (append-map (rpartial k) config))))
        (case shell
          ((#:shell/bash)
           (home-bash-extension
            (environment-variables (field #:environment-variables))
            (bash-profile (field #:profile))))
          ;; ((#:shell/zsh)
          ;;  (home-zsh-extension
          ;;   (environment-variables (field #:environment-variables))
          ;;   (zprofile (field #:profile))))
          ))))
   (default-value (kvm))))
#+end_src
**** Bash
***** Bashrc
...
**** Zsh
***** Zshrc
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "zshrc")
:END:
****** Andrew Tropin's zshrc
- TODO trying out Andrew Tropin's zsh configuration verbatim for now
#+begin_src sh
# Prevent freezing output on ^s, needed for various isearches
hash stty 2> /dev/null && stty -ixon

# Completions and other stuff
autoload -U compinit
compinit -d ${XDG_CACHE_HOME:-$HOME/.cache}/.zcompdump

# Enable bash completion, requires to source them from somewhere
# autoload -U bashcompinit && bashcompinit

zstyle ':completion:*' menu select
zstyle ':completion:*' insert-tab false

# Automatically update cache of binaries avaliable in $PATH
zstyle ':completion:*' rehash true # Can have a performance penalty

# Approximate completion
# zstyle ':completion:::::' completer _complete _approximate
# zstyle ':completion:*:approximate:*' max-errors 2

# Fuzzy completion
# https://superuser.com/questions/415650/does-a-fuzzy-matching-mode-exist-for-the-zsh-shell
zstyle ':completion:*' matcher-list '' \
  'm:{a-z\-}={A-Z\_}' \
  'r:[^[:alpha:]]||[[:alpha:]]=** r:|=* m:{a-z\-}={A-Z\_}' \
  'r:|?=** m:{a-z\-}={A-Z\_}'

# Make kill completion smart
zstyle ':completion:*:*:*:*:processes' command "ps -u $USER -o pid,user,args -w -w"

# Colored completion for files and dirs according to LS_COLORS

hash dircolors 2> /dev/null && eval $(dircolors --sh) && \
zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}

# Prompt theme setup
clear_fn() {
#  zle reset-prompt
  zle kill-buffer
}

prompt_rde_precmd() {
  # Prevent killing prompt on ^C
  trap 'clear_fn' SIGINT
}

prompt_rde_setup() {
  if [[ $UID -eq 0 ]]; then
    user_part='%F{red}>%f'
  else
    user_part='%F{green}>%f'
  fi
  if [ -n "$GUIX_ENVIRONMENT" ]; then
    genv_part='%F{blue}>%f'
  fi
  # exit_code_part='%(?..[%?])'

  PS1="$user_part$genv_part "
  # RPS1="$exit_code_part"

  # Fish-like C-c behavior
  # add-zsh-hook precmd prompt_rde_precmd
}

# Load promptinit and set rde theme
autoload -Uz promptinit && promptinit
prompt_themes+=( rde )
prompt rde

setopt printexitvalue # Instead of using RPS1 for status code

echo -en "\033[6 q" # Make a cursor to be a vertical bar

# Remove slashes and dashes from wordchars to make M-b, M-f work
# correctly
WORDCHARS=""

# Configure history
# HISTSIZE=5000
# SAVEHIST=$HISTSIZE
HISTFILE=${XDG_CACHE_HOME:-$HOME/.cache}/.zhistory

#setopt incappendhistory # Save history to shared file, but not read
setopt sharehistory     # Share history across shell sessions
setopt histignorespace  # Ignore commands that start with space

# Configuring help (M-h to call it on current command/function)
autoload -Uz run-help
(( ${+aliases[run-help]} )) && unalias run-help
autoload -Uz run-help-git

# Delete, home, end buttons
bindkey  "^[[3~"  delete-char
bindkey  "^[[H"   beginning-of-line
bindkey  "^[[F"   end-of-line

# Launch $VISUAL or $EDITOR, for emacsclient if there is no server
# avaliable $ALTERNATE_EDITOR will be used.
autoload -z edit-command-line
zle -N edit-command-line
bindkey "^X^E" edit-command-line

alias help=run-help
alias try='guix shell man-db coreutils'
alias ls='ls -p --color=auto'
alias ll='ls -l'
alias grep='grep --color=auto'
#+end_src
****** History
#+begin_src sh
HISTSIZE=1000000
SAVEHIST=$HISTSIZE
#+end_src
*** Extra profiles
**** login shell profile wip
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "profile")
:END:
***** Use Guix extra profiles
#+begin_src sh :noweb yes
gepp="<<guix-extra-profiles-path>>"
GUIX_EXTRA_PROFILES="${gepp/#\~/$HOME}"

for i in $GUIX_EXTRA_PROFILES/*; do
  profile=$i/$(basename "$i")
  if [ -f "$profile"/etc/profile ]; then
    GUIX_PROFILE="$profile"
    . "$GUIX_PROFILE"/etc/profile
  fi

  # Emulate guix-home setup-environment file (and thus `/etc/profile` as well). Regarding MANPATH and INFOPATH in particular, see https://guix.gnu.org/en/cookbook/en/guix-cookbook.html#Required-packages
  case $XDG_DATA_DIRS in
    ,*"$profile"/share*) ;;
    ,*) export XDG_DATA_DIRS="$profile"/share:$XDG_DATA_DIRS ;;
  esac
  case $MANPATH in
    ,*"$profile"/share/man*) ;;
    ,*) export MANPATH="$profile"/share/man:$MANPATH
  esac
  case $INFOPATH in
    ,*"$profile"/share/info*) ;;
    ,*) export INFOPATH="$profile"/share/info:$INFOPATH ;;
  esac
  case $XDG_CONFIG_DIRS in
    ,*"$profile"/etc/xdg*) ;;
    ,*) export XDG_CONFIG_DIRS="$profile"/etc/xdg:$XDG_CONFIG_DIRS ;;
  esac
  case $XCURSOR_PATH in
    ,*"$profile"/share/icons*) ;;
    ,*) export XCURSOR_PATH="$profile"/share/icons:$XCURSOR_PATH ;;
  esac

  unset profile
done
#+end_src
*** Nix
#+begin_src scheme
(define (he-nix svcs)
  (cons*
   (service
    (service-type
     (name 'he-nix)
     (extensions
      (list
       (service-extension
        home-files-service-type
        (const
         `(("nix-channels"
            ,(local-file "nix-channels"))
           ("config/nixpkgs/config.nix"
            ,(local-file "nixpkgs-config.nix")))))))
     (default-value #f)))
   svcs))
#+end_src
**** Load Nix environment
#+begin_src sh
if [ -f /run/current-system/profile/etc/profile.d/nix.sh ]; then
  . /run/current-system/profile/etc/profile.d/nix.sh
fi
#+end_src
**** Nix channels
#+begin_src conf :tangle (meta-in-dir "nix-channels")
https://nixos.org/channels/nixpkgs-unstable nixpkgs
#+end_src
**** Nixpkgs config
#+begin_src nix :tangle (meta-in-dir "nixpkgs-config.nix")
{ allowUnfree = true; }
#+end_src
**** Nix WIP
Commands and stuff (like manifests install and upgrade and guix channel pull) plus a packages "manifest"
***** Update channels
#+begin_src sh :results output silent :async
nix-channel --update
#+end_src
***** "Manifest"
- TODO might want to / see if I can make this a simple bulleted list I pass with :var to source block(s)
#+name: nix-packages
#+begin_src org
google-chrome zoom-us
#+end_src
***** Install packages
#+begin_src sh :results output silent :async :noweb yes
nix-env --install <<nix-packages>>
#+end_src
***** Upgrade packages
#+begin_src sh :results output silent :async
nix-env --upgrade
#+end_src
*** Emacs
#+begin_src scheme
(define* (he-emacs svcs #:key zsh-vterm? config)
  (cons*
   (service (he-emacs-service-type zsh-vterm? config))
   svcs))

(define (he-emacs-service-type zsh-vterm? config)
  (service-type
   (name 'he-emacs)
   (extensions
    (filter
     service-extension?
     (list
      (service-extension
       home-profile-service-type
       (lambda (config)
         (list (get config #:emacs))))
      (service-extension
       he-login-shell-service-type
       (lambda (config)
         (kvm #:environment-variables
              `(("VISUAL" . ,(file-append (get config #:emacs) "/bin/emacsclient"))
                ("EDITOR" . "$VISUAL")))))
      (when zsh-vterm?
        (service-extension
         home-zsh-service-type
         (const (home-zsh-extension
                 (zshrc
                  (local-file "zsh-vterm")))))))))
   (default-value
     (or config
         (kvm #:emacs emacs-29-pgtk+native-comp)))))
#+end_src
**** Configure zsh for vterm
#+begin_src sh :tangle (meta-in-dir "zsh-vterm")
vterm_printf(){
    if [ -n "$TMUX" ] && ([ "${TERM%%-*}" = "tmux" ] || [ "${TERM%%-*}" = "screen" ] ); then
        # Tell tmux to pass the escape sequences through
        printf "\ePtmux;\e\e]%s\007\e\\" "$1"
    elif [ "${TERM%%-*}" = "screen" ]; then
        # GNU screen (screen, screen-256color, screen-256color-bce)
        printf "\eP\e]%s\007\e\\" "$1"
    elif ([ "${TERM%%-*}" = "eterm" ] || [ "${TERM%%-*}" = "dumb" ]); then
        # Do nothing for Emacs' term and ansi-term, and other dumb terminals.
    else
        printf "\e]%s\e\\" "$1"
    fi
}

vterm_prompt_end() {
    vterm_printf "51;A$(whoami)@$(hostname):$(pwd)";
}
setopt PROMPT_SUBST
PROMPT=$PROMPT'%{$(vterm_prompt_end)%}
#+end_src
**** Emacs 29 with pgtk + native comp :package:version:
#+begin_src scheme :tangle (meta-in-dir "emacs.scm")
(define-module (ebullient home emacs)
  #:use-module ((gnu packages emacs) #:select (emacs-next-pgtk))
  #:use-module ((gnu packages gcc) #:select (gcc-11)))

(define emacs-from-git (@@ (flat packages emacs) emacs-from-git))
(define emacs-with-native-comp (@@ (flat packages emacs) emacs-with-native-comp))

(define-public emacs-29-pgtk+native-comp
  (emacs-from-git
   (emacs-with-native-comp emacs-next-pgtk gcc-11 'full-aot)
   #:pkg-name "emacs-29-pgtk+native-comp"
   #:pkg-version "29.0.50"
   #:pkg-revision "0"
   #:git-repo "https://git.savannah.gnu.org/git/emacs.git"
   #:git-commit "dcc97fec29785051d7d11a66beb5f44fbaae6289"
   #:checksum "1xph27x953pgigb09dkjgfcb10ldlclbxwa0hmmawmxyyx3865bn"))
#+end_src
**** Doom
#+begin_src scheme
(define (he-doom svcs)
  (cons*
   (service
    (service-type
     (name 'he-doom)
     (extensions
      (list
       (service-extension
        home-profile-service-type
        (const (list doom-emacs
                     font-fira-code))) ; TODO maybe make this contributed by the doom /config/ specifically
       ;; (service-extension
       ;;  home-files-service-type
       ;;  (const (list `("config/doom"
       ;;                 ,(local-file "doom" #:recursive? #t)))))
       ))
     (default-value #f)))
   svcs))
#+end_src
***** Doom Emacs :package:version:
- TODO make the ~doom~ program (probably the entire =bin= directory) part of outputs
#+begin_src scheme :tangle (meta-in-dir "doom-emacs.scm")
(define-module (ebullient home doom-emacs)
  #:use-module (guix build-system trivial)
  #:use-module (guix gexp)
  #:use-module (guix git-download)
  #:use-module (guix packages)
  #:use-module ((guix licenses) #:prefix license:)
  #:use-module ((gnu packages base) #:select (coreutils))
  ;; #:use-module ((gnu packages emacs) #:select (emacs))
  #:use-module ((gnu packages llvm) #:select (clang))
  #:use-module ((gnu packages rust-apps) #:select (fd ripgrep))
  #:use-module ((gnu packages version-control) #:select (git))
  #:use-module ((ebullient home fonts) #:select (fonts-emacs-all-the-icons)))

(define-public doom-emacs
  (let ((commit "849672691dd5d1214d6c72167ae84c03e8d9c8e3")
        (revision "0"))
    (package
      (name "doom-emacs")
      (version (git-version "21.12.0-alpha" revision commit))
      (source
       (origin
         (method git-fetch)
         (uri (git-reference
               (url "https://github.com/hlissner/doom-emacs")
               (commit commit)))
         (sha256
          (base32
           "1lm5mgvjhpxqfw5gcv99h4mwbq728b6f2hj5vjh1j67kdwy7ws8k"))
         (file-name (git-file-name name version))))
      ;; TODO Ideally these wouldn't be propagated inputs. Instead of tracking down usages of these and doing `substitute' everywhere maybe `wrap-prgram' is an option? However maybe there are other things in these inputs than just binaries Doom depends on or it has parts outside of emacs that recquire them?
      (propagated-inputs
       (list
        ;; Required
        ;; emacs ; TODO uncomment and wrap usage(s) with `package-input-rewriting`
        git
        ripgrep
        ;; Optional
        coreutils ; TODO might not be necessary because emacs Guix package already adds "coreutils/bin" to PATH with `wrap-program'
        fd
        clang ; TODO I still don't know what this is for. Notably hlissner doesn't install clang, nor gcc, in his emacs "module" in his dotfiles.

        all-the-icons-fonts))
      (build-system trivial-build-system)
      (arguments
       `(#:modules ((guix build utils))
         #:builder
         ,#~(begin
              (use-modules (guix build utils))
              (mkdir-p (string-append #$output "/asdf"))
              (with-output-to-file (string-append #$output "/asdf/asdf.txt")
                (lambda _
                  (display "asdffffffffffff")))
              #t)))
      (synopsis "An Emacs framework for the stubborn martian hacker")
      (description synopsis)
      (home-page "https://github.com/hlissner/doom-emacs")
      (license license:expat))))
#+end_src
****** Ligatures patch
Taken from this as-yet unmerged pull request: [[https://github.com/hlissner/doom-emacs/pull/5082][hlissner/doom-emacs#5082 feat(:ui ligatures): use ligature.el for Emacs28+ by...]]

#+begin_src diff :tangle (meta-in-dir "ligatures.patch")
diff --git a/modules/ui/ligatures/README.org b/modules/ui/ligatures/README.org
index 66d969ff1..ed486dbf6 100644
--- a/modules/ui/ligatures/README.org
+++ b/modules/ui/ligatures/README.org
@@ -16,8 +16,10 @@
   - [[#mathematical-symbols-replacement][Mathematical symbols replacement]]
   - [[#coding-ligatures][Coding ligatures]]
 - [[#configuration][Configuration]]
-  - [[#setting-ligatures][Setting ligatures]]
-  - [[#changing-ligatures][Changing ligatures]]
+  - [[#setting-symbol-replacements][Setting symbol replacements]]
+  - [[#changing-symbol-replacements][Changing symbol replacements]]
+  - [[#setting-ligatures-for-specific-font-or-major-mode][Setting ligatures for specific font or major mode]]
+    - [[#overwriting-all-default-ligatures][Overwriting all default ligatures]]
 - [[#troubleshooting][Troubleshooting]]
 
 ,* Description
@@ -53,7 +55,7 @@ Harfbuzz support (which can compose ligatures natively), or b) Mitsuharu's
 ,#+end_quote
 
 ,** Plugins
-This module installs no packages.
+- [[https://github.com/mickeynp/ligature.el][ligature.el]] (on Emacs 28+ with Harfbuzz)
 
 ,* Prerequisites
 This module requires one of three setups for ligatures to work:
@@ -103,9 +105,9 @@ Even though harfbuzz has been included in emacs 27, there is currently a [[https
 emacs 27.
 
 ,* Configuration
-** Setting ligatures
-If you want to set ligatures for modules that don't have them by default you can
-use the ~set-ligatures!~ macro in your config el file
+** Setting symbol replacements
+If you want to set symbol replacements for modules that don't have them by
+default you can use the ~set-ligatures!~ macro in your config el file
 ,#+BEGIN_SRC emacs-lisp
 (after! PACKAGE
   (set-ligatures! 'MAJOR-MODE
@@ -167,7 +169,7 @@ If you have multiple versions of the same keyword you can set the symbol twice
   :null "none"
   :null "None")
 ,#+END_SRC
-** Changing ligatures
+** Changing symbol replacements
 if you don't like the symbols chosen you can change them by using...
 
 ,#+BEGIN_SRC emacs-lisp
@@ -212,5 +214,53 @@ if you don't like the symbols chosen you can change them by using...
   :dot           "•")  ;; you could also add your own if you want
 ,#+END_SRC
 
+** Setting ligatures for specific font or major mode
+#+begin_quote
+You need Emacs 28+ with (MacOS or Harfbuzz) for EmacsLisp in this section to work.
+#+end_quote
+
+As the [[https://github.com/mickeynp/ligature.el][README]] for ligature.el states, you can manipulate the ligatures that you
+want to enable, specific for your font, or specific for the major modes that you
+want to use.
+
+#+begin_src elisp
+(after! ligature
+  (ligature-set-ligatures '(haskell-mode clojure-mode) '(">>=")))
+
+;; Alternatively
+(set-ligatures! '(haskell-mode clojure-mode)
+  :font-ligatures '(">>="))
+#+end_src
+
+This call will:
+- overwrite all preceding calls to =ligature-set-ligatures= or =set-ligatures!=
+  for =haskell-mode= and =clojure-mode= specifically, but
+- keep the inheritance to ligatures set for all modes, or parent modes like =prog-mode=
+
+*** Overwriting all default ligatures
+If you want to "start from scratch" and get control over all ligatures that
+happen in all modes, you can use
+
+#+begin_src elisp
+;; Set all your custom ligatures for all prog-modes here
+;; This section is *out of* the after! block
+;; Example: only get ligatures for "==" and "===" in programming modes
+;; by default, and get only "www" in all buffers by default.
+(setq +ligatures-prog-mode-list '("==" "===")
+      +ligatures-all-modes-list '("www"))
+;; Set any of those variables to nil to wipe all defaults.
+
+;; All mode specific configuration go in the `after!' block
+(after! ligature
+  ;; Set all your additional custom ligatures for other major modes here.
+  ;; Example: enable traditional ligature support in eww-mode, if the
+  ;; `variable-pitch' face supports it
+  (ligature-set-ligatures 'eww-mode '("ff" "fi" "ffi")))
+
+;; Alternatively
+(set-ligatures! 'eww-mode
+  :font-ligatures '("ff" "fi" "ffi"))
+#+end_src
+
 ,* TODO Troubleshooting
  If you have any problems with this module, do get in touch!
diff --git a/modules/ui/ligatures/autoload/ligatures.el b/modules/ui/ligatures/autoload/ligatures.el
index 7856ff7c1..06486a4ec 100644
--- a/modules/ui/ligatures/autoload/ligatures.el
+++ b/modules/ui/ligatures/autoload/ligatures.el
@@ -9,17 +9,24 @@
   "Associates string patterns with icons in certain major-modes.
 
   MODES is a major mode symbol or a list of them.
-  PLIST is a property list whose keys must match keys in
-`+ligatures-extra-symbols', and whose values are strings representing the text
-to be replaced with that symbol. If the car of PLIST is nil, then unset any
-pretty symbols previously defined for MODES.
+  PLIST is a property list whose keys must either:
 
-This function accepts one special property:
+  - match keys in
+`+ligatures-extra-symbols', and whose values are strings representing the text
+to be replaced with that symbol, or
+ - be one of two special properties:
 
   :alist ALIST
     Appends ALIST to `prettify-symbols-alist' literally, without mapping text to
     `+ligatures-extra-symbols'.
 
+  :font-ligatures LIST
+    Sets the list of strings that should get transformed by the font into ligatures,
+    like \"==\" or \"-->\". LIST is a list of strings.
+
+If the car of PLIST is nil, then unset any
+pretty symbols and ligatures previously defined for MODES.
+
 For example, the rule for emacs-lisp-mode is very simple:
 
   (set-ligatures! 'emacs-lisp-mode
@@ -30,18 +37,32 @@ assicated with :lambda in `+ligatures-extra-symbols'.
 
 Pretty symbols can be unset for emacs-lisp-mode with:
 
-  (set-ligatures! 'emacs-lisp-mode nil)"
+  (set-ligatures! 'emacs-lisp-mode nil)
+
+Note that this will keep all ligatures in `+ligatures-prog-mode-list' active, as
+`emacs-lisp-mode' is derived from `prog-mode'."
   (declare (indent defun))
   (if (null (car-safe plist))
       (dolist (mode (doom-enlist modes))
-        (delq! mode +ligatures-extra-alist 'assq))
-    (let (results)
+        (delq! mode +ligatures-extra-alist 'assq)
+        (add-to-list 'ligature-ignored-major-modes mode))
+    (let ((results)
+          (font-ligatures))
       (while plist
         (let ((key (pop plist)))
-          (if (eq key :alist)
-              (prependq! results (pop plist))
+          (cond
+           ((eq key :alist)
+            (prependq! results (pop plist)))
+           ((eq key :font-ligatures)
+            (setq font-ligatures (pop plist)))
+           (t
             (when-let (char (plist-get +ligatures-extra-symbols key))
-              (push (cons (pop plist) char) results)))))
+              (push (cons (pop plist) char) results))))))
+      (when font-ligatures
+        (with-eval-after-load 'ligature
+          (dolist (mode (doom-enlist modes))
+            (setq ligature-ignored-major-modes (delete mode ligature-ignored-major-modes)))
+          (ligature-set-ligatures (doom-enlist modes) font-ligatures)))
       (dolist (mode (doom-enlist modes))
         (setf (alist-get mode +ligatures-extra-alist)
               (if-let (old-results (alist-get mode +ligatures-extra-alist))
diff --git a/modules/ui/ligatures/config.el b/modules/ui/ligatures/config.el
index 484945ceb..3958aefbd 100644
--- a/modules/ui/ligatures/config.el
+++ b/modules/ui/ligatures/config.el
@@ -47,44 +47,25 @@ font.")
 (defvar +ligatures-extra-alist '((t))
   "A map of major modes to symbol lists (for `prettify-symbols-alist').")
 
-(defvar +ligatures-composition-alist
-  '((?!  . "\\(?:!\\(?:==\\|[!=]\\)\\)")                                      ; (regexp-opt '("!!" "!=" "!=="))
-    (?#  . "\\(?:#\\(?:###?\\|_(\\|[#(:=?[_{]\\)\\)")                         ; (regexp-opt '("##" "###" "####" "#(" "#:" "#=" "#?" "#[" "#_" "#_(" "#{"))
-    (?$  . "\\(?:\\$>>?\\)")                                                  ; (regexp-opt '("$>" "$>>"))
-    (?%  . "\\(?:%%%?\\)")                                                    ; (regexp-opt '("%%" "%%%"))
-    (?&  . "\\(?:&&&?\\)")                                                    ; (regexp-opt '("&&" "&&&"))
-    (?*  . "\\(?:\\*\\(?:\\*[*/]\\|[)*/>]\\)?\\)")                            ; (regexp-opt '("*" "**" "***" "**/" "*/" "*>" "*)"))
-    (?+  . "\\(?:\\+\\(?:\\+\\+\\|[+:>]\\)?\\)")                              ; (regexp-opt '("+" "++" "+++" "+>" "+:"))
-    (?-  . "\\(?:-\\(?:-\\(?:->\\|[>-]\\)\\|<[<-]\\|>[>-]\\|[:<>|}~-]\\)\\)") ; (regexp-opt '("--" "---" "-->" "--->" "->-" "-<" "-<-" "-<<" "->" "->>" "-}" "-~" "-:" "-|"))
-    (?.  . "\\(?:\\.\\(?:\\.[.<]\\|[.=>-]\\)\\)")                             ; (regexp-opt '(".-" ".." "..." "..<" ".=" ".>"))
-    (?/  . "\\(?:/\\(?:\\*\\*\\|//\\|==\\|[*/=>]\\)\\)")                      ; (regexp-opt '("/*" "/**" "//" "///" "/=" "/==" "/>"))
-    (?:  . "\\(?::\\(?:::\\|[+:<=>]\\)?\\)")                                  ; (regexp-opt '(":" "::" ":::" ":=" ":<" ":=" ":>" ":+"))
-    (?\; . ";;")                                                              ; (regexp-opt '(";;"))
-    (?0  . "0\\(?:\\(x[a-fA-F0-9]\\).?\\)") ; Tries to match the x in 0xDEADBEEF
-    ;; (?x . "x") ; Also tries to match the x in 0xDEADBEEF
-    ;; (regexp-opt '("<!--" "<$" "<$>" "<*" "<*>" "<**>" "<+" "<+>" "<-" "<--" "<---" "<->" "<-->" "<--->" "</" "</>" "<<" "<<-" "<<<" "<<=" "<=" "<=<" "<==" "<=>" "<===>" "<>" "<|" "<|>" "<~" "<~~" "<." "<.>" "<..>"))
-    (?<  . "\\(?:<\\(?:!--\\|\\$>\\|\\*\\(?:\\*?>\\)\\|\\+>\\|-\\(?:-\\(?:->\\|[>-]\\)\\|[>-]\\)\\|\\.\\(?:\\.?>\\)\\|/>\\|<[<=-]\\|=\\(?:==>\\|[<=>]\\)\\||>\\|~~\\|[$*+./<=>|~-]\\)\\)")
-    (?=  . "\\(?:=\\(?:/=\\|:=\\|<[<=]\\|=[=>]\\|>[=>]\\|[=>]\\)\\)")         ; (regexp-opt '("=/=" "=:=" "=<<" "==" "===" "==>" "=>" "=>>" "=>=" "=<="))
-    (?>  . "\\(?:>\\(?:->\\|=>\\|>[=>-]\\|[:=>-]\\)\\)")                      ; (regexp-opt '(">-" ">->" ">:" ">=" ">=>" ">>" ">>-" ">>=" ">>>"))
-    (??  . "\\(?:\\?[.:=?]\\)")                                               ; (regexp-opt '("??" "?." "?:" "?="))
-    (?\[ . "\\(?:\\[\\(?:|]\\|[]|]\\)\\)")                                    ; (regexp-opt '("[]" "[|]" "[|"))
-    (?\\ . "\\(?:\\\\\\\\[\\n]?\\)")                                          ; (regexp-opt '("\\\\" "\\\\\\" "\\\\n"))
-    (?^  . "\\(?:\\^==?\\)")                                                  ; (regexp-opt '("^=" "^=="))
-    (?w  . "\\(?:wwww?\\)")                                                   ; (regexp-opt '("www" "wwww"))
-    (?{  . "\\(?:{\\(?:|\\(?:|}\\|[|}]\\)\\|[|-]\\)\\)")                      ; (regexp-opt '("{-" "{|" "{||" "{|}" "{||}"))
-    (?|  . "\\(?:|\\(?:->\\|=>\\||=\\|[]=>|}-]\\)\\)")                        ; (regexp-opt '("|=" "|>" "||" "||=" "|->" "|=>" "|]" "|}" "|-"))
-    (?_  . "\\(?:_\\(?:|?_\\)\\)")                                            ; (regexp-opt '("_|_" "__"))
-    (?\( . "\\(?:(\\*\\)")                                                    ; (regexp-opt '("(*"))
-    (?~  . "\\(?:~\\(?:~>\\|[=>@~-]\\)\\)"))                                  ; (regexp-opt '("~-" "~=" "~>" "~@" "~~" "~~>"))
-  "An alist of all ligatures used by `+ligatures-extras-in-modes'.
-
-The car is the character ASCII number, cdr is a regex which will call
-`font-shape-gstring' when matched.
-
-Because of the underlying code in :ui ligatures module, the regex should match a
-string starting with the character contained in car.
-
-This variable is used only if you built Emacs with Harfbuzz on a version >= 28")
+(defvar +ligatures-prog-mode-list
+  '("|||>" "<|||" "<==>" "<!--" "####" "~~>" "***" "||=" "||>"
+    ":::" "::=" "=:=" "===" "==>" "=!=" "=>>" "=<<" "=/=" "!=="
+    "!!." ">=>" ">>=" ">>>" ">>-" ">->" "->>" "-->" "---" "-<<"
+    "<~~" "<~>" "<*>" "<||" "<|>" "<$>" "<==" "<=>" "<=<" "<->"
+    "<--" "<-<" "<<=" "<<-" "<<<" "<+>" "</>" "###" "#_(" "..<"
+    "..." "+++" "/==" "///" "_|_" "www" "&&" "^=" "~~" "~@" "~="
+    "~>" "~-" "**" "*>" "*/" "||" "|}" "|]" "|=" "|>" "|-" "{|"
+    "[|" "]#" "::" ":=" ":>" ":<" "$>" "==" "=>" "!=" "!!" ">:"
+    ">=" ">>" ">-" "-~" "-|" "->" "--" "-<" "<~" "<*" "<|" "<:"
+    "<$" "<=" "<>" "<-" "<<" "<+" "</" "#{" "#[" "#:" "#=" "#!"
+    "##" "#(" "#?" "#_" "%%" ".=" ".-" ".." ".?" "+>" "++" "?:"
+    "?=" "?." "??" ";;" "/*" "/=" "/>" "//" "__" "~~" "(*" "*)"
+    "\\\\" "://")
+  "A list of ligatures to enable in all `prog-mode' buffers.")
+
+(defvar +ligatures-all-modes-list
+  '()
+  "A list of ligatures to enable in all buffers.")
 
 (defvar +ligatures-in-modes
   '(not special-mode comint-mode eshell-mode term-mode vterm-mode Info-mode
@@ -182,15 +163,19 @@ and cannot run in."
  ((and EMACS28+
        (or (featurep 'ns)
            (string-match-p "HARFBUZZ" system-configuration-features))
-       (featurep 'composite))  ; Emacs loads `composite' at startup
-  (defvar +ligature--composition-table (make-char-table nil))
+       (featurep 'composite))           ; Emacs loads `composite' at startup
+
+  (use-package! ligature
+    :config
+    ;; Enable all `+ligatures-prog-mode-list' ligatures in programming modes
+    (ligature-set-ligatures 'prog-mode +ligatures-prog-mode-list)
+    (ligature-set-ligatures 't +ligatures-all-modes-list))
+
   (add-hook! 'doom-init-ui-hook :append
-    (defun +ligature-init-composition-table-h ()
-      (dolist (char-regexp +ligatures-composition-alist)
-        (set-char-table-range
-         +ligature--composition-table
-         (car char-regexp) `([,(cdr char-regexp) 0 font-shape-gstring])))
-      (set-char-table-parent +ligature--composition-table composition-function-table))))
+    (defun +ligature-enable-globally-h ()
+      "Enables ligature checks globally in all buffers.
+You can also do it per mode with `ligature-mode'."
+      (global-ligature-mode t))))
 
  ;; Fallback ligature support for certain, patched fonts. Install them with
  ;; `+ligatures/install-patched-font'
diff --git a/modules/ui/ligatures/packages.el b/modules/ui/ligatures/packages.el
new file mode 100644
index 000000000..c710f766c
--- /dev/null
+++ b/modules/ui/ligatures/packages.el
@@ -0,0 +1,9 @@
+(when (and EMACS28+
+           (or (featurep 'ns)
+               (string-match-p "HARFBUZZ" system-configuration-features))
+           (featurep 'composite))
+  (package! ligature
+    :recipe (:host github
+             :repo "mickeynp/ligature.el"
+             :files ("*.el"))
+    :pin "9357156a917a021a87b33ee391567a5d8e44794a"))
#+end_src
****** All-the-icons fonts :package:version:
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "fonts.scm")
:END:
#+begin_src scheme
(define-module (ebullient home fonts)
  #:use-module (guix build-system font)
  #:use-module (guix git-download)
  #:use-module (guix packages)
  #:use-module ((gnu packages emacs-xyz) #:select (emacs-all-the-icons))
  #:use-module ((gnu packages fonts) #:select (font-awesome font-google-material-design-icons) #:prefix fonts:)
  #:use-module (ebullient utils))

(define-public all-the-icons-fonts
  (let ((base-pkg emacs-all-the-icons)
        (commit "2c963ebb75f211d2f7ac3d2db5f4a9ee2f3e27da")
        (revision "0"))
    (package
      (name "all-the-icons-fonts")
      (version (git-version (package-version base-pkg) revision commit))
      (source
       (origin
         (method git-fetch)
         (uri (git-reference
               (url (-> base-pkg package-source origin-uri git-reference-url))
               (commit commit)))
         (sha256
          (base32
           "1gn5nyyhrvz8w1y5m8lg2khwfir0czjizmdzinr70gd7n8g1xqk9"))
         (file-name (git-file-name name version))))
      (build-system font-build-system)
      (arguments
       `(#:phases
         (modify-phases %standard-phases
           (add-before 'install 'remove-unbundled-fonts
             (lambda _
               (let* ((source (getcwd)))
                 (with-directory-excursion (string-append source "/fonts")
                   (for-each delete-file
                             (list "fontawesome.ttf"
                                   "material-design-icons.ttf")))))))))
      (propagated-inputs
       (list
        font-awesome
        fonts:font-google-material-design-icons))
      (home-page (package-home-page base-pkg))
      (synopsis (package-synopsis base-pkg))
      (description (package-description base-pkg))
      (license (package-license base-pkg)))))
#+end_src
******* Font Awesome :package:version:
#+begin_src scheme
(define-public font-awesome
  (let ((base-pkg fonts:font-awesome))
    (package (inherit base-pkg)
      (version "6.0.0")
      (source (origin
                (method git-fetch)
                (uri (git-reference
                      (url (-> base-pkg package-source origin-uri git-reference-url))
                      (commit version)))
                (file-name (git-file-name (package-name base-pkg) version))
                (sha256
                 (base32
                  "1zc4dzzcqg0xmykb4bbzcz4dxzr369k9lcx34s8yny0iakxg1xb8"))))
      (build-system font-build-system)
      (arguments '()))))
#+end_src
****** \
- TODO write a command that shows me the git diff like doom-upgrade does and use it in my eventual dotfiles upgrade script
  https://github.com/hlissner/doom-emacs/compare/fca8bd7f3fa697a91774c2ddedcd1a47cd7da01a...849672691dd5d1214d6c72167ae84c03e8d9c8e3
*** Direnv
#+begin_src scheme
(define* (he-direnv svcs #:key shell)
  (cons*
   (service
    (service-type
     (name 'he-zsh-direnv)
     (extensions
      (list
       ;; REVIEW This might not be necessary once I integrate emacs-envrc during my Doom/Straight/Guix integration.
       (service-extension
        home-profile-service-type
        (const (list direnv)))
       (case shell
         ;; ((#:shell/bash)
         ;;  (service-extension
         ;;   home-bash-service-type
         ;;   (const (home-bash-extension
         ;;           (bashrc
         ;;            (list (mixed-text-file
         ;;                   "direnv-hook"
         ;;                   "eval \"$(" (file-append direnv "/bin/direnv") "hook bash)\"")))))))
         ((#:shell/zsh)
          (service-extension
           home-zsh-service-type
           (const (home-zsh-extension
                   (zshrc
                    (list (mixed-text-file
                           "direnv-hook"
                           "eval \"$(" (file-append direnv "/bin/direnv") "hook zsh)\""))))))))))
     (default-value #f)))
   svcs))
#+end_src
*** Desktop
**** Pipewire
#+begin_src scheme
(define (he-pipewire svcs)
  (cons*
   (service
    (service-type
     (name 'he-pipewire)
     (extensions
      (list
       (service-extension
        home-profile-service-type
        (const (list pipewire-0.3
                     wireplumber)))
       (service-extension
        home-shepherd-service-type
        (const
         (list
          (shepherd-service
           (provision '(pipewire))
           (stop  #~(make-kill-destructor))
           (start #~(make-forkexec-constructor
                     (list #$(file-append pipewire-0.3 "/bin/pipewire"))
                     #:environment-variables
                     (append (list "DISABLE_RTKIT=1")
                             (default-environment-variables))))
           (auto-start? #f))
          (shepherd-service
           (requirement '(pipewire))
           (provision '(wireplumber))
           (stop  #~(make-kill-destructor))
           (start #~(make-forkexec-constructor
                     (list #$(file-append wireplumber "/bin/wireplumber"))
                     #:environment-variables
                     (append (list "DISABLE_RTKIT=1")
                             (default-environment-variables))))
           (auto-start? #f))
          (shepherd-service
           (requirement '(pipewire))
           (provision '(pipewire-pulse))
           (stop  #~(make-kill-destructor))
           (start #~(make-forkexec-constructor
                     (list #$(file-append pipewire-0.3 "/bin/pipewire-pulse"))
                     #:environment-variables
                     (append (list "DISABLE_RTKIT=1")
                             (default-environment-variables))))
           (auto-start? #f)))))
       (service-extension
        home-files-service-type
        (const
         `(("config/alsa/asoundrc"
            ,(mixed-text-file
              "asoundrc"
              #~(string-append
                 "<" #$(file-append pipewire-0.3 "/share/alsa/alsa.conf.d/50-pipewire.conf") ">" "\n"
                 "<" #$(file-append pipewire-0.3 "/share/alsa/alsa.conf.d/99-pipewire-default.conf") ">" "\n"
                 "\n"
                 "pcm_type.pipewire {" "\n"
                 "  lib " #$(file-append pipewire-0.3 "/lib/alsa-lib/libasound_module_pcm_pipewire.so") "\n"
                 "}" "\n"
                 "\n"
                 "ctl_type.pipewire {" "\n"
                 "  lib " #$(file-append pipewire-0.3 "/lib/alsa-lib/libasound_module_ctl_pipewire.so") "\n"
                 "}" "\n"))))))))
     (default-value #f)))
   svcs))
#+end_src
**** Flatpak
#+begin_src scheme
(define (he-flatpak svcs)
  (cons*
   (service
    (service-type
     (name 'he-flatpak)
     (extensions
      (list
       (service-extension
        home-profile-service-type
        (const (list flatpak
                     xdg-desktop-portal
                     xdg-desktop-portal-wlr)))))
     (default-value #f)))
   svcs))
#+end_src
***** Make Flatpak apps visible
#+begin_src sh
export XDG_DATA_DIRS=$HOME/.local/share/flatpak/exports/share:$XDG_DATA_DIRS
#+end_src
***** WIP Flatpak
Ran these manually
#+begin_src sh
flatpak remote-add --user --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo

# flatpak install --user flathub com.spotify.Client
# flatpak install --user flathub us.zoom.Zoom
#+end_src
**** Window managers
***** Sway
#+begin_src scheme
(define-module (rde features wm)
  #:use-module (rde features)
  #:use-module (rde features predicates)
  #:use-module (rde features fontutils)
  #:use-module (gnu system)
  #:use-module (gnu system keyboard)
  #:use-module (rde packages)
  #:use-module (gnu packages wm)
  #:use-module (gnu packages image)
  #:use-module (gnu packages web)
  #:use-module (gnu packages qt)
  #:use-module (gnu packages linux)
  #:use-module (gnu packages xdisorg)
  #:use-module (gnu packages freedesktop)
  #:use-module (gnu packages terminals)
  #:use-module (gnu packages rust-apps)
  #:use-module (gnu services)
  #:use-module (gnu services xorg)
  #:use-module (gnu services shepherd)
  #:use-module (gnu home services)
  #:use-module (rde home services wm)
  #:use-module (gnu home services shells)

  #:use-module (guix gexp)
  #:use-module (guix packages)

  #:use-module (srfi srfi-1)

  #:export (feature-sway
            feature-sway-run-on-tty
            feature-sway-screenshot
            feature-sway-statusbar

            feature-swayidle
            feature-swaylock))

;; https://github.com/jjquin/dotfiles/tree/master/sway/.config/sway/config.d
;; https://nixos.wiki/wiki/Sway
;; https://github.com/swaywm/sway/wiki/Useful-add-ons-for-sway

(define (keyboard-layout-to-sway-config keyboard-layout)
  (let ((kb-options (string-join
                     (keyboard-layout-options keyboard-layout) ",")))
    `((input *
             ((xkb_layout  ,(keyboard-layout-name keyboard-layout))
              (xkb_variant ,(keyboard-layout-variant keyboard-layout))
              (xkb_options ,kb-options))))))

(define* (feature-sway
          #:key
          (extra-config '())
          (sway sway)
          (foot foot)
          (bemenu bemenu)
          (xdg-desktop-portal xdg-desktop-portal)
          (xdg-desktop-portal-wlr xdg-desktop-portal-wlr)
          ;; Logo key. Use Mod1 for Alt.
          (sway-mod 'Mod4)
          (add-keyboard-layout-to-config? #t)
          (xwayland? #f))
  "Setup and configure sway."
  (ensure-pred sway-config? extra-config)
  (ensure-pred boolean? add-keyboard-layout-to-config?)
  (ensure-pred any-package? sway)
  (ensure-pred any-package? foot)
  (ensure-pred any-package? bemenu)
  (ensure-pred any-package? xdg-desktop-portal)
  (ensure-pred any-package? xdg-desktop-portal-wlr)

  (define (sway-home-services config)
    "Returns home services related to sway."
    (let* ((kb-layout      (get-value 'keyboard-layout config))
           (layout-config  (if (and add-keyboard-layout-to-config? kb-layout)
                               (keyboard-layout-to-sway-config kb-layout)
                               '()))

           (lock-cmd
            (get-value 'default-screen-locker config "loginctl lock-session"))

           (default-terminal
             (get-value-eval 'default-terminal config
                             (file-append foot "/bin/foot")))
           (backup-terminal
             (get-value 'backup-terminal config
                        (file-append foot "/bin/foot")))
           (default-application-launcher
             (get-value 'default-application-launcher config
                        (file-append bemenu "/bin/bemenu-run -l 20 -p run:"))))
      (list
       (service
        home-sway-service-type
        (home-sway-configuration
         (package sway)
         (config
          `((xwayland ,(if xwayland? 'enable 'disable))
            (,#~"")
            ,@layout-config

            (,#~"\n\n# General settings:")
            (set $mod ,sway-mod)
            (set $term ,default-terminal)
            (set $backup-term ,backup-terminal)
            (set $menu ,default-application-launcher)
            (set $lock ,lock-cmd)

            (floating_modifier $mod normal)

            (bindsym $mod+Shift+r reload)

            (,#~"\n\n# Launching external applications:")
            (bindsym $mod+Control+Shift+Return exec $backup-term)
            (bindsym $mod+Return exec $term)

            (bindsym $mod+Shift+d exec $menu)
            (bindsym $mod+Shift+l exec $lock)

            (,#~"\n\n# Manipulating windows:")
            (bindsym $mod+Shift+c kill)
            (bindsym $mod+Shift+f fullscreen)
            (bindsym $mod+Shift+space floating toggle)
            (bindsym $mod+Ctrl+space focus mode_toggle)

            (bindsym $mod+Left focus left)
            (bindsym $mod+Down focus down)
            (bindsym $mod+Up focus up)
            (bindsym $mod+Right focus right)

            (bindsym $mod+Shift+Left move left)
            (bindsym $mod+Shift+Down move down)
            (bindsym $mod+Shift+Up move up)
            (bindsym $mod+Shift+Right move right)

            (,#~"\n\n# Moving around workspaces:")
            (bindsym $mod+tab workspace back_and_forth)
            ,@(append-map
               (lambda (x)
                 `((bindsym ,(format #f "$mod+~a" (modulo x 10))
                            workspace number ,x)
                   (bindsym ,(format #f "$mod+Shift+~a" (modulo x 10))
                            move container to workspace number ,x)))
               (iota 10 1))

            (,#~"\n\n# Scratchpad settings:")
            (bindsym $mod+Shift+minus move scratchpad)
            (bindsym $mod+minus scratchpad show)

            (,#~"")
            (default_border pixel)
            (default_floating_border pixel)
            (gaps inner ,(get-value 'emacs-margin config 8))))))

       (when (get-value 'swayidle-cmd config)
         (simple-service
          'sway-enable-swayidle
          home-sway-service-type
          `((,#~"")
            (exec ,(get-value 'swayidle-cmd config)))))

       (when (get-value 'swayidle config)
         (let* ((swaymsg (file-append sway "/bin/swaymsg"))
                (swaymsg-cmd (lambda (cmd)
                               #~(format #f "'~a \"~a\"'" #$swaymsg #$cmd)))
                (idle-timeout (+ 30 (get-value 'lock-timeout config 120))))
           (simple-service
            'sway-add-dpms-to-swayidle
            home-swayidle-service-type
            `((timeout ,idle-timeout ,(swaymsg-cmd "output * dpms off")
               resume                ,(swaymsg-cmd "output * dpms on"))))))

       (simple-service
        'sway-configuration
        home-sway-service-type
        `(,@extra-config
          (,#~"")))

       (simple-service
        'sway-reload-config-on-change
        (@@ (gnu home services) home-run-on-change-service-type)
        `(("files/config/sway/config"
           ,#~(system* #$(file-append sway "/bin/swaymsg") "reload"))))

       (simple-service
        'packages-for-sway
        home-profile-service-type
        (append
         (if (and (get-value 'default-terminal config)
                  (get-value 'backup-terminal config))
             '() (list foot))
         (if (get-value 'default-application-launcher config) '() (list bemenu))
         (list qtwayland swayhide
               xdg-desktop-portal xdg-desktop-portal-wlr)))
       (simple-service 'set-wayland-specific-env-vars
                       home-environment-variables-service-type
                       ;; export NO_AT_BRIDGE=1
                       '(("XDG_CURRENT_DESKTOP" . "sway")
                         ("XDG_SESSION_TYPE" . "wayland")
                         ;; FIXME: Should be in feature-pipewire
                         ("RTC_USE_PIPEWIRE" . "true")
                         ("SDL_VIDEODRIVER" . "wayland")
                         ("MOZ_ENABLE_WAYLAND" . "1")
                         ("CLUTTER_BACKEND" . "wayland")
                         ("ELM_ENGINE" . "wayland_egl")
                         ("ECORE_EVAS_ENGINE" . "wayland-egl")
                         ("QT_QPA_PLATFORM" . "wayland-egl")
                         ("_JAVA_AWT_WM_NONREPARENTING" . "1"))))))

  (feature
   (name 'sway)
   (values `((sway . ,sway)
             (wl-clipboard . ,wl-clipboard)
             (wayland . #t)
             (xwayland? . ,xwayland?)))
   (home-services-getter sway-home-services)))


;;;
;;; sway-screenshot.
;;;

(define* (feature-sway-screenshot)
  "Configure slurp, grim and other tools for screenshot capabilities."

  (define sway-f-name 'screenshot)
  (define f-name (symbol-append 'sway- sway-f-name))

  (define (get-home-services config)
    (require-value 'sway config)
    (define subject-output
      #~(format #f "~a -t get_outputs | ~a -r '.[] | select(.focused) | .name'"
                #$(file-append (get-value 'sway config) "/bin/swaymsg")
                #$(file-append jq "/bin/jq")))
    (define subject-window-or-selection
      #~(format #f "~a -t get_tree | ~a -r '.. | select(.pid? and .visible?) \
| .rect | \"\\(.x),\\(.y) \\(.width)x\\(.height)\"' | ~a -b ~a -B ~a"
                #$(file-append (get-value 'sway config) "/bin/swaymsg")
                #$(file-append jq "/bin/jq")
                ;; TODO: Move to slurp-cmd
                #$(file-append slurp "/bin/slurp")
                "303030AA"
                "303030AA"))

    (define* (shot-script subject #:key output geom (file "-"))
      (program-file
       (string-append "sway-shot-" subject)
       #~(system
          (format #f "~a ~a~a~a | ~a"
                  #$(file-append grim "/bin/grim")
                  #$(if output #~(string-append "-o \"$(" #$output ")\" ") "")
                  #$(if geom #~(string-append "-g \"$(" #$geom ")\" ") "")
                  #$file
                  #$(file-append (get-value 'wl-clipboard config)
                                 "/bin/wl-copy")))))

    (define shot-output
      (shot-script "output" #:output subject-output))
    (define shot-window-or-selection
      (shot-script "window-or-selection" #:geom subject-window-or-selection))
    (list
     ;; (simple-service
     ;;  'sway-screenshot-packages
     ;;  home-profile-service-type
     ;;  (list slurp grim wl-clipboard jq))

     (simple-service
      'sway-screenshot
      home-sway-service-type
      `((bindsym $mod+Print exec ,shot-output)
        (bindsym $mod+Shift+Print exec ,shot-window-or-selection)))))

  (feature
   (name f-name)
   (values `((,f-name . #t)))
   (home-services-getter get-home-services)))




;;;
;;; swayidle.
;;;

(define* (feature-swayidle
          #:key
          (swayidle swayidle)
          (lock-timeout 120)
          (extra-config '()))
  "Configure swayidle."
  (ensure-pred any-package? swayidle)

  (define swayidle-cmd (file-append swayidle "/bin/swayidle -w"))

  (define (get-home-services config)
    (define lock-cmd (get-value 'default-screen-locker config))

    (list
     (service
      home-swayidle-service-type
      (home-swayidle-configuration
       (swayidle swayidle)
       (config
        `(,@(if lock-cmd
                (let ((lock-cmd-quoted (format #f "'~a'" lock-cmd)))
                  `((lock ,lock-cmd-quoted)
                    (before-sleep ,lock-cmd-quoted)
                    (timeout ,lock-timeout ,lock-cmd-quoted)))
                '())
          ,@extra-config))))))

  (feature
   (name 'swayidle)
   (values `((swayidle . ,swayidle)
             (swayidle-cmd . ,swayidle-cmd)
             (lock-timeout . ,lock-timeout)))
   (home-services-getter get-home-services)))


;;;
;;; swaylock.
;;;

(define* (feature-swaylock
          #:key
          (swaylock swaylock)
          (show-failed-attempts? #t)
          (show-keyboard-layout? #f)
          (daemonize? #t)
          (extra-config '())
          (default-screen-locker? #t))
  "Configure swaylock."
  (ensure-pred any-package? swaylock)

  (define (get-home-services config)
    (list
     (service
      home-swaylock-service-type
      (home-swaylock-configuration
       (swaylock swaylock)
       (config
        `((show-failed-attempts . ,show-failed-attempts?)
          (daemonize . ,daemonize?)
          (show-keyboard-layout . ,show-keyboard-layout?)
          ;; TODO: Source color from colorscheme
          (color . 3e3e3e)
          (indicator-caps-lock)
          ,@extra-config))))))

  (define (get-system-services _)
    (list
     (screen-locker-service swaylock "swaylock")
     ;; (simple-service
     ;;  'setuid-chkpwd
     ;;  setuid-program-service-type
     ;;  (list (file-like->setuid-program
     ;;         (file-append linux-pam "/sbin/unix_chkpwd"))))

     ;; (simple-service
     ;;  'sway-add-swaylock-pam
     ;;  pam-root-service-type
     ;;  (list
     ;;   (unix-pam-service "swaylock")))
     ))

  (feature
   (name 'swaylock)
   (values `((swaylock . ,swaylock)
             ,@(if default-screen-locker?
                   ;; TODO: Change it to path in the store, once
                   ;; https://issues.guix.gnu.org/53468 is resolved
                   `((default-screen-locker . "/run/setuid-programs/swaylock"))
                   '())))
   (home-services-getter get-home-services)
   (system-services-getter get-system-services)))
#+end_src
****** Sway old WIP
#+begin_src scheme
(define (sway-env-vars env-vars)
  (simple-service 'set-sway-env-vars
                  home-bash-service-type
                  (home-bash-extension
                   (bash-profile
                    (list (mixed-text-file
                           "sway-env-vars"
                           "if [[ \"$DESKTOP_SESSION\" = \"\" || \"$DESKTOP_SESSION\" = \"sway\" ]] ; then\n"
                           (serialize-posix-env-vars #f env-vars)
                           "fi"))))))

(define (conditionalize-sway-env-vars services)
  (define env-vars)
  (as-> services $
    (update-services*
     $
     (lambda (svc)
       (eq? (-> svc service-kind service-type-name) 'set-wayland-specific-env-vars))
     (lambda (vars)
       (set! env-vars vars)
       '()))
    (cons* (sway-env-vars env-vars) $)))

(define sway-services
  (conditionalize-sway-env-vars
   ((feature-home-services-getter
     (feature-sway #:xwayland? #t
                   #:sway-mod 'Mod1
                   #:extra-config
                   ;; `((include ,(file-append (@ (gnu packages wm) sway) "/etc/sway/config")))
                   ;; `((include ,(local-file "./config/sway/config")))
                   `((include "/home/pharcosyle/projects/dotfiles/config"))))
    (rde-config))))
#+end_src
**** Screen lockers
***** Swaylock
**** Idle management
***** Swayidle
**** Status bars
***** Waybar
**** Applets
***** Gammastep
- TODO broken tray icon. Probably I need to have some part of the =gammastep= package on the path so it can find the icon. Don't worry about this for now, maybe there will be some way to tell =papirus-icon-theme= to use a different icon or something.
#+begin_src scheme
(define (gammastep-shepherd-service _)
  (list
   (shepherd-service
    (provision '(gammastep))
    (start #~(lambda (wayland-display . _)
               ((make-forkexec-constructor
                 (list #$(file-append gammastep "/bin/gammastep-indicator") "-l 44:-123")
                 #:environment-variables
                 ;; (list (string-append "WAYLAND_DISPLAY=" wayland-display))
                 (call-with-input-file "/tmp/env-for-applets" read)))))
    (stop #~(make-kill-destructor))
    (respawn? #f)
    (auto-start? #f))))

(define gammastep-service-type
  (service-type (name 'he-gammastep)
                (extensions
                 (list (service-extension
                        home-shepherd-service-type
                        gammastep-shepherd-service)))
                (default-value #f)))
#+end_src
***** Network Manager
#+begin_src scheme
(define (network-manager-shepherd-service _)
  (list
   (shepherd-service
    (provision '(nm))
    (start #~(lambda (wayland-display . _)
               ((make-forkexec-constructor
                 (list #$(file-append network-manager-applet "/bin/nm-applet") "--indicator")
                 #:environment-variables
                 ;; (list (string-append "WAYLAND_DISPLAY=" wayland-display))
                 (call-with-input-file "/tmp/env-for-applets" read)))))
    (stop #~(make-kill-destructor))
    (respawn? #f)
    (auto-start? #f))))

(define network-manager-service-type
  (service-type (name 'he-network-manager)
                (extensions
                 (list (service-extension
                        home-shepherd-service-type
                        network-manager-shepherd-service)))
                (default-value #f)))
#+end_src
***** Udiskie
#+begin_src scheme
(define (udiskie-shepherd-service _)
  (list
   (shepherd-service
    (provision '(udiskie))
    (start #~(lambda (wayland-display . _)
               ((make-forkexec-constructor
                 (list #$(file-append udiskie "/bin/udiskie")
                       "--tray"
                       ;; (string-append "--file-manager="
                       ;;                #$(file-append xdg-utils "/bin/xdg-open"))
                       )
                 #:environment-variables
                 ;; (list (string-append "WAYLAND_DISPLAY=" wayland-display))
                 (call-with-input-file "/tmp/env-for-applets" read)))))
    (stop #~(make-kill-destructor))
    (respawn? #f)
    (auto-start? #f))))

(define udiskie-service-type
  (service-type (name 'he-udiskie)
                (extensions
                 (list (service-extension
                        home-shepherd-service-type
                        udiskie-shepherd-service)))
                (default-value #f)))
#+end_src
** Base HE
#+begin_src scheme :tangle (meta-in-dir "base-he.scm")
(define-module (ebullient home base-he)
  #:use-module (gnu home)
  #:use-module ((donnager client) #:prefix d:)
  #:use-module (ebullient home components)
  #:use-module (ebullient common)
  #:use-module (ebullient utils)
  #:export (base-he))

(define* (base-he #:key
                  system
                  account
                  developer?)
  (let* ((login-shell
          (let ((shell (get (d:pull '(#:user/login-shell) user) #:user/login-shell)))
            (if (equal shell #:shell/default)
                default-login-shell shell)))
         (interactive-shell (if developer?
                                #:shell/zsh login-shell))
         (feature?
          (let ((features (get (d:pull '(#:system/features) system) #:system/features)))
            (lambda (feat)
              (member feat features))))
         (nix? (feature? #:feature/nix))
         (desktop? (feature? #:feature/desktop))
         (pipewire? (feature? #:feature/pipewire))
         (session?
          (lambda (s)
            (member s (get (d:pull '(#:user/sessions) account) #:user/sessions))))
         (sway? (session? :session/sway)))
    (home-environment
     (services
      (-> '()
          (he-shells #:login-shell login-shell
                     #:interactive-shell interactive-shell)
          he-extra-profiles
          (as-> $
            (if nix?
                (he-nix $) $)
            (if developer?
                (-> $
                    (he-emacs #:zsh-vterm? (eq? interactive-shell #:shell/zsh)
                              ;; #:config (kvm #:emacs ...)
                              )
                    he-doom
                    (he-direnv #:shell interactive-shell)))
            (if desktop?
                (-> $
                    (as->$
                      (if pipewire?
                          (he-pipewire $) $))
                    he-flatpak
                    (as->$
                      (if sway?
                          (he-sway $) $)))
                $)))))))
#+end_src
** Home environments
:PROPERTIES:
:meta-dir+: /he
:END:
*** Solitude
#+begin_src scheme :tangle (meta-in-dir "solitude.scm")
(define-module (ebullient home he solitude)
  #:use-module (ebullient home base-he)
  #:export (he))

(define-public he
  (base-he #:system #:system/frostfire
           #:account #:user/primary
           #:developer? #t))
#+end_src
**** Solitude old WIP
#+begin_src scheme
(define-module (ebullient home he solitude)
  #:use-module (ebullient home base-he)
  #:export (he))

(define he
  (home-environment
   (packages (list ;; (specification->package "font-adobe-source-code-pro")
                   (specification->package "font-awesome") ; TODO for waybar, move this somewhere later
                   (specification->package "font-google-noto") ; TODO for sway (or any non-DE probably)
                   ))
   (services
    (list
     (service gammastep-service-type)
     (service network-manager-service-type)
     (service udiskie-service-type)

     (service home-xdg-user-directories-service-type
              (let* ((xdg-user-subdir "/files")
                     (xdg-dir (lambda (path)
                                (string-append "$HOME" xdg-user-subdir path))))
                (home-xdg-user-directories-configuration
                 (desktop "$HOME/desktop")
                 (documents (xdg-dir "/docs"))
                 (download "$HOME/dl")
                 (music (xdg-dir "/music"))
                 (pictures (xdg-dir "/pics"))
                 (publicshare (xdg-dir "/public"))
                 (templates (xdg-dir "/templates"))
                 (videos (xdg-dir "/vids")))))

     (service home-mcron-service-type
              (home-mcron-configuration
               (jobs
                (list
                 #~(job '(next-hour)
                        (lambda ()
                          (call-with-output-file "/tmp/test-mcron-file"
                            (lambda (port)
                              (display "Output!" port))))
                        "Test mcron output")))))
     (service home-git-service-type
              (home-git-configuration
               (config
                `((user
                   ((name . "Krzysztof Baranowski") ; FIXME <user-full-name>>
                    (email . "pharcosyle@gmail.com"))) ; FIXME <user-email>>
                  ;; (http "https://weak.example.com"
                  ;;   ((ssl-verify . #f)))
                  ;; (gpg
                  ;;  ((program . ,(file-append gnupg "/bin/gpg"))))
                  ;; (sendmail
                  ;;  ((annotate . #t)))
                  ))))
     (service home-ssh-service-type
              ;; (home-ssh-configuration
              ;;  (extra-config
              ;;   (list
              ;;    (ssh-host "savannah"
              ;;              '((compression . #f))))))
              )


     ;; TODO Examples from RDE I may want to make use of.
     ;; (service home-keyboard-service-type
     ;;          (keyboard-layout "us,ru" "dvorak,"
     ;;                           #:options '("grp:win_space_toggle" "ctrl:nocaps")))
     ;; (service home-gnupg-service-type
     ;;          (home-gnupg-configuration
     ;;           (gpg-agent-config
     ;;            (home-gpg-agent-configuration
     ;;             (ssh-agent? #t)))))
     ;; (service home-state-service-type
     ;;          (append
     ;;           (list
     ;;            (state-rsync "/home/bob/tmp/example-rsync-state/"
     ;;                         "abcdw@olorin.lan:/var/services/homes/abcdw/tmp-state/")
     ;;            (state-git "/home/bob/tmp/talkes/"
     ;;                       "git@git.sr.ht:~abcdw/rde"))))
     ))))
#+end_src
**** Channel deps
#+begin_src scheme :tangle (meta-in-dir "solitude-channels")
(use-modules (ebullient home channels))

(get-home-channels
 (user-channel-deps #:user/primary))
#+end_src
**** Channels lock
#+begin_src scheme :tangle (meta-in-dir "solitude-channels-lock")
(list (channel
        (name 'guix)
        (url "https://git.savannah.gnu.org/git/guix.git")
        (branch "master")
        (commit
          "04ac1a248c188e4e49e6372e8336c31d32d1c96e")
        (introduction
          (make-channel-introduction
            "9edb3f66fd807b096b48283debdcddccfea34bad"
            (openpgp-fingerprint
              "BBB0 2DDF 2CEA F6A8 0D1D  E643 A2A0 6DF2 A33A 54FA"))))
      (channel
        (name 'flat)
        (url "https://github.com/flatwhatson/guix-channel.git")
        (branch "master")
        (commit
          "ece373bcd1e00ef746fb7b104e56ab610cc4af2a")
        (introduction
          (make-channel-introduction
            "33f86a4b48205c0dc19d7c036c85393f0766f806"
            (openpgp-fingerprint
              "736A C00E 1254 378B A982  7AF6 9DBE 8265 81B6 4490"))))
      (channel
        (name 'rde)
        (url "https://git.sr.ht/~abcdw/rde")
        (branch "master")
        (commit
          "520e1429593c2daf4a296a9ea55c4aa32848b491")
        (introduction
          (make-channel-introduction
            "257cebd587b66e4d865b3537a9a88cccd7107c95"
            (openpgp-fingerprint
              "2841 9AC6 5038 7440 C7E9  2FFA 2208 D209 58C1 DEB0"))))
      (channel
        (name 'nonguix)
        (url "https://gitlab.com/nonguix/nonguix")
        (branch "master")
        (commit
          "35533c763a81365e14d0b58ad262e8f88c82872c")
        (introduction
          (make-channel-introduction
            "897c1a470da759236cc11798f4e0a5f7d4d59fbc"
            (openpgp-fingerprint
              "2A39 3FFF 68F4 EF7A 3D29  12AF 6F51 20A0 22FB B2D5")))))
#+end_src
** \
#+begin_src sh :var he_name="" he_dir=(meta-get-dir)
guix pull --channels="$he_dir"/$he_name-channels-lock
#+end_src
#+begin_src sh :var he_name=""
guix home \
	--load-path=. \
	--expression="(@ (ebullient home he $he_name) he)" \
	reconfigure
#+end_src
** Guix extra profiles
:PROPERTIES:
:meta-dir+: /manifests
:END:
*** Manifests
#+name: guix-extra-profile-path
#+begin_src sh :var profileName="" :noweb yes
echo "<<guix-extra-profiles-path>>/$profileName/$profileName"
#+end_src
**** Multiverse :manifest:
#+begin_src scheme :tangle (meta-in-dir "multiverse")
(specifications->manifest
 '("btrfs-progs" ; TODO "depends on"/"exists because of" the stateless module. Maybe it should be in some "system administration" section of Home config

   ;; "protonvpn-cli" ; REVIEW Appears to be broken after the big Guix frozen-updates upgrade.

   ;; General
   "xdg-utils"
   "gtk+:bin" ; TODO Gate this with `desktop?`
   "curl"
   "zip"
   "unzip"

   ;; Nice-to-have ; TODO might get rid of these and just `guix shell' or install as-needed
   "tree"
   "woof"


   ;;; Apps

   ;; Nyxt
   "nyxt"
   "gst-libav"
   "gst-plugins-bad"
   "gst-plugins-base"
   "gst-plugins-good"
   "gst-plugins-ugly"

   ;; "gimp" ; TODO maybe. Or just install as-needed with `guix shell`
   ))
#+end_src
#+begin_src elisp :noweb-ref guix-extra-profiles :noweb-sep " " :noweb yes
"<<guix-extra-profile-path("multiverse")>>"
#+end_src
**** Clojure manifest WIP :manifest:
- TODO =clojure-tools= has, at the time of this writing, just been upstreamed from nonguix to guix. However the guix package depends on the guix =clojure= package (presumably instead of just using the one included in the downloaded clojure-tools) which is currently on version 1.10.0 (I'll definitely want a newer version) and has a dependency on icedtea (which is jdk version 8 even though now I'll want openjdk version 11 to match datomic or version 17 because it's the newest one supported by clojure). Rewrite the =clojure= package =jre= dependency to use a newer version and bump clojure somehow? What does the =clojure= package being old mean for me, if anything, since projects definte their own clojure versions (perhaps just that version of clojure will be used when invoking tools outside a project, and even then I could just specify a higher clojure version in my home directory =deps.edn=, no?) Just resurrect the nonguix clojure-tools packge in my own dotfiles? If I keep using the guix clojure-tools package that depends on =clojure= does it having its own non-propagated java dependency mean I don't have to install one in my profile any more?
  - [2022-02-26 Sat] Andrew tropin says it's important to use the =jdk= output of openjdk (like ~(list openjdk16 "jdk")~) since the default output is the jre
#+begin_src scheme
(specifications->manifest
 '("clojure-tools" ; TODO comes from nonguix channel, I might be making that explicit later
   "icedtea" ; For clojure-tools ; TODO can I make this a non-propagated input to "clojure-tools" (`substitute*' or `wrap-program'? Automatic in some way?) or is that a bad idea / a pain?
   "clj-kondo")) ; TODO comes from nonguix channel, I might be making that explicit later
#+end_src
*** \
#+name: install-profiles
#+begin_src sh :results output silent :dir (meta-get-dir) :noweb yes :async
gepp="<<guix-extra-profiles-path>>"
GUIX_EXTRA_PROFILES="${gepp/#\~/$HOME}"

profiles=$*
if [[ $# -eq 0 ]]; then
    profiles="*";
fi

for profile in $profiles; do
  profileName=$(basename $profile .scm)
  profilePath="$GUIX_EXTRA_PROFILES/$profileName"
  mkdir -p $profilePath
  guix package --profile="$profilePath/$profileName" --manifest="$profileName"
done
#+end_src
#+call: install-profiles[:cmdline ...]()

#+name: upgrade-profiles
#+begin_src sh :results output silent :noweb yes :async
gepp="<<guix-extra-profiles-path>>"
GUIX_EXTRA_PROFILES="${gepp/#\~/$HOME}"

profiles=$*
if [[ $# -eq 0 ]]; then
    profiles="$GUIX_EXTRA_PROFILES/*";
fi

for profile in $profiles; do
  profileName=$(basename $profile)
  profilePath="$GUIX_EXTRA_PROFILES/$profileName"
  guix package --profile="$profilePath/$profileName" --manifest="$profileName"
done
#+end_src
#+call: upgrade-profiles[:cmdline ...]()
** Doom
:PROPERTIES:
:meta-dir+: /doom
:END:
*** Init
#+begin_src elisp :tangle (meta-in-dir "init.el")
;;; -*- lexical-binding: t; -*-

(doom! :completion
       (company +childframe)
       (vertico +icons)

       :ui
       doom
       doom-dashboard
       (emoji +unicode)
       hl-todo
       hydra
       indent-guides
       (ligatures +extra)
       modeline
       nav-flash
       ophints
       (popup +defaults +all)
       tabs
       treemacs
       vc-gutter
       vi-tilde-fringe
       window-select
       workspaces

       :editor
       (evil +everywhere)
       file-templates
       fold
       format
       lispy
       multiple-cursors
       rotate-text
       snippets
       word-wrap

       :emacs
       (dired +icons)
       electric
       (ibuffer +icons)
       undo
       vc

       :term
       eshell
       vterm

       :checkers
       (syntax +childframe)

       :tools
       direnv ; TODO should be contributed by direnv component
       (eval +overlay)
       lookup
       (magit +forge)
       (pass +auth)
       pdf
       prodigy ; TODO dependency of hyperdrive. Keep it enabled by default too.
       rgb
       taskrunner

       :lang
       clojure ; TODO contribute this with some Clojure module/compnent /if I end up having one/ (maybe along with the WIP clojure manifest)
       common-lisp ; TODO this should be contributed by Nyxt / my eventual nyxt project
       data
       emacs-lisp
       json
       javascript
       markdown
       nix ; TODO this should be gated by Nix inclusion like system components do.
       (org +journal)
       rest
       (scheme +guile) ; TODO Should be contributed by some Guix component (also the guix-related packages.el entries and stuff in config)
       sh
       web
       yaml ; TODO this should probably be specific to the krush/hyperdrive/afterburner(?) project

       :app
       calendar

       :config
       (default +bindings +smartparens))
#+end_src
*** Config
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "config.el")
:END:
#+begin_src elisp
;;; -*- lexical-binding: t; -*-

(use-package! dash)
(use-package! s)
#+end_src
**** Personal Info :user:
#+begin_src elisp :noweb yes
(setq user-full-name "Krzysztof Baranowski" ; FIXME <user-full-name>>
      user-mail-address "pharcosyle@gmail.com") ; FIXME <user-email>>
#+end_src
**** Locals :path:
#+begin_src elisp
(defconst biome--org-dir (concat org-directory "~/org"))
(defconst biome--org-gcal-dir (concat biome--org-dir "/gcal"))

(defconst biome--very-big 1000000)

(defconst biome--theme 'doom-nuclear)
#+end_src
#+begin_src elisp :var palette=palette
(defun biome--color (color)
  (let ((k (-> color symbol-name (substring 1))))
    (cadr (assoc k palette))))
#+end_src
**** General :UI:path:
#+begin_src elisp
;; hlissner says this must be set before org loads. I'm not sure if this is a requirement of org-mode but the Doom org config certainly does a lot of gymnastics with this variable so I'll just set this exactly like the example config does.
(setq org-directory biome--org-dir)

(setq scroll-margin 10
      save-interprogram-paste-before-kill t)

;; I like having line numbers on but hlissner says they're slow so I might want to disable them at some point. Keep in mind I use them to determine what lines are continuation lines so I might have to make the right fringe bigger if I do this and set visual-line-fringe-indicators.
;; (setq display-line-numbers-type nil)
#+end_src
***** Doom resets
#+begin_src elisp
(setq-default indent-tabs-mode t)

;; I'd like to have this on but in the Doom code it says it's more efficient not to.
;; (setq-default cursor-in-non-selected-windows t)
#+end_src
***** Doom
#+begin_src elisp
;; REVIEW Might be useful if there end up being a lot more of these and they have a lot of similarities: https://www.gnu.org/software/emacs/manual/html_node/elisp/Extending-Rx.html
(add-hook! 'doom-real-buffer-functions
  ;; (defun biome-new-buffer-p (buf)
  ;;   (s-matches?
  ;;    (rx bol "*new*"
  ;;        (* "<" (+ digit) ">")
  ;;        eol)
  ;;    (buffer-name buf)))
  ;; TODO This should be in my Org config section / module but wait to move it until I'm confident I'll be continuing with this marking-buffers-as-real approach.
  (defun biome-org-src-edit-buffer-p (buf)
    (s-matches?
     (rx bol "*Org Src " (+ anything) "*"
         (* "<" (+ digit) ">")
         eol)
     (buffer-name buf))))
#+end_src
**** Keybindings :bindings:
#+begin_src elisp
(setq help-char (string-to-char "\C-_"))
#+end_src
***** Translations
#+begin_src elisp
(defun biome--trans (&rest rest)
  (-each (-partition 2 rest)
    (-lambda ((to from))
      (define-key key-translation-map (kbd to) (kbd from)))))

(biome--trans "C-h" "DEL"
              "C-?" "C-h"

              "s-h" "<left>"
              "s-j" "<down>"
              "s-k" "<up>"
              "s-l" "<right>")
#+end_src
***** Leader/localleader
#+begin_src elisp
(setq doom-leader-alt-key "s-SPC"
      doom-localleader-key "s-m"
      doom-localleader-alt-key "s-m")
#+end_src
***** General
#+begin_src elisp
(defalias 'original-yank-pop #'yank-pop)

;; REVIEW Some of these should be in `:after' (or their respective package) sections but I'm not totally certain where I want to put bindings yet and I'm lazy.
(map! "s-V" #'original-yank-pop

      "s-SPC" doom-leader-map

      ;; Adapted from Doom macOS bindings: ~/.config/emacs/modules/config/default/config.el:263
      "s-`" #'other-frame
      "s-n" #'+default/new-buffer
      "s-z" #'undo
      "s-Z" #'redo
      "s-c" (if (featurep 'evil) #'evil-yank #'copy-region-as-kill)
      "s-v" #'yank
      "s-s" #'save-buffer
      "s-x" #'execute-extended-command
      ;; REVIEW I don't think I need this, any time I'm in visual mode I can use `evil-delete` ("d")
      ;; :v "s-x" #'kill-region
      "s-/" (cmd! (save-excursion (comment-line 1)))
      :n "s-/" #'evilnc-comment-or-uncomment-lines
      :v "s-/" #'evilnc-comment-operator

      "s-t" (lookup-key doom-leader-map (kbd "`"))
      "s-f" (lookup-key doom-leader-map (kbd "s b"))
      "s-r" (lookup-key doom-leader-map (kbd "f r"))
      "s-w" (lookup-key doom-leader-map (kbd "b k"))
      "s-d w" (lookup-key doom-leader-map (kbd "w d"))
      "s-d s-w" (cmd! (kill-current-buffer)
                      (+workspace/close-window-or-workspace))
      "s-g" (lookup-key doom-leader-map (kbd "g g"))
      "s-," (lookup-key doom-leader-map (kbd "w w"))
      "s-<" (lookup-key doom-leader-map (kbd "w W"))
      "s-y" (lookup-key doom-leader-map (kbd "i y"))
      "s-{" (lookup-key doom-leader-map (kbd "b p"))
      "s-}" (lookup-key doom-leader-map (kbd "b n"))
      "s-p" (lookup-key global-map (kbd "C-~")) ; TODO if I'm keeping this, improve it to first switch focus to a/the popup window if one isn't focused already

      "s-u" (lookup-key doom-leader-map (kbd "u"))
      "s-U" #'negative-argument         ; Trying this out.
      (:map universal-argument-map
       "s-u" #'universal-argument-more)

      (:after evil-easymotion
       "s-a" (lookup-key evilem-map (kbd "SPC")))

      "s-." #'repeat

      "s-J" #'evil-scroll-down
      "s-K" #'evil-scroll-up

      (:prefix "s-d"
       "." #'repeat-complex-command

       "h" #'git-gutter:popup-hunk
       ;; "o" #'+macos/open-in-default-program ;; TODO consider a Guix alternative? Meh.
       "r" #'projectile-replace
       "t" #'tldr
       "s" #'org-save-all-org-buffers
       "a" #'link-hint-open-multiple-links
       ;; "b" (cmd! (evil-local-mode 'toggle)
       ;;           (when evil-local-mode (evil-normal-state)))
       (:prefix "c"
        "f" #'org-gcal-fetch
        "s" #'org-gcal-sync
        "p" #'org-gcal-post-at-point)))
#+end_src
**** Modules
***** Completion
****** Vertico
******* vertico
#+begin_src elisp
(after! vertico
  (map! :map vertico-map
        "DEL" #'vertico-directory-delete-char))
#+end_src
***** UI
****** Doom
******* doom-themes
- TODO get rid of this if I'm not going to try it out again
#+begin_src elisp
;; (after! doom-themes
;;   (doom-themes-visual-bell-config))
#+end_src
****** Modeline
******* doom-modeline
#+begin_src elisp
(after! doom-modeline
  ;; (setq doom-modeline-checker-simple-format nil)
  (setq doom-modeline-major-mode-icon t)
  (setq doom-modeline-persp-name t))
#+end_src
****** Indent Guides
******* highlight-indent-guides :prog_mode:
#+begin_src elisp
(use-package! highlight-indent-guides
  :defer t
  :init
  ;; I don't want indent guides on by default, remove all the Doom module's hooks.
  (remove-hook! '(prog-mode-hook
                  text-mode-hook
                  conf-mode-hook)
    #'highlight-indent-guides-mode))
#+end_src
****** Ligatures
******* ligature
#+begin_src elisp :tangle (meta-in-dir "init.el")
(use-package-hook! ligature
  :pre-config
  (setq +ligatures-all-modes-list
        '("www")
        +ligatures-prog-mode-list
        '(;; Fira Code (from https://github.com/tonsky/FiraCode/wiki/Emacs-instructions#using-ligatureel)
          "**" "***" "**/" "*>" "*/" "\\\\" "\\\\\\" "{-" "::"
          ":::" ":=" "!!" "!=" "!==" "-}" "----" "-->" "->" "->>"
          "-<" "-<<" "-~" "#{" "#[" "##" "###" "####" "#(" "#?" "#_"
          "#_(" ".-" ".=" ".." "..<" "..." "?=" "??" ";;" "/*" "/**"
          "/=" "/==" "/>" "//" "///" "&&" "||" "||=" "|=" "|>" "^=" "$>"
          "++" "+++" "+>" "=:=" "==" "===" "==>" "=>" "=>>" "<="
          "=<<" "=/=" ">-" ">=" ">=>" ">>" ">>-" ">>=" ">>>" "<*"
          "<*>" "<|" "<|>" "<$" "<$>" "<!--" "<-" "<--" "<->" "<+"
          "<+>" "<=" "<==" "<=>" "<=<" "<>" "<<" "<<-" "<<=" "<<<"
          "<~" "<~~" "</" "</>" "~@" "~-" "~>" "~~" "~~>" "%%"
          ;; Doom defaults (just the ones not already present in Fira Code)
          "|||>" "<|||" "<==>" "||>" "::=" "=!=" "!!." ">->" "---" "<~>"
          "<||" "<-<" "_|_" "~=" "|}" "|]" "|-" "{|" "[|" "]#" ":>" ":<"
          ">:" "-|" "--" "<:" "#:" "#=" "#!" ".?" "?:" "?." "__" "(*"
          "*)" "://"))
  t)
#+end_src
***** Editor
****** Evil
******* evil :bindings:theming:
#+begin_src elisp
(after! evil
  (defun biome--set-theme-cursor-color-symbols ()
    (put 'cursor 'evil-normal-color (biome--color :gold))
    (put 'cursor 'evil-emacs-color  (biome--color :pink)))

  (defadvice! biome-update-cursor-color-a (&rest _)
    :after #'+evil-update-cursor-color-h
    (when (memq biome--theme custom-enabled-themes)
      (biome--set-theme-cursor-color-symbols)))

  (map! :m [C-i] nil)) ; Remove Doom's binding for `evil-jump-forward'.
#+end_src
****** Multiple Cursors
******* evil-multiedit :evil:
#+begin_src elisp
(after! evil-multiedit
  (setq evil-multiedit-follow-matches t))
#+end_src
****** Lisp
******* lispy
#+begin_src elisp
(use-package! lispy
  :defer t
  :init
  ;; Not using lispy, remove all the Doom module's hooks.
  (remove-hook! '(lisp-mode-hook
                  emacs-lisp-mode-hook
                  ielm-mode-hook
                  scheme-mode-hook
                  racket-mode-hook
                  hy-mode-hook
                  lfe-mode-hook
                  dune-mode-hook
                  clojure-mode-hook
                  fennel-mode-hook)
    #'lispy-mode)
  (remove-hook! 'eval-expression-minibuffer-setup-hook #'doom-init-lispy-in-eval-expression-h))
#+end_src
******* lispyville :prog_mode:bindings:
#+begin_src elisp
(use-package! lispyville
  :hook (prog-mode . lispyville-mode)
  :init
  (setq lispyville-key-theme nil) ; Prevent Doom module's invocation of `lispyville-set-key-theme' from doing anything.
  :config
  (lispyville-set-key-theme
   '(operators
     c-w
     c-u
     commentary))
  (map! :map lispyville-mode-map
        "C-s-j" #'lispyville-beginning-of-next-defun
        "C-s-k" #'lispyville-beginning-of-defun
        "C-s-," #'lispyville-end-of-defun
        "C-s-a" #'lispyville-drag-backward
        "C-s-g" #'lispyville-drag-forward
        "C-s-p" #'lispyville-prettify
        (:prefix "C-s-;"
         "R" #'lispyville-raise-list)))
#+end_src
***** Emacs
****** Dired
******* dired-x :UI:hidden:
Don't hide files in dired, remove the Doom module's hook. However, via the Doom config dired-x is only loaded when ~dired-omit-mode~ is triggered so add another hook that mimics this (loads dired-x after the first use of dired). A simple =:after= would probably be fine too (and less odd) but this is lazier.
- TODO dired buffers always marked modified
  *wait to do this until I do my dired project*
  Removing the ~dired-omit-mode~ hook causes dired buffers to start off marked as modified. I don't think this was happening until I upgraded to Emacs 29 so maybe this will resolve itself on a later Emacs upgrade.
  - although even before this started happenning I recall dired buffers being marked modified and annoying to close irritating me. I don't know why I'd want that behavior to begin with but I suspect there are good reasons.
    Some remarks on modified dired buffers: [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Auto-Reverting-Dired.html]]
#+begin_src elisp
(use-package! dired-x
  :defer t
  :init
  (remove-hook! 'dired-mode-hook #'dired-omit-mode)
  (add-hook! 'dired-mode-hook
    (defun require-dired-x-h ()
      (require 'dired-x))))
#+end_src
***** Term
****** eshell :persistence:
#+begin_src elisp
(after! eshell
  (setq eshell-history-size biome--very-big)) ; Setting this to `nil' to inherit envvar HISTSIZE is another option.
#+end_src
***** Tools
****** Magit
******* magit :UI:
#+begin_src elisp
(after! magit
  (setq git-commit-style-convention-checks '(non-empty-second-line))
  (setq magit-revision-show-gravatars '("^Author:     " . "^Commit:     ")))
#+end_src
***** Lang
****** Clojure
******* clojure :bindings:theming:
#+begin_src elisp
(use-package! clojure-mode
  :defer t
  :init
  (setq clojure-refactor-map-prefix (kbd "s-M r")) ; Has to be set before clojure-mode loads. ; REVIEW temporary binding
  :config
  (set-ligatures! 'clojure-mode :lambda "fn")
  (custom-theme-set-faces! biome--theme
    `(clojure-character-face :foreground ,(doom-color 'violet) :weight bold)))
#+end_src
******* cider :persistence:
#+begin_src elisp
(after! cider
  (setq cider-repl-history-size biome--very-big
        cider-print-options '(("length" 100))))

;; REVIEW make sure this is still working after nesting in `after!'
(after! cider-repl
  (add-hook! 'cider-repl-mode-hook
             #'goto-address-prog-mode
             #'highlight-numbers-mode
             #'rainbow-delimiters-mode
             #'yas-minor-mode-on
             #'biome-sp-strict-h))
#+end_src
******* clj-refactor :bindings:
#+begin_src elisp
(after! clj-refactor
  (cljr-add-keybindings-with-prefix "s-M R")) ; REVIEW temporary binding
#+end_src
****** Emacs Lisp
******* emacs-lisp
#+begin_src elisp
(after! elisp-mode
  (setq-hook! 'emacs-lisp-mode-hook indent-tabs-mode nil))
#+end_src
****** Org
******* org :UI:path:theming:
#+begin_src elisp
(after! org
  (setq org-agenda-files `(,biome--org-dir
                           ,biome--org-gcal-dir
                           ,(concat biome--org-dir "/projects"))
        org-log-done 'time
        org-priority-lowest ?E
        org-priority-default ?C
        org-priority-faces `((?A . ,(doom-color 'red))
                             (?B . ,(doom-color 'orange))
                             (?C . ,(doom-color 'blue))
                             (?D . ,(doom-color 'yellow))
                             (?E . ,(doom-color 'green)))))
#+end_src
******* ob
#+begin_src elisp
(after! ob
  (setq org-babel-noweb-error-all-langs t))
#+end_src
******* evil-org :evil:bindings:
#+begin_src elisp
(after! evil-org
  (map! :map evil-org-mode-map
        :nv "C-j" #'outline-forward-same-level
        :nv "C-k" #'outline-backward-same-level))
#+end_src
****** Scheme
******* scheme
#+begin_src elisp
(after! scheme
  (setq-hook! 'scheme-mode-hook indent-tabs-mode nil))
#+end_src
******* geiser :persistence:path:guix:
Use ~:init~ to configure variables (as opposed to ~:config~, which seems like it'd be fine) because hlissner does it this way for the Geiser package so I will too.
#+begin_src elisp
(use-package! geiser
  :defer t
  :init
  (setq geiser-repl-current-project-function #'ignore) ; Reset this back to its default (don't have separate REPLs for projects) because it doesn't play nice with the Guix store.
  (setq geiser-repl-history-filename (concat doom-cache-dir "geiser-history")))
#+end_src
***** App
****** Calendar
******* org-gcal :org:user:secret:persistence:path:
#+begin_src elisp
(after! org-gcal
  (setq org-gcal-client-id "446729771716-pp79934q99aro2h8v3iki1fejcodbdoo.apps.googleusercontent.com"
        org-gcal-client-secret (-> (auth-source-search :host org-gcal-client-id) car (plist-get :secret) funcall)
        org-gcal-fetch-file-alist `((user-mail-address . ,(concat biome--org-gcal-dir "/" user-mail-address ".org"))
                                    ("addressbook%23contacts@group.v.calendar.google.com" . ,(concat biome--org-gcal-dir "/contacts.org"))
                                    ("en.usa%23holiday@group.v.calendar.google.com" . ,(concat biome--org-gcal-dir "/holidays.org")))
        org-gcal-recurring-events-mode 'nested))
#+end_src
***** Config
****** expand-region :bindings:
#+begin_src elisp
(use-package! expand-region
  :defer t
  :init
  (map! :nv "s-e" #'er/expand-region
        :nv "s-E" #'er/contract-region)
  :config
  (setq expand-region-fast-keys-enabled nil) ; My mapping is conventient enough and I don't want the repeat key to conflict with anything.
  ;; Copied from Doom config: ~/.config/emacs/modules/config/default/+emacs.el:12
  (defadvice! biome--quit-expand-region-a (&rest _)
    "Properly abort an expand-region region."
    :before '(evil-escape doom/escape)
    (when (memq last-command '(er/expand-region er/contract-region))
      (er/contract-region 0))))
#+end_src
***** Guix
****** Emacs integration
******* man :path:
#+begin_src elisp :noweb yes
(after! man
  (prependq! Man-header-file-path
             (-concat (-map (lambda (p)
                              (concat p "/include"))
                            '(<<guix-extra-profiles>>))
                      '("<<guix-home-profile>>/include"))))
#+end_src
******* tramp :path:
Make tramp work on Guix. Tramp is used locally to do sudo from inside Emacs so include my user-specific paths too.
#+begin_src elisp :noweb yes
(after! tramp
  (prependq! tramp-remote-path
             (-concat (-map (lambda (p)
                              (concat p "/bin"))
                            '(<<guix-extra-profiles>>))
                      '("<<guix-home-profile>>/bin"
                        "~/.config/guix/current/bin"
                        "~/.guix-profile/bin"
                        "~/.guix-profile/sbin"
                        "/run/current-system/profile/bin"
                        "/run/current-system/profile/sbin"))))
#+end_src
****** Guix.el
******* guix :UI:
#+begin_src elisp
(after! guix
  (set-popup-rules!
    '(("^\\*Guix" :height 0.5))))
#+end_src
******* guix-devel :scheme:
#+begin_src elisp
(use-package! guix-devel
  :hook (scheme-mode . guix-devel-mode))
#+end_src
******* guix-popup :bindings:
#+begin_src elisp
(use-package! guix-popup
  :defer t
  :init
  (map! :leader
        "l" #'guix))  ; REVIEW temporary binding?
#+end_src
******* guix-prettify :UI:
#+begin_src elisp
(use-package! guix-prettify
  :hook (doom-first-buffer . global-guix-prettify-mode))
#+end_src
****** Editing
- TODO The Guix repo offers some [[https://github.com/guix-mirror/guix/tree/master/etc/snippets][snippets]] and less importantly a copyright inserter I'd like to use ([[https://guix.gnu.org/manual/en/guix.html#The-Perfect-Setup][described here]]) but I don't know where if anywhere the repo code lives on my machine.
#+begin_src elisp
;; (let ((guix-source-path "???/guix"))

;;   (after! yasnippet
;;     (add-to-list 'yas-snippet-dirs (concat guix-source-path "/etc/snippets")))

;;   (after! skeleton
;;     (load-file (concat guix-source-path "/etc/copyright.el")))

;;   (after! copyright
;;     (setq copyright-names-regexp (format "%s <%s>" user-full-name user-mail-address))))
#+end_src
***** ?
****** avy
#+begin_src elisp
;; REVIEW Trying out not having this so I can use avy dispatch commands.
;; (after! avy
;;   (setq avy-single-candidate-jump t))
#+end_src
****** paren :UI:
#+begin_src elisp
(after! paren
  (setq! show-paren-delay 0))
#+end_src
****** prog-mode :prog_mode:
#+begin_src elisp
(add-hook! 'prog-mode-hook #'biome-sp-strict-h)
#+end_src
****** rainbow-delimiters :theming:
#+begin_src elisp
(after! rainbow-delimiters
  (let ((default-max rainbow-delimiters-max-face-count))
    (defun biome-set-rainbow-delimiters-max-face-count ()
      (setq rainbow-delimiters-max-face-count
            (if (memq biome--theme custom-enabled-themes)
                8 default-max))))

  (biome-set-rainbow-delimiters-max-face-count)
  (add-hook! 'doom-load-theme-hook #'biome-set-rainbow-delimiters-max-face-count)

  (custom-theme-set-faces! biome--theme
    `(rainbow-delimiters-depth-1-face :foreground ,(doom-color 'fg))
    `(rainbow-delimiters-depth-2-face :foreground ,(doom-color 'magenta))
    `(rainbow-delimiters-depth-3-face :foreground ,(doom-color 'blue))
    `(rainbow-delimiters-depth-4-face :foreground ,(doom-color 'cyan))
    `(rainbow-delimiters-depth-5-face :foreground ,(doom-color 'green))
    `(rainbow-delimiters-depth-6-face :foreground ,(doom-color 'yellow))
    `(rainbow-delimiters-depth-7-face :foreground ,(doom-color 'orange))
    `(rainbow-delimiters-depth-8-face :foreground ,(doom-color 'red))))
#+end_src
****** recentf :persistence:
#+begin_src elisp
(after! recentf
  (setq recentf-max-saved-items 500))
#+end_src
****** smartparens :bindings:
#+begin_src elisp
(after! smartparens
  (map! :map smartparens-mode-map
        "C-s-h" #'sp-backward-sexp
        "C-s-l" #'sp-forward-sexp
        "C-s-u" #'sp-backward-up-sexp
        "C-s-o" #'sp-up-sexp
        :gn "C-s-m" #'sp-backward-down-sexp ; Bind in normal mode explicitly to override the Doom mapping in ~/.config/emacs/modules/config/default/config.el:447
        "C-s-." #'sp-down-sexp
        "C-s-c" #'sp-splice-sexp
        "C-s-s" #'sp-splice-sexp-killing-backward
        "C-s-f" #'sp-splice-sexp-killing-forward
        "C-s-x" #'sp-backward-slurp-sexp
        "C-s-v" #'sp-forward-slurp-sexp
        "C-s-w" #'sp-backward-barf-sexp
        "C-s-r" #'sp-forward-barf-sexp
        (:prefix "C-s-;"
         "(" #'sp-wrap-round
         "[" #'sp-wrap-square
         "{" #'sp-wrap-curly
         "s" #'sp-split-sexp
         "j" #'sp-join-sexp
         "r" #'sp-raise-sexp
         "c" #'sp-convolute-sexp
         "w" #'sp-rewrap-sexp)))
#+end_src
******* Hook :bindings:
#+begin_src elisp
(defun biome-sp-strict-h ()
  (add-hook! 'smartparens-enabled-hook :local
             #'turn-on-smartparens-strict-mode
             (defun biome-modify-sp-strict-mode-map-h ()
               (map! :map smartparens-strict-mode-map
                     :i "DEL" #'sp-backward-delete-char))))
#+end_src
****** tldr :persistence:path:
#+begin_src elisp
(use-package! tldr
  :defer t
  :config
  (setq tldr-directory-path (concat doom-etc-dir "tldr/")))
#+end_src
****** transient :persistence:
- TODO Not sure where this should be categorized, it's a helper package required by at least magit, forge, git-timemachine
#+begin_src elisp
(after! transient
  (setq transient-history-limit biome--very-big))
#+end_src
****** undo-fu
#+begin_src elisp
(after! undo-fu
  (setq undo-fu-ignore-keyboard-quit t))
#+end_src
****** undo-tree :UI:
#+begin_src elisp
;; (after! undo-tree
;;   (setq undo-tree-visualizer-timestamps t))
#+end_src
****** emojify :UI:
#+begin_src elisp
(after! emojify
  (setq emojify-display-style 'unicode))
#+end_src
****** asdf :bindings:
- TODO donno where this should go, ~+default-minibuffer-maps~ is a doom thing I guess
#+begin_src elisp
(define-key! :keymaps +default-minibuffer-maps
  "s-J" #'scroll-up-command
  "s-K" #'scroll-down-command)
#+end_src
**** Theming :theming:
#+begin_src elisp
(setq doom-theme biome--theme)

(custom-theme-set-faces! biome--theme
  `(font-lock-comment-delimiter-face :foreground ,(biome--color :comment-delimiter))
  `(font-lock-doc-face :foreground ,(doom-color 'cyan)))
#+end_src
***** Font
#+begin_src elisp
(let ((font (font-spec :family "Fira Code Retina" :size 12)))
  (when (find-font font)
    (setq doom-font font)))
#+end_src
***** Nuclear Theme

#+call: gen-doom-theme() :results code :post unescape(*this*) :results_switches ":tangle (meta-in-dir \"themes/doom-nuclear-theme.el\")"

#+RESULTS:
#+begin_src elisp :tangle (meta-in-dir "themes/doom-nuclear-theme.el")
;;; nuclear-theme.el --- inspired by Atom One Dark -*- lexical-binding: t; no-byte-compile: t; -*-
;;
;;
;; Created: December 6, 2020
;; Version: 2.0.0
;; Keywords: custom themes, faces
;; Homepage: https://github.com/hlissner/emacs-doom-themes
;; Package-Requires: ((emacs "25.1") (cl-lib "0.5") (doom-themes "2.2.1"))
;;
;;; Commentary:
;;
;; Inspired by Atom's One Dark color scheme.
;;
;;; Code:

(require 'doom-themes)


;;
;;; Variables

(defgroup nuclear-theme nil
  "Options for the `nuclear' theme."
  :group 'doom-themes)

(defcustom nuclear-brighter-modeline nil
  "If non-nil, more vivid colors will be used to style the mode-line."
  :group 'nuclear-theme
  :type 'boolean)

(defcustom nuclear-brighter-comments nil
  "If non-nil, comments will be highlighted in more vivid colors."
  :group 'nuclear-theme
  :type 'boolean)

(defcustom nuclear-padded-modeline doom-themes-padded-modeline
  "If non-nil, adds a 4px padding to the mode-line.
Can be an integer to determine the exact padding."
  :group 'nuclear-theme
  :type '(choice integer boolean))


;;
;;; Theme definition

(def-doom-theme doom-nuclear
  "A dark theme inspired by Atom One Dark."

  ;; name        default   256           16
  ((bg         '("#282c34" "black"       "black"  ))
   (fg         '("#dee2f8" "#bfbfbf"     "brightwhite"  ))

   ;; These are off-color variants of bg/fg, used primarily for `solaire-mode',
   ;; but can also be useful as a basis for subtle highlights (e.g. for hl-line
   ;; or region), especially when paired with the `doom-darken', `doom-lighten',
   ;; and `doom-blend' helper functions.
   (bg-alt     '("#21242b" "black"       "black"        ))
   (fg-alt     '("#5B6268" "#2d2d2d"     "white"        ))

   ;; These should represent a spectrum from bg to fg, where base0 is a starker
   ;; bg and base8 is a starker fg. For example, if bg is light grey and fg is
   ;; dark grey, base0 should be white and base8 should be black.
   (base0      '("#1B2229" "black"       "black"        ))
   (base1      '("#1c1f24" "#1e1e1e"     "brightblack"  ))
   (base2      '("#202328" "#2e2e2e"     "brightblack"  ))
   (base3      '("#23272e" "#262626"     "brightblack"  ))
   (base4      '("#3f444a" "#3f3f3f"     "brightblack"  ))
   (base5      '("#5B6268" "#525252"     "brightblack"  ))
   (base6      '("#73797e" "#6b6b6b"     "brightblack"  ))
   (base7      '("#9ca0a4" "#979797"     "brightblack"  ))
   (base8      '("#DFDFDF" "#dfdfdf"     "white"        ))

   (grey       base4)
   (red        '("#fb8578" "#ff6655" "red"          ))
   (orange     '("#fdce5f" "#dd8844" "brightred"    ))
   (green      '("#9fed9c" "#99bb66" "green"        ))
   (teal       '("#4db5bd" "#44b9b1" "brightgreen"  ))
   (yellow     '("#eddc91" "#ECBE7B" "yellow"       ))
   (blue       '("#7db9fe" "#51afef" "brightblue"   ))
   (dark-blue  '("#5f68de" "#2257A0" "blue"         ))
   (magenta    '("#e29bf7" "#c678dd" "brightmagenta"))
   (violet     '("#aeb9f3" "#a9a1e1" "magenta"      ))
   (cyan       '("#75e0f9" "#46D9FF" "brightcyan"   ))
   (dark-cyan  '("#5699AF" "#5699AF" "cyan"         ))

   ;; These are the "universal syntax classes" that doom-themes establishes.
   ;; These *must* be included in every doom themes, or your theme will throw an
   ;; error, as they are used in the base theme defined in doom-themes-base.
   (highlight      "#8496ff")
   (vertical-bar   (doom-darken base1 0.1))
   (selection      dark-blue)
   (builtin        blue)
   (comments       "#63677f")
   (doc-comments   (doom-lighten (if nuclear-brighter-comments dark-cyan base5) 0.25))
   (constants      yellow)
   (functions      blue)
   (keywords       magenta)
   (methods        violet)
   (operators      cyan)
   (type           orange)
   (strings        green)
   (variables      red)
   (numbers        violet)
   (region         `(,(doom-lighten (car bg-alt) 0.15) ,@(doom-lighten (cdr base1) 0.35)))
   (error          red)
   (warning        yellow)
   (success        green)
   (vc-modified    orange)
   (vc-added       green)
   (vc-deleted     red)

   ;; These are extra color variables used only in this theme; i.e. they aren't
   ;; mandatory for derived themes.
   (modeline-fg              fg)
   (modeline-fg-alt          base5)
   (modeline-bg              (if nuclear-brighter-modeline
                                 (doom-darken blue 0.45)
                               (doom-darken bg-alt 0.1)))
   (modeline-bg-alt          (if nuclear-brighter-modeline
                                 (doom-darken blue 0.475)
                               `(,(doom-darken (car bg-alt) 0.15) ,@(cdr bg))))
   (modeline-bg-inactive     `(,(car bg-alt) ,@(cdr base1)))
   (modeline-bg-inactive-alt `(,(doom-darken (car bg-alt) 0.1) ,@(cdr bg)))

   (-modeline-pad
    (when nuclear-padded-modeline
      (if (integerp nuclear-padded-modeline) nuclear-padded-modeline 4))))


  ;;;; Base theme face overrides
  (((line-number &override) :foreground base4)
   ((line-number-current-line &override) :foreground violet)
   ((font-lock-comment-face &override)
    :background (if nuclear-brighter-comments (doom-lighten bg 0.05)))
   (mode-line
    :background modeline-bg :foreground modeline-fg
    :box (if -modeline-pad `(:line-width ,-modeline-pad :color ,modeline-bg)))
   (mode-line-inactive
    :background modeline-bg-inactive :foreground modeline-fg-alt
    :box (if -modeline-pad `(:line-width ,-modeline-pad :color ,modeline-bg-inactive)))
   (mode-line-emphasis :foreground (if nuclear-brighter-modeline base8 highlight))

   ;;;; css-mode <built-in> / scss-mode
   (css-proprietary-property :foreground orange)
   (css-property             :foreground green)
   (css-selector             :foreground blue)
   ;;;; doom-modeline
   (doom-modeline-bar :background (if nuclear-brighter-modeline modeline-bg highlight))
   (doom-modeline-buffer-file :inherit 'mode-line-buffer-id :weight 'bold)
   (doom-modeline-buffer-path :inherit 'mode-line-emphasis :weight 'bold)
   (doom-modeline-buffer-project-root :foreground green :weight 'bold)
   ;;;; elscreen
   (elscreen-tab-other-screen-face :background "#353a42" :foreground "#1e2022")
   ;;;; ivy
   (ivy-current-match :background dark-blue :distant-foreground base0 :weight 'normal)
   ;;;; LaTeX-mode
   (font-latex-math-face :foreground green)
   ;;;; markdown-mode
   (markdown-markup-face :foreground base5)
   (markdown-header-face :inherit 'bold :foreground red)
   ((markdown-code-face &override) :background (doom-lighten base3 0.05))
   ;;;; rjsx-mode
   (rjsx-tag :foreground red)
   (rjsx-attr :foreground orange)
   ;;;; solaire-mode
   (solaire-mode-line-face
    :inherit 'mode-line
    :background modeline-bg-alt
    :box (if -modeline-pad `(:line-width ,-modeline-pad :color ,modeline-bg-alt)))
   (solaire-mode-line-inactive-face
    :inherit 'mode-line-inactive
    :background modeline-bg-inactive-alt
    :box (if -modeline-pad `(:line-width ,-modeline-pad :color ,modeline-bg-inactive-alt))))

  ;;;; Base theme variable overrides-
  ())

;;; nuclear-theme.el ends here
#+end_src
****** Generator
:PROPERTIES:
:header-args+: :tangle no
:END:
#+name: gen-doom-theme
#+begin_src elisp :var palette=palette
(defun dt--color (color)
  (let ((k (-> color symbol-name (substring 1))))
    (cadr (assoc k palette))))

(defmacro dt--buffer->string (&rest body)
  `(with-temp-buffer
     ,@body
     (buffer-string)))

(defun dt--slurp (f)
  (dt--buffer->string
   (insert-file-contents f)))

(defun dt--replace (s match replacement)
  (replace-regexp-in-string match replacement s 'fixedcase 'literal))

(defun dt--replace-sexp (s match replacement)
  (dt--buffer->string
   (insert s)
   (goto-char (point-min))
   (re-search-forward match)
   ;; Calling `forward-sexp' and `backward-sexp' here to preserve whitespace.
   (forward-sexp)
   (backward-sexp)
   (kill-sexp)
   (insert (format "%S" replacement))))

(defun dt--gen-doom-theme (f)
  (-as->
   (dt--slurp f) $
   (dt--replace-sexp $ "def-doom-theme" 'doom-nuclear)
   (dt--replace $ "doom-one" "nuclear")
   (-reduce-from
    (-lambda (s (match replacement))
      (dt--replace-sexp s match replacement))
    $
    (-partition
     2
     (let ((match-base-color (lambda (form)
                               (rx-to-string `(seq "(" ,form (+ whitespace) "'("))))
           (match-face (lambda (&rest forms)
                         (rx-to-string `(seq "(" ,@forms)))))
       (list
        (funcall match-base-color "fg") (dt--color :fg)
        (funcall match-base-color "red") (dt--color :red)
        (funcall match-base-color "orange") (dt--color :orange)
        (funcall match-base-color "green") (dt--color :green)
        (funcall match-base-color "yellow") (dt--color :yellow)
        (funcall match-base-color "blue") (dt--color :blue)
        (funcall match-base-color "dark-blue") (dt--color :dark-blue)
        (funcall match-base-color "magenta") (dt--color :magenta)
        (funcall match-base-color "violet") (dt--color :violet)
        (funcall match-base-color "cyan") (dt--color :cyan)
        (funcall match-face "highlight") (dt--color :highlight)
        (funcall match-face "builtin") 'blue
        (funcall match-face "comments") (dt--color :comments)
        (funcall match-face "constants") 'yellow
        (funcall match-face "functions") 'blue
        (funcall match-face "keywords") 'magenta
        (funcall match-face "methods") 'violet
        (funcall match-face "operators") 'cyan
        (funcall match-face "type") 'orange
        (funcall match-face "variables") 'red
        (funcall match-face "numbers") 'violet
        (funcall match-face "line-number-current-line" '(+? anything) ":foreground") 'violet))))
   (dt--replace $ (rx ";; Copyright" (*? anything) "\n") "")
   (dt--replace $ (rx ";; Author" (*? anything) "\n") "")))

;; REVIEW do this better (don't hardcode it?). Add a :path: tag to this org header if necessary. Perhaps it would be best to have the doom-themes repo be an explicit dependency in some way and manage like I do other Guix or Doom/straight dependencies.
(dt--gen-doom-theme "~/.config/emacs/.local/straight/repos/themes/themes/doom-one-theme.el")
#+end_src

#+name: unescape
#+begin_src elisp :var s=""
(-as-> s $
       (substring s 1 -1) ; Remove outer quotes.
       (replace-regexp-in-string (rx "\\n" ) "\n" $) ; Unescape newlines specifically before unescaping everything else (not how this works / why it's necessary).
       (replace-regexp-in-string (rx "\\" (group anything)) "\\1" $))

#+end_src
**** Projects
***** Dotfiles :path:
#+begin_src elisp
(load "~/projects/dotfiles/meta.el" 'noerror 'nomessage)

(pushnew! safe-local-variable-values
          '(eval . (with-eval-after-load 'geiser-guile
                     (let ((root-dir
                            (file-name-directory
                             (locate-dominating-file default-directory ".dir-locals.el"))))
                       (make-local-variable 'geiser-guile-load-path)
                       (add-to-list 'geiser-guile-load-path root-dir)))))
#+end_src
***** Nyxt
- TODO donno if I should keep this section in particular (it's not really impoportant), I'm just thinking I want to start trying out adding safe local variables for other codebases so I can get their advantages.
#+begin_src elisp
(pushnew! safe-local-variable-values
          '(eval . (cl-flet ((enhance-imenu-lisp
                              (&rest keywords)
                              (dolist (keyword keywords)
                                (add-to-list
                                 'lisp-imenu-generic-expression
                                 (list (purecopy (concat (capitalize keyword)
                                                         (if (string= (substring-no-properties keyword -1) "s")
                                                             "es"
                                                           "s")))
                                       (purecopy (concat "^\\s-*("
                                                         (regexp-opt
                                                          (list (concat "define-" keyword))
                                                          t)
                                                         "\\s-+\\(" lisp-mode-symbol-regexp "\\)"))
                                       2)))))
                     ;; This adds the argument to the list of imenu known keywords.
                     (enhance-imenu-lisp
                      "bookmarklet-command"
                      "class"
                      "command"
                      "ffi-method"
                      "function"
                      "mode"
                      "parenscript"
                      "user-class"))))
#+end_src
***** Hyperdrive :path:
#+begin_src elisp
(pushnew! safe-local-variable-values
          '(cider-preferred-build-tool . shadow-cljs)
          '(cider-default-cljs-repl . shadow)
          '(cider-shadow-default-options . ":app")
          '(cider-offer-to-open-cljs-app-in-browser . nil)
          '(cider-clojure-cli-global-options . "-A:dev")
          '(eval . (setenv "DATOMIC_APP_INFO_MAP" "{:app-name \"neutrino\"}"))
          '(eval . (setenv "DATOMIC_ENV_MAP" "{:env :dev}"))
          '(cider-clojure-cli-global-options . nil))

(prodigy-define-service
  :name "Amplify Mock"
  :command "amplify"
  :args '("mock")
  :cwd "~/projects/Krush/hyperdrive/apps/singularity"
  :kill-process-buffer-on-stop t)

(prodigy-define-service
  :name "Datomic Access (exogenesis)"
  :command "bash"
  :args '("datomic" "client" "access" "exogenesis")
  :cwd "~/projects/Krush/hyperdrive/ion/team"
  :kill-process-buffer-on-stop t)
#+end_src
***** Massrealty :path:
#+begin_src elisp
;; (pushnew! safe-local-variable-values
;;           '(ssh-deploy-root-remote . "/ssh:massrealty@35.196.144.73:/home/massrealty/deploy/homes/public_html/")
;;           '(ssh-deploy-automatically-detect-remote-changes . t))

;; (after! org-gcal
;;   (add-to-list 'org-gcal-fetch-file-alist `("krzysztof@massrealty.com" . ,(concat biome--org-gcal-dir "/krzysztof@massrealty.com.org")) 'append))
#+end_src
**** WIP
#+begin_src elisp
(after! org
  (add-to-list 'org-agenda-files (concat biome--org-dir "/spring_cleaning") 'append))

;; (map! "s-b" (cmd!
;;              ;; (message "chainging margin")
;;              ;; (message "%s" (selected-window))
;;              (set-window-margins (selected-window) nil (if (cdr (window-margins))
;;                                                            nil 12))))

;; I don't think I'll ever need this with Sway. Is it worth keeping this and having an "I'm not on Sway / some WM" conditional around it?
;; (add-to-list 'initial-frame-alist '(fullscreen . fullboth))

(map! "s-A" #'app-launcher-run-app)

(map! "s-&" (lambda (command)
              (interactive (list (read-shell-command "$ ")))
              (call-process-shell-command command nil 0 nil)))

(map! :leader
      "s-," (lookup-key doom-leader-map (kbd "<")))

(after! company
  (map! :map company-active-map
        "s-[" #'company-show-doc-buffer ; Currently opens Help, it would be better if I made it use Helpful.
        "s-]" #'company-show-location))

(after! evil-org
  (map! :map evil-org-mode-map
        (:prefix "g"
         :nv "{" #'evil-backward-paragraph
         :nv "}" #'evil-forward-paragraph)))

;; TODO Maybe do this if popping to the side is too annoying
;; (after! geiser-repl
;;   (setq geiser-repl-use-other-window nil))

;; Doesn't work yet: you have to switch to the buffer "manually" once before it starts being treated as real
(map! "s-d m" (cmd! (doom-set-buffer-real (current-buffer) t)))

;; `forward-char' in original definition is messing things up, do this for now
;; (defun +eshell/search-history ()
;;   (interactive)
;;   (consult-history))
(after! esh-mode
  (map! :map eshell-mode-map
        "C-s" #'consult-history))

;; Remove the :mode set by the Doom module. It's unnecessary (`guix-drv-mode.el' already does this, and for /nix/store drvs specifically) and it shadows `guix-derivation-mode'.
;; TODO should this go in the Guix or Nix config section?
(use-package! nix-drv-mode
  :defer t
  :init
  (setq auto-mode-alist (delete '("\\.drv\\'" . nix-drv-mode) auto-mode-alist)))

(after! vertico
  (setq vertico-count 20  ; Trying out, maybe too big.
        vertico-scroll-margin 7))

(load "~/projects/dotfiles/doom-additional.el" 'noerror 'nomessage)
#+end_src
***** "status bar"
Not using waybar at the moment so these are handy.
#+begin_src elisp
(use-package! battery
  :config
  (display-battery-mode 1))

(use-package! time
  :config
  (setq display-time-day-and-date t)
  ;; (setq display-time-24hr-format t)
  (display-time-mode 1))
#+end_src
***** keybinding ideas
#+begin_src elisp
;; If I keep this I can get rid of the "C-_" binding I have too. Update: maybe? Some places C-_ works and some s-h does (in vertico)? What about my key translation for C-? ? Straighten all this shit out.
(biome--trans "s-h" "C-h")

(map! "s-o" (lookup-key doom-leader-map (kbd "<")))
;; Get rid of binding for =s-r=?
(map! "s-r" nil)

;; Maybe "C-s-i" but then I'll have to change my sexp-movement command(s). Maybe keep this even if I do that, for consistency.
(biome--trans "C-S-i" "<backtab>")
;; Also messes with my sexp-movement bindings
;; (map! "C-s-j" #'evil-scroll-down
;;       "C-s-k" #'evil-scroll-up)

(after! evil
  (map! :map evil-motion-state-map
        ;; Maybe "C-s-o" but then I'll have to change my sexp-movement command(s). There are other bindings for jump-forward though, maybe I'll just use those.
        "C-S-o" #'evil-jump-forward))

;; Maybe `s-S' to save-and-tangle? If I don't get some sort of auto-tangling thing going
;; - maybe it could be "save and eval defun (C-M-x)" in lisp/programming modes?'
;; Maybe a hotkey that just jumps back and forth between my most recently focused browser window and eemacs?
;; Maybe bind `s-o' in `consult-buffer' to "close consult-buffer and open +vertico/switch-workspace-buffer"
#+end_src
***** dotfiles auto-tangle :path:
- TODO Might be easier to do this with file-local variables.
#+begin_src elisp
;; (setq biome--dotfiles-dir "~/projects/dotfiles")

;; (add-hook! 'org-mode-hook
;;   (defun biome-add-org-autotangle-after-save-hook-h ()
;;     (add-hook! 'after-save-hook :local
;;       (defun biome-autotangle-h ()
;;         (when (file-in-directory-p buffer-file-name biome--dotfiles-dir)
;;           ;; TODO ensure there aren't files in the output directory that no longer correspond to the org file. Just wipe it?
;;           (let ((org-confirm-babel-evaluate nil))
;;             (org-babel-tangle)))))))
#+end_src
***** org-tanglesync
#+begin_src elisp
;; (use-package! org-tanglesync
;;   :hook ((org-mode . org-tanglesync-mode)
;;          ((prog-mode text-mode) . org-tanglesync-watch-mode))
;;   :config
;;   (setq org-tanglesync-watch-files '("/home/pharcosyle/projects/dotfiles/dotfiles.org")))
#+end_src
***** Temporary copypasta from bloodhound
Copying this here for now, for convenience.
#+begin_src elisp
(setq my-dotfiles-git-dir (concat "--git-dir=" (expand-file-name "~/home-state.git")))
;; (setq my-dotfiles-work-tree (concat "--work-tree=" (expand-file-name "~")))
(map! "s-b" (cmd!
             (pushnew! magit-git-global-arguments my-dotfiles-git-dir)
             (magit-status "~")))
(map! "s-B" (cmd!
             ;; (delq! my-dotfiles-git-dir magit-git-global-arguments)
             ;; Why is the above not working? Doing this for now:
             ;; - Update: because `delq!' tests for equality with `eq'
             (setq magit-git-global-arguments (remove my-dotfiles-git-dir magit-git-global-arguments))))
#+end_src
***** until I get semicolon working
#+begin_src elisp
(map! (:map minibuffer-local-map
       "C-:" #'embark-act
       "C-c C-:" #'embark-export)
      (:leader
       "A" #'embark-dwim)
      ;; Trying out cycling (temp)
      "C-:" #'embark-act
      "s-q" #'embark-cycle)
#+end_src
***** ligatures
Probably move these to ~after!~ blocks
#+begin_src elisp
(set-ligatures! '(html-mode nxml-mode web-mode)
  :font-ligatures '("<!--" "-->" "</>" "</" "/>" ; Fira Code
                    "://"))
#+end_src
*** Packages :version:
#+begin_src elisp :tangle (meta-in-dir "packages.el")
;; -*- no-byte-compile: t; -*-

(package! dash :pin "da167c51e9fd167a48d06c7c0ee8e3ac7abd9718") ; TODO make this be introduced by my doom config (where I need it)?
(package! expand-region :pin "7e5bbe2763c12bae3e77fe0c49bcad05ff91dbfe")
(package! tldr :pin "d3fd2a809a266c005915026799121c78e8b358f0")
(package! trashed :pin "ddf5830730544435a068f2dc9ac75a81ea69df1d")

(package! guix :pin "c9aef52121b458297e70bb50f49f7276b4a8d759")
(package! build-farm :pin "5c268a3c235ace0d79ef1ec82c440120317e06f5") ; REVIEW trying out
(package! guix-packaging ; REVIEW trying out
  :recipe (:host github
           :repo "ryanprior/emacs-guix-packaging"
           :files (:defaults "snippets"))
  :pin "d843088252467db3c8a09de40ae9a62050196a0e")

(package! bluetooth :pin "a1ea361f17c6b4e5353160539cd3df6754007a9d") ; TODO just maybe make this dependent on my "bluetooth feature"

(package! symon :pin "8dd8b6df49b03cd7d31b85aedbe9dd08fb922335")

;; TODO this should probably be specific to the krush/hyperdrive/afterburner(?) project
;; (package! graphql-mode :pin "2371316a750b807de941184d49ca19d277ecadcd")

(package! org-tanglesync :pin "af83a73ae542d5cb3c9d433cbf2ce1d4f4259117")

(package! i3wm-config-mode :pin "c70bdc1367e461299e13a4797bc9d9d950184edd") ; TODO maybe make this part of a Sway / Window Manager feature or introduced by my Dotfiles project

;; REVIEW Breaks stuff after I updated to emacs 29 latest:
;; Compiling EmacSQL SQLite binary ...
;; Code Review initialization: (error "No EmacSQL SQLite binary available, aborting")
(package! code-review :disable t)

(package! app-launcher
  :recipe (:host github
           :repo "SebastienWae/app-launcher")
  :pin "80a9ed37892ee6e21fe44487ed11f66a15e3f440")

(package! 0x0 :pin "63cd5eccc85e527f28e1acc89502a53245000428")

;; TODO do hardcoded path better?
(package! donnager
  :recipe (:local-repo "~/projects/dotfiles/donnager"
           ;; Avoid having to run `doom sync' every time the package is changed. REVIEW after packaging Doom revisit this and see if it still makes sense to disable compilation. Byte-compiled code is faster, after all.
           :build (:not compile)))
#+end_src
* Utils
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "ebullient/utils.scm")
:END:
#+begin_src scheme
(define-module (ebullient utils)
  #:use-module ((guix inferior) #:select (inferior-for-channels lookup-inferior-packages))
  #:use-module (gnu services)
  #:use-module ((ice-9 match) #:select (match-lambda))
  #:use-module ((srfi srfi-1) #:select (take drop remove fold first))
  #:export (when-let
            if-let
            when-not
            if-not
            update-list
            partial
            ->
            ->>
            as->
            kvm
            get
            keys
            massoc
            merge
            keyvals
            update-services*
            update-services))
#+end_src
** Conditionals
#+begin_src scheme
(define-syntax when-let
  (syntax-rules ()
    ((_ ((var expr)) body ...)
     (let ((var expr))
       (when var body ...)))))

(define-syntax if-let
  (syntax-rules ()
    ((_ ((var expr)) then else)
     (let ((var expr))
       (if var then else)))))

(define-syntax when-not
  (syntax-rules ()
    ((_ test body ...)
     (when (not test) body ...))))

(define-syntax if-not
  (syntax-rules ()
    ((_ test then else)
     (if (not test) then else))))
#+end_src
** Lists
#+begin_src scheme
(define (update-list l pred f)
  (map (lambda (x)
         (if (pred x) (f x) x))
       l))

(define* (partial f #:rest args)
  (lambda* (#:rest more)
    (apply f (append args more))))

(define* (rpartial f #:rest args)
  (lambda* (#:rest more)
    (apply f (append more args))))

(define-syntax ->
  (syntax-rules ()
    ((_ value) value)
    ((_ value (f . body) next ...) (-> (f value . body) next ...))
    ((_ value f next ...) (-> (f value) next ...))))

(define (thread-last-helper f value . body)
  (apply f (append body (list value))))

(define-syntax ->>
  (syntax-rules ()
    ((_ value) value)
    ((_ value (f . body) next ...) (->> (thread-last-helper f value . body) next ...))
    ((_ value f next ...) (-> (f value) next ...))))

(define-syntax as->
  (syntax-rules ()
    ((_ expr name) expr)
    ((_ expr name form form* ...)
     (let ((name expr))
       (as-> form name form* ...)))))
#+end_src
** Maps
#+begin_src scheme
(define* (kvm #:rest keyvals)
  (let loop ((m '())
             (more keyvals))
    (if (null? more)
        m
        (loop (cons (as-> more $
                          (take $ 2)
                          (apply cons $))
                    m)
              (drop more 2)))))

(define get assoc-ref)

(define (keys m)
  (map car m))

(define (massoc m k v)
  (->> m
       (remove (match-lambda
                 ((k1 . _)
                  (equal? k k1))))
       (cons '(k . v))))

(define* (merge #:rest maps)
  (fold
   (lambda (m1 m2)
     (fold
      (match-lambda
        (((k . v) res)
         (massoc res k v)))
      m1 m2))
   (kvm)
   maps))

(define (keyvals m)
  (->> m
       (map (match-lambda
              ((k . v)
               (list k v))))
       (apply append)))
#+end_src
** Guix
#+begin_src scheme
(define (update-services* services pred update-fn)
  (update-list
   services
   pred
   (lambda (svc)
     (service (service-kind svc)
              (update-fn (service-value svc))))))

(define (update-services services kind update-fn)
  (update-services*
   services
   (lambda (svc)
     (eq? (service-kind svc) kind))
   update-fn))

(define (get-inferior-package channels package)
  (-> (inferior-for-channels channels)
      (lookup-inferior-packages package)
      first))
#+end_src
* DB
:PROPERTIES:
:meta-dir+: /donnager
:END:
** Core
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "donnager-core.el")
:END:
#+begin_src elisp
;;; -*- lexical-binding: t; -*-

(require 'dash)
#+end_src




#+begin_src elisp
(defun db--entity->datoms (entity)
  (->> entity
       ;; FIXME what was `map-pairs' for?
       map-pairs
       (map-remove (lambda (k _)
                     (equal k :db/id)))
       (-mapcat (-lambda ((a . v))
                  (let ((avs (if (listp v)
                                 (-map (lambda (i) `(,a ,i)) v)
                               `((,a ,v)))))
                    (-map (-lambda ((attr value))
                            (db--datom (map-elt entity :db/id) attr value))
                          avs))))))
#+end_src

#+name: base-schema
| =:db/id=        | =:db/valueType=  | =:db/cardinality=   |
|-----------------+------------------+---------------------|
| :db/id          | :db.type/keyword | :db.cardinality/one |
| :db/valueType   | :db.type/keyword | :db.cardinality/one |
| :db/cardinality | :db.type/keyword | :db.cardinality/one |

#+begin_src elisp
(defun db--parse-schema-entity (entity)
  (map-apply (lambda (a b)
               (cons (intern a) (intern b)))
             entity))
#+end_src

#+begin_src elisp :var base-schema-table=base-schema
(defun db--parse-base-schema ()
  (->> base-schema-table
       db--parse-org-table
       (-map #'db--parse-schema-entity)
       (-mapcat #'db--entity->datoms)))
#+end_src
#+begin_src elisp
(setq db--base-schema-memo nil)

(defun db--base-schema ()
  (if db--base-schema-memo
      db--base-schema-memo
    (setq db--base-schema-memo db--parse-base-schema)))


(defun db--with-base-schema (db)
  (-concat (db--base-schema) db))
#+end_src



#+begin_src elisp
(setq db--schema-defaults
      (kvm :db.valueType :db.type/string
           :db.cardinality :db.cardinality/one))

(defun db--get-schema (db attr schema-attr)
  (-as-> db $
         (db--with-base-schema $)
         (-first (lambda (datom)
                   (db--datom-match-e+a datom attr schema-attr))
                 $)
         (if $
             (db--dget $ :datom/v)
           (map-elt db--schema-defaults schema-attr))))
#+end_src




#+begin_src elisp
(defun db--datom (e a v)
  (list e a v))

(defun db--dget (datom component)
  ((pcase component
     (:datom/e #'-first-item)
     (:datom/a #'-second-item)
     (:datom/v #'-third-item))
   datom))

(defun db--datom-match-e+a (datom e a)
  (and (equal (db--dget datom :datom/e) e)
       (equal (db--dget datom :datom/a) a)))

(defun db--assert (db datom)
  (cons datom))
#+end_src
*** Utils
#+begin_src elisp
(defun kvm (&rest keyvals)
  (->> keyvals
       (-partition 2)
       (-map (-lambda ((a b))
               (cons a b)))))
#+end_src
*** \
#+begin_src elisp
(provide 'donnager-core)
#+end_src
** Client API
*** Elisp
*** Scheme
#+begin_src scheme :tangle (meta-in-dir "client.scm")
(define-module (donnager client)
  #:export (q
            q-many
            pull
            pull-many))

(define (q)
  #f)
(define (q-many)
  #f)
(define (pull)
  #f)
(define (pull-many)
  #f)
#+end_src
** Org API
:PROPERTIES:
:header-args+: :tangle (meta-in-dir "donnager-org.el")
:END:
#+begin_src elisp
;;; -*- lexical-binding: t; -*-

(require 'donnager-core)

(setq db--empty-db '())
#+end_src
*** Data
#+begin_src elisp
(setq db--parse-keyword #'intern)

(defun match-string-one (regex s)
  (save-match-data
    (when (string-match regex s)
      (match-string 1 string))))

(setq db--parsers
      (kvm :db.type/keyword db--parse-keyword
           :db.type/string #'identity
           :db.type/boolean (lambda (s)
                              (pcase s
                                ("true" t)
                                ("false" nil)))
           :db.type/symbol (lambda (s)
                             (intern (match-string-one (rx "'" (group (* anything))) s)))))

(defalias 'db--parse-attr #'db--parse-keyword)

(defun db--parse-value (db a raw-v)
  (let* ((type (db--get-schema db a :db/valueType))
         (parser (map-elt db--parsers type))
         (cardinality (db--get-schema db a :db/cardinality)))
    (if (equal cardinality :db.cardinality/many)
        (-as-> raw-v $
               (split-string $ (rx (+ whitespace)))
               (-map (lambda (raw-item)
                       (funcall parser raw-item))))
      (funcall parser raw-v))))

(defun db--parse-entity (db raw-entity)
  (map-apply (lambda (raw-a raw-v)
               (let ((a (db--parse-attr raw-a)))
                 (cons a
                       (db--parse-value db a raw-v))))
             raw-entity))
#+end_src
*** Tables
#+begin_src elisp
(defun db--normalize-org-table (table)
  (-remove (-partial #'equal 'hline) table))

(defun db--strip-org-emphasis (s)
  (if (and (< 2 (length s))
           (let ((first (substring s 0 1))
                 (last (substring s -1)))
             (and (equal first last)
                  (member first (map-keys org-emphasis-alist)))))
      (substring s 1 -1)
    s))

(defun db--parse-org-table (table)
  (let* ((table (db--normalize-org-table table))
         (attrs (-map #'db--strip-org-emphasis (car table)))
         (rows (cdr table)))
    (-map (lambda (row)
            (->> row
                 (-zip-pair attrs)
                 (map-remove (lambda (_ v)
                               (equal v "")))))
          rows)))
#+end_src
*** Injest
#+begin_src elisp
(defun db--raw-entity-into-db (db raw-entity)
  (->> raw-entity
       (db--parse-entity db)
       db--entity->datoms
       (-reduce-from #'db--assert db)))

(defun db--tables-into-db (tables)
  (->> tables
       (-mapcat #'db--parse-org-table)
       (-reduce-from #'db--raw-entity-into-db db--empty-db)))

(defun db--load (table-refs)
  (require 'ob-ref)
  (db--tables-into-db
   (-map #'org-babel-ref-resolve table-refs)))
#+end_src
*** Serialize
#+begin_src elisp
(setq db--tokenize-keyword #'identity)

(setq db--tokenizers
      (kvm :db.type/keyword db--tokenize-keyword
           :db.type/string #'identity
           :db.type/boolean (lambda (v)
                              (if v 'true 'false))
           :db.type/symbol #'identity))

(defalias 'db--tokenize-attr #'db--tokenize-keyword)

(defun db--tokenize-value (db a v)
  (let* ((type (db--get-schema db a :db/valueType))
         (tokenizer (map-elt db--tokenizers type)))
    (funcall tokenizer v)))

(defun db--tokenize-datom (db datom)
  (let ((e (db--dget datom :datom/e))
        (a (db--dget datom :datom/a))
        (v (db--dget datom :datom/v)))
    (db--datom
     (db--tokenize-value db :db/id e)
     (db--tokenize-attr a)
     (db--tokenize-value db a v))))

(defalias 'db--serialize-fn (-partial #'format "%S"))

(defun db--spit (f content)
  (with-temp-file f
    (insert content)))

(defun db--serialize (file datoms)
  (with-temp-file file
    (->> datoms
         (-map (-partial #'tokenize-datom datoms))
         db--serialize-fn
         ;; db--pretty-print-db
         db--spit)))

;; TODO pretty-printing
;; https://emacs.stackexchange.com/questions/10382/perform-function-until-it-returns-user-error

;; (defmacro db--buffer->string (&rest body)
;;   `(with-temp-buffer
;;      ,@body
;;      (buffer-string)))

;; (defun db--pretty-print-db (s)
;;   (let ((delim "\n "))
;;     (dt--buffer->string
;;      (insert s)
;;      (goto-char (point-min))
;;      (forward-char)
;;      (condition-case _
;;          (while t
;;            (forward-sexp)
;;            (insert delim))
;;        (scan-error nil))
;;      (dotimes (_ (length delim))
;;        (backward-delete-char)))))
#+end_src
*** Deserialize
#+begin_src elisp
(setq db--marshall-keyword #'identity)

(setq db--marshallers
      (kvm :db.type/keyword db--marshall-keyword
           :db.type/string #'identity
           :db.type/boolean (lambda (token)
                              (pcase s
                                ('true t)
                                ('false nil)))
           :db.type/symbol #'identity))

(defalias 'db--marshall-attr #'db--marshall-keyword)

(defun db--marshall-value (db a v)
  (let* ((type (db--get-schema db a :db/valueType))
         (marshaller (map-elt db--marshallers type)))
    (funcall marshaller v)))

(defun db--marshall-datom (db tokenized-datom)
  (let ((e (db--dget tokenized-datom :datom/e))
        (a (db--dget tokenized-datom :datom/a))
        (v (db--dget tokenized-datom :datom/v)))
    (db--datom
     (db--marshall-value db :db/id e)
     (db--marshall-attr a)
     (db--marshall-value db a v))))

(defalias 'db--deserialize-fn #'read)

(defun db--slurp (f)
  (with-temp-buffer
    (insert-file-contents f)
    (buffer-string)))

(defun db--deserialize (file)
  (->> (db--slurp file)
       db--deserialize-fn
       (-map #'marshall-datom)))
#+end_src
*** \
#+begin_src elisp
(provide 'donnager-org)
#+end_src
** \
#+begin_src gitignore :tangle (meta-in-dir ".gitignore")
*
#+end_src
* Dev
** Git ignore
#+begin_src gitignore :tangle (meta-in-dir ".gitignore")
/.gitignore
#+end_src
** Github
*** Git config
#+begin_src gitconfig :tangle (meta-in-dir ".git/config")
[remote "origin"]
	url = https://github.com/pharcosyle/dotfiles.git
	fetch = +refs/heads/*:refs/remotes/origin/*

[branch "master"]
	remote = origin
	merge = refs/heads/master
#+end_src
* Dev local
** Git config
#+begin_src gitconfig :tangle (meta-in-dir ".git/config")
[core]
	repositoryformatversion = 0
	filemode = true
	bare = false
	logallrefupdates = true
#+end_src
** Emacs directory-local variables
- TODO Causes gesier to fail to load outside of this directory
  *don't do this until I figure out how I'm doing per-project Emcas config* I might not end up doing Geiser setup this way at all
  Since the ~with-eval-after-load~ body will get called wherever geiser-guile is first loaded, if the geiser library isn't loaded yet and I e.g. visit a file in this directory, then leave, then try to =M-x guix p e= while I'm viewing a file elsewhere it'll fail to run since it loads geiser internally and can't find a dominating .dir-locals.
  - an alternative approach to setting up geiser for a project: [[https://github.com/guix-mirror/guix/blob/master/.dir-locals.el#L21][guix/.dir-locals.el at master · guix-mirror/guix · GitHub]]
    Maybe try that or something like it.
    - here's where I got the original approach, for reference: [[https://github.com/flatwhatson/flycheck-guile#troubleshooting][GitHub - flatwhatson/flycheck-guile: A Flycheck checker for GNU Guile]]
#+begin_src elisp :tangle (meta-in-dir ".dir-locals.el")
((nil
  (eval . (with-eval-after-load 'geiser-guile
            (let ((root-dir
                   (file-name-directory
                    (locate-dominating-file default-directory ".dir-locals.el"))))
              (make-local-variable 'geiser-guile-load-path)
              (add-to-list 'geiser-guile-load-path root-dir))))))
#+end_src

#+begin_src gitignore :tangle (meta-in-dir ".gitignore")
/.dir-locals.el
#+end_src
