#+TITLE: Dotfiles
#+PROPERTY: header-args :mkdirp yes

* Meta
#+begin_src elisp
(setq base-tangle-dir ".")

(defun get-tangle-dir ()
  (concat base-tangle-dir
          (when-let ((dirs (org-entry-get (point) "tangle-dir" 'inherit)))
            (thread-first dirs (split-string " /") (string-join "/")))))

(defun in-tangle-dir (sub-path)
  (concat (get-tangle-dir) "/" sub-path))
#+end_src
* Common
#+name: user-name
#+begin_src org
pharcosyle
#+end_src
#+name: user-full-name
#+begin_src org
Krzysztof Baranowski
#+end_src
#+name: user-email
#+begin_src org
pharcosyle@gmail.com
#+end_src
* Installation
** Create bootable USB
Download (or create) a Guix installation ISO
- I'm using the [[https://github.com/SystemCrafters/guix-installer/releases/latest][System Crafters Guix Installer]] since it's kept up-to-date which should speed things up a bit.
- Run ~lsblk~ to find the usb device.
#+begin_src sh
iso_file=guix-system-install-1.3.0.x86_64-linux.iso
usb_device=/dev/sdc
dd if=$iso_file of=$usb_device status=progress bs=4M
sync
#+end_src
** Install
Boot from the installation medium, select your language and country, and select "Install using the shell based process" when prompted.
*** Keyboard layout
This messed up the keyboard when I tried it on mac, not doing ~loadkeys~ at all was fine.
#+begin_src sh
# keysfile=mac-us
# loadkeys mac-us
#+end_src
*** Networking
#+begin_src sh
# List network interfaces and find one to use.
ifconfig -a

# Is this necessary if the interface is already activated?
interface=usb0
ifconfig $interface up

dhclient -v $interface

# Test that networking is up and working.
ping -c 3 gnu.org
#+end_src
*** Partitioning
#+begin_src sh
# Check out the current block devices and partitions if you want.
lsblk

device=/dev/sda

# Make two partitions, partition types should be "EFI system partition" and "Linux x86-64 root (/)". For EFI I'm gonna do 1GB to be on the safe side, second should be remainder of free space.
cfdisk $device
parted $device set 1 esp on

efi_system_partition="$device"1
efi_label=genesis

mkfs.fat -F32 -n $efi_label $efi_system_partition

root_partition="$device"2
root_label=firmament
crypt_name=ciphered
crypt_mapping=/dev/mapper/$crypt_name

cryptsetup luksFormat $root_partition
cryptsetup open --type luks $root_partition $crypt_name

mkfs.btrfs -L $root_label $crypt_mapping
#+end_src
*** Set up subvolumes
#+begin_src sh
# I don't know if the type argument is necessary but that's how Andrew Tropin had it.
mount -t btrfs LABEL=$root_label /mnt

btrfs subvolume create /mnt/root
btrfs subvolume create /mnt/boot
btrfs subvolume create /mnt/guix-store
btrfs subvolume create /mnt/guix-var
btrfs subvolume create /mnt/log
btrfs subvolume create /mnt/home
btrfs subvolume create /mnt/persist
btrfs subvolume create /mnt/nix

# Take an empty readonly snapshot of the root subvolume (might be useful later for rolling back or comparison)
btrfs subvolume snapshot -r /mnt/root /mnt/root-blank

umount /mnt
#+end_src
*** Mount
NB: ~$crypt_mapping~ can/"should" be ~LABEL=$root_label~
#+begin_src sh
mount -o subvol=root,compress=zstd,autodefrag $crypt_mapping /mnt

mkdir /mnt/boot
mount -o subvol=boot,compress=zstd,autodefrag $crypt_mapping /mnt/boot
mkdir -p /mnt/gnu/store
mount -o subvol=guix-store,compress=zstd,autodefrag,noatime $crypt_mapping /mnt/gnu/store
mkdir -p /mnt/var/guix
mount -o subvol=guix-var,compress=zstd,autodefrag $crypt_mapping /mnt/var/guix
mkdir -p /mnt/var/log
mount -o subvol=log,compress=zstd,autodefrag $crypt_mapping /mnt/var/log
mkdir /mnt/home
mount -o subvol=home,compress=zstd,autodefrag $crypt_mapping /mnt/home
mkdir /mnt/.persist
mount -o subvol=persist,compress=zstd,autodefrag $crypt_mapping /mnt/.persist

mkdir -p /mnt/boot/efi
mount LABEL=$efi_label /mnt/boot/efi
#+end_src
*** Proceeding with installation
#+begin_src sh
herd start cow-store /mnt
#+end_src
*** System configuration
#+begin_src sh
# Grab my dotfiles, from github if I put them up at some point or maybe from a USB or another computer with `woof`, into the current directory (the one I'm already in, not `/mnt`).
# git clone https://github.com/pharcosyle/dotfiles
# guix environment --ad-hoc woof -- woof -U
# Important: `woof` didn't work for me over the local network, I had to have my other computer offer it over the public internet with localtunnel.

mkdir -p ~/.config/guix
cp ~/projects/dotfiles/ebullient/home/channels.scm ~/.config/guix
guix pull
hash guix

# Find the LUKS UUID to update it in the system config. Make sure to update in the dotfiles upstream later.
cryptsetup luksUUID $root_partition

cd ~/projects/dotfiles/ebullient
guix system --load-path=. init system/frostfire.scm /mnt
#+end_src
*** Post-installation
#+begin_src sh
# Reboot the system, take out the installation medium, and login as root when faced with a login prompt.

# Set the password for the root account.
passwd
# Set the password for my user.
my_user=pharcosyle
passwd $my_user

# Log out and log in to my user account.

# Grab my dotfiles again.

# Ensure my channels file is in `~/.config/guix` and update my channels.
guix pull

# Run a system reconfigure, home reconfigure, install manifests, and deploy `home-state.git`. Copy over all my old data.
#+end_src
* System
:PROPERTIES:
:tangle-dir+: /ebullient/system
:END:
** Components
:PROPERTIES:
:header-args+: :tangle (in-tangle-dir "components.scm")
:END:
#+begin_src scheme
(define-module (ebullient system components)
  #:use-module (guix build-system trivial)
  #:use-module ((guix modules) #:select (source-module-closure))
  #:use-module (guix gexp)
  #:use-module ((guix store) #:select (%default-substitute-urls))
  #:use-module (gnu bootloader)
  #:use-module (gnu bootloader grub)
  #:use-module ((gnu packages) #:select (specification->package))
  #:use-module ((gnu packages fonts) #:select (font-terminus))
  #:use-module ((gnu packages gnupg) #:select (guile-gcrypt))
  #:use-module ((gnu packages linux) #:select (brightnessctl))
  #:use-module ((gnu packages wm) #:select (sway))
  #:use-module (gnu services)
  #:use-module (gnu services base)
  #:use-module (gnu services desktop)
  #:use-module (gnu services nix)
  #:use-module (gnu services sound)
  #:use-module (gnu services xorg)
  #:use-module (gnu system)
  #:use-module (gnu system accounts)
  #:use-module (gnu system file-systems)
  #:use-module (gnu system keyboard)
  #:use-module (gnu system mapped-devices)
  #:use-module ((nongnu packages linux) #:select (linux linux-firmware broadcom-sta broadcom-bt-firmware))
  #:use-module ((nongnu system linux-initrd) #:select (microcode-initrd))
  #:use-module (rde features)
  #:use-module ((rde features linux) #:select (feature-pipewire))
  #:use-module ((rde features wm) #:select (feature-sway))
  #:use-module ((ice-9 match) #:select (match-lambda))
  #:use-module ((ice-9 rdelim) #:select (read-string))
  #:use-module ((srfi srfi-1) #:select (any remove iota))
  #:use-module (ebullient utils)
  #:export (barebones-os
            basics
            boot
            initial-services
            linux-nonfree
            disk-encryption
            stateless
            btrfs
            users
            gdm
            nix
            hidpi-console-font
            nonguix-substitutes
            macbook
            macbook-kbl
            wm
            sway-wm
            miscellany))
#+end_src
#+begin_src scheme
(define-syntax-rule (system-comp os field ...)
  (operating-system
    (inherit os)
    field ...))

(define-syntax define-system-comp
  (lambda (x)
    (syntax-case x ()
      ((_ (name arg ...) field ...)
       (with-syntax ((os (datum->syntax x 'os)))
         #'(define* (name os arg ...)
             (system-comp os field ...)))))))

(define (update-services services kind update-fn)
  (update-services*
   services
   (lambda (svc)
     (eq? (service-kind svc) kind))
   update-fn))
#+end_src
*** Barebones OS
#+begin_src scheme
(define barebones-os
  (operating-system
    (host-name #f)
    (timezone #f)
    (bootloader #f)
    (services '())
    (file-systems %base-file-systems)))
#+end_src
*** Basics
Other components may inherit ~keyboard-value~ so use this component early. At the time of this writing, nothing depends on the values of hostname, etc but I could see them being useful base values to have present early.
#+begin_src scheme
(define-system-comp (basics #:key host-name timezone locale keyboard-layout)
  (host-name host-name)
  (timezone timezone)
  (locale locale)
  (keyboard-layout keyboard-layout))
#+end_src
*** EFI Boot
#+begin_src scheme
(define-system-comp (boot #:key label target)
  (bootloader (bootloader-configuration
               (bootloader grub-efi-bootloader)
               (targets (list target))
               (timeout 1)
               (keyboard-layout (operating-system-keyboard-layout os))))
  (file-systems
   (cons* (file-system
            (device (file-system-label label))
            (mount-point target)
            (type "vfat"))
          (operating-system-file-systems os))))
#+end_src
*** Initial services
Other components may wish to modify the list of operating system services so use this in the component chain early.
#+begin_src scheme
(define (selective-desktop-services pipewire?)
  (remove (lambda (service)
            (member (service-kind service)
                    (append (list gdm-service-type
                                  screen-locker-service-type)
                            (if pipewire?
                                (list pulseaudio-service-type
                                      alsa-service-type)
                                '()))))
          %desktop-services))

(define-system-comp (initial-services #:key desktop? pipewire?)
  (services
   (append (if desktop?
               (selective-desktop-services pipewire?)
               %base-services)
           (operating-system-user-services os))))
#+end_src
*** Linux nonfree
#+begin_src scheme
(define-system-comp (linux-nonfree)
  (kernel linux)
  (initrd microcode-initrd)
  (firmware (cons* linux-firmware
                   (operating-system-firmware os))))
#+end_src
*** Disk encryption
#+begin_src scheme
(define* (disk-encryption os #:key source-uuid target encrypted-mount-points)
  (let ((encrypted-device (mapped-device
                           (source (uuid source-uuid))
                           (targets (list target))
                           (type luks-device-mapping))))
    (system-comp
     os
     (mapped-devices
      (cons* encrypted-device
             (operating-system-mapped-devices os)))
     (file-systems
      (map (lambda (fs)
             (if (member (file-system-mount-point fs) encrypted-mount-points)
                 (file-system
                   (inherit fs)
                   (dependencies (cons* encrypted-device
                                        (file-system-dependencies fs))))
                 fs))
           (operating-system-file-systems os))))))
#+end_src
*** Stateless
The stateless service should come after base/desktop services (potentially others as well) so its state gets installed before theirs during activation. To this end the ~stateless-service-type~ is appended, not prepended, to operating system services. It also modifies file systems so users of this component should include it at the end of their component chain.
#+begin_src scheme
(define-system-comp (stateless #:key persist-dir bluetooth?)
  (initrd (lambda (file-systems . rest)
            (apply (operating-system-initrd os) file-systems
                   #:volatile-root? #t
                   rest)))
  (file-systems
   (map (lambda (fs)
          (if (member (file-system-mount-point fs)
                      `("/var/guix" "/var/log" ,persist-dir))
              (file-system
                (inherit fs)
                (needed-for-boot? #t))
              fs))
        (operating-system-file-systems os)))
  (services
   (append
    (operating-system-user-services os)
    (list
     (service stateless-service-type
              `(#:persist-dir ,persist-dir
                #:paths ,(append
                          '("/etc/machine-id"
                            "/var/lib/random-seed"
                            "/etc/NetworkManager/system-connections"
                            "/var/lib/NetworkManager/secret_key"
                            "/etc/guix/signing-key.pub"
                            "/etc/guix/signing-key.sec")
                          (if bluetooth?
                              (list "/var/lib/bluetooth") '()))))))))
#+end_src
**** Service
#+begin_src scheme
(define save-or-restore-users+groups
  #~(lambda (persist-dir save-or-restore)
      (for-each (lambda (path)
                  (let ((files (list path (string-append persist-dir path))))
                    (apply copy-file (case save-or-restore
                                       ((#:restore) (reverse files))
                                       ((#:save) files)))))
                '("/etc/group"
                  "/etc/passwd"
                  "/etc/shadow"))))

(define (populate-gexp config)
  (with-extensions (list guile-gcrypt)
    (with-imported-modules (source-module-closure
                            '((gnu build install)))
      #~(begin
          (use-modules ((gnu build install) #:select (populate-root-file-system)))

          (define* (populate #:key persist-dir #:allow-other-keys)
            (let* ((system-path "/var/guix/profiles/system")
                   (system-1-path "/var/guix/profiles/system-1-link")
                   (system-1-exists? (file-exists? system-1-path))
                   (system-link (readlink system-path))
                   (system-1-link (if system-1-exists?
                                      (readlink system-1-path)
                                      system-link)))
              (populate-root-file-system system-1-link ""
                                         #:extras `((,system-path -> ,system-link)))
              (unless system-1-exists?
                (delete-file system-1-path)))
            (#$save-or-restore-users+groups persist-dir #:restore))

          (apply populate '#$config)))))

(define (activate-state-gexp config)
  #~(begin
      (use-modules ((ice-9 match) #:select (match)))

      (define* (activate-state #:key persist-dir paths)

        (define (install path)
          (let loop ((components (string-tokenize path (char-set-complement (char-set #\/))))
                     (base persist-dir)
                     (target-base ""))
            (match components
              ((head tail ...)
               (let* ((path (string-append base "/" head))
                      (target-path (string-append target-base "/" head)))
                 (if (null? tail)
                     ;; The Guix code makes a point of doing stuff like this atomically. I don't really know why but I will too.
                     (let ((pivot (string-append target-path ".new")))
                       (symlink path pivot)
                       (rename-file pivot target-path))
                     (begin
                       (catch 'system-error
                         (lambda ()
                           (mkdir target-path))
                         (lambda args
                           (unless (= EEXIST (system-error-errno args))
                             (apply throw args))))
                       (let ((st (lstat path)))
                         (chown target-path (stat:uid st) (stat:gid st))
                         (chmod target-path (stat:perms st)))
                       (loop tail path target-path))))))))

        (for-each install paths)
        (#$save-or-restore-users+groups persist-dir #:save))

      (apply activate-state '#$config)))

(define stateless-service-type
  (service-type (name 'stateless)
                (extensions
                 (list (service-extension boot-service-type
                                          populate-gexp)
                       (service-extension activation-service-type
                                          activate-state-gexp)))))
#+end_src
*** Btrfs file systems
#+begin_src scheme
(define-system-comp (btrfs #:key label subvols)
  (file-systems
   (append
    (map (match-lambda
           ((subvol mount-point)
            (file-system
              (device (file-system-label label))
              (mount-point mount-point)
              (type "btrfs")
              (options (string-append "subvol=" subvol ",compress=zstd,autodefrag")))))
         subvols)
    (operating-system-file-systems os))))
#+end_src
*** Users
#+begin_src scheme
(define* (account #:key name comment admin? password salt bluetooth?)
  (user-account
   (name name)
   (comment (or comment ""))
   (group "users")
   (supplementary-groups (append '("netdev" "audio" "video")
                                 (if admin? '("wheel") '())
                                 (if bluetooth? '("lp") '())))
   (password (if password
                 (crypt password salt)
                 #f))))

(define-system-comp (users #:key who bluetooth?)
  (users
   (append (map (lambda (user)
                  (apply account (append user `(#:bluetooth? ,bluetooth?))))
                who)
           (operating-system-users os))))
#+end_src
*** GDM display manager
#+begin_src scheme
(define-system-comp (gdm #:key auto-login)
  (services
   (cons* (service gdm-service-type
                   (gdm-configuration
                    (auto-login? (if auto-login #t #f))
                    (default-user auto-login)
                    (wayland? #t)))
          (operating-system-user-services os))))
#+end_src
*** HiDPI console font
#+begin_src scheme
(define-system-comp (hidpi-console-font)
  (services
   (update-services
    (operating-system-user-services os)
    console-font-service-type
    (lambda (config)
      (map (lambda (tty-and-font)
             (cons (car tty-and-font)
                   (file-append font-terminus "/share/consolefonts/ter-132n")))
           config)))))
#+end_src
*** Nonguix substitutes
At the time of this writing I've just added the new substitute server at nonguix.org. The brielmaier.net substitute server is probably obviated now but I'll keep it around becuase it doesn't hurt to have more sources for substitutes.
#+begin_src scheme
(define-system-comp (nonguix-substitutes)
  (services
   (update-services
    (operating-system-user-services os)
    guix-service-type
    (lambda (config)
      (guix-configuration
       (inherit config)
       (substitute-urls
        (append (guix-configuration-substitute-urls config)
                (list "https://substitutes.nonguix.org"
                      "https://mirror.brielmaier.net")))
       (authorized-keys
        (append (guix-configuration-authorized-keys config)
                (list (local-file "substitutes.nonguix.org.pub")
                      (local-file "mirror.brielmaier.net.pub")))))))))
#+end_src
**** Signing keys
***** substitutes.nonguix.org
#+begin_src scheme :tangle (in-tangle-dir "substitutes.nonguix.org.pub")
(public-key
 (ecc
  (curve Ed25519)
  (q #C1FD53E5D4CE971933EC50C9F307AE2171A2D3B52C804642A7A35F84F3A4EA98#)))
#+end_src
***** mirror.brielmaier.net
#+begin_src scheme :tangle (in-tangle-dir "mirror.brielmaier.net.pub")
(public-key
 (ecc
  (curve Ed25519)
  (q #7514F8D729DB1935470A581CE3851ED9FD6F1F9BAFE1D8BEC77A931ADB7A4337#)))
#+end_src
*** Macbook
I'm not sure if this requires [[Linux nonfree][Linux nonfree]] and/or if the blacklist refers to kernel modules that are only in the nonfree linux kernel (i.e., not linux-libre)
#+begin_src scheme
(define (with-blacklist kernel-args new)

  (define (blacklist? ka)
    (string-prefix? "modprobe.blacklist" ka))

  (if (any blacklist? kernel-args)
      (update-list kernel-args blacklist? (lambda (blacklist)
                                            (string-append blacklist "," new)))
      (cons* (string-append "modprobe.blacklist=" new) kernel-args)))

(define-system-comp (macbook #:key bluetooth?)
  (kernel-arguments (with-blacklist (operating-system-user-kernel-arguments os)
                                    "b43,b43legacy,ssb,bcm43xx,brcm80211,brcmfmac,brcmsmac,bcma"))
  (kernel-loadable-modules (cons* broadcom-sta
                                  (operating-system-kernel-loadable-modules os)))
  (firmware (append
             (if bluetooth? (list broadcom-bt-firmware) '())
             (operating-system-firmware os))))
#+end_src
**** Keyboard layout
#+begin_src scheme
(define macbook-kbl
  (keyboard-layout "us" #:model "macbook78"))
#+end_src
*** Window manager
#+begin_src scheme
(define-system-comp (wm #:key package services)
  (packages
   (cons* package
          (operating-system-packages os)))
  (services
   (append services
           (operating-system-user-services os))))
#+end_src
**** Sway
#+begin_src scheme
(define* (sway-wm os #:key laptop?)
  (wm os
      #:package sway
      #:services (append ((feature-system-services-getter (feature-sway)) (rde-config))
                         (if laptop?
                             (list (udev-rules-service 'backlight-add brightnessctl)) '()))))
#+end_src
*** Miscellany
nss-certs, Gnome, backlight control, Nix, bluetooth
#+begin_src scheme
(define-system-comp (miscellany #:key desktop? nix? pipewire? bluetooth?)
  (packages
   (cons* (specification->package "nss-certs")
          (operating-system-packages os)))
  (services
   (append
    (if desktop?
        (list (service gnome-desktop-service-type)) '())
    (if pipewire?
        ((feature-system-services-getter (feature-pipewire)) (rde-config)) '())
    (if nix?
        (list (service nix-service-type)) '())
    ;; (if bluetooth?
    ;;     (list (bluetooth-service #:auto-enable? #t)) '())
    (operating-system-user-services os))))
#+end_src
** Base OS
#+begin_src scheme :tangle (in-tangle-dir "base-os.scm") :noweb yes
(define-module (ebullient system base-os)
  #:use-module (ebullient system components)
  #:use-module (ebullient utils)
  #:export (base-os))

(define* (base-os #:key
                  host-name
                  (desktop? #t)
                  (laptop? #t)
                  macbook?
                  (disk-encryption? #t)
                  luks-uuid
                  (nix? #t)
                  (pipewire? desktop?)
                  (bluetooth? desktop?)
                  (aux-admin? #t)
                  (guest? laptop?))
  (-> barebones-os
      (basics #:host-name host-name
              #:timezone "America/Los_Angeles"
              #:locale "en_US.utf8"
              #:keyboard-layout (if macbook?
                                    macbook-kbl #f))
      (boot #:label "genesis"
            #:target "/boot/efi")
      (initial-services #:desktop? desktop?
                        #:pipewire? pipewire?)
      linux-nonfree
      (users #:who (append
                    '((#:name "<<user-name>>" #:comment "<<user-full-name>>" #:admin? #t))
                    (if aux-admin?
                        '((#:name "pcoulson" #:comment "Phil Coulson" #:admin? #t)) '())
                    (if guest?
                        '((#:name "gandalf" #:comment "Speak Friend and Enter" #:password "mellon" #:salt "toosimple")) '()))
             #:bluetooth? bluetooth?)
      (as-> $
        (if desktop?
            (-> $
                (gdm
                 ;; #:auto-login (if disk-encryption?
                 ;;                      "<<user-name>>" #f)
                 )
                (sway-wm #:laptop? laptop?)
                hidpi-console-font)
            $))
      nonguix-substitutes
      (as-> $
        (if macbook?
            (macbook $ #:bluetooth? bluetooth?) $))
      (miscellany #:desktop? desktop?
                  #:nix? nix?
                  #:pipewire? pipewire?
                  #:bluetooth? bluetooth?)
      (as-> $
        (let* ((persist-dir "/.persist")
               (subvols
                (append
                 `(("root-blank" "/")
                   ("boot" "/boot")
                   ("guix-store" "/gnu/store")
                   ("guix-var" "/var/guix")
                   ("log" "/var/log")
                   ("home" "/home")
                   ("persist" ,persist-dir))
                 (if nix? '(("nix" "/nix")) '()))))
          (-> $
              (btrfs #:label "firmament"
                     #:subvols subvols)
              (as-> $
                (if disk-encryption?
                    (disk-encryption $ #:source-uuid luks-uuid
                                     #:target "ciphered"
                                     #:encrypted-mount-points (map cadr subvols))
                    $))
              (stateless #:persist-dir persist-dir
                         #:bluetooth? bluetooth?))))))
#+end_src
** Hosts
:PROPERTIES:
:tangle-dir+: /hosts
:END:
*** Frostfire
#+begin_src scheme :tangle (in-tangle-dir "frostfire.scm") :noweb yes
(define-module (ebullient system hosts frostfire)
  #:use-module (ebullient system base-os)
  #:use-module (ebullient utils))

(define-public os
  (base-os #:host-name "frostfire"
           #:luks-uuid "<<frostfire-luks-uuid>>"
           #:macbook? #t))
#+end_src
**** LUKS UUID
- REVIEW ~source-uuid~ is a kind of generated state (it gets created on install), perhaps I should treat it specially, like e.g. a channels lockfile. Currently I'm just putting it in this special org block, review once I've figured out how I'm doing generated state (putting it in files, redirecting it into the org file itself...)
#+name: frostfire-luks-uuid
#+begin_src org
bdda56af-6ca0-4953-bc13-d5af8715e0e5
#+end_src
* Home
:PROPERTIES:
:tangle-dir+: /ebullient/home
:END:
#+name: guix-home-profile
#+begin_src sh
~/.guix-home/profile
#+end_src
#+name: guix-extra-profiles-path
#+begin_src sh
~/.guix-extra-profiles
#+end_src
** Components
:PROPERTIES:
:header-args+: :tangle (in-tangle-dir "components.scm")
:END:
#+begin_src scheme
(define-module (ebullient home components)
  #:use-module (guix gexp)
  ;; #:use-module (gnu home services)
  #:use-module (gnu home services shepherd)
  #:use-module (gnu home-services shells)
  #:use-module ((gnu packages freedesktop) #:select (udiskie))
  #:use-module ((gnu packages xdisorg) #:select (gammastep))
  #:use-module (gnu services)
  ;; #:use-module (gnu services configuration)
  #:use-module (gnu services shepherd)
  #:use-module (rde features)
  #:use-module ((rde features linux) #:select (feature-pipewire))
  #:use-module ((rde features wm) #:select (feature-sway))
  #:use-module (ebullient utils)
  #:export (pipewire-services
            sway-services
            gammastep-service-type
            udiskie-service-type))

(define serialize-posix-env-vars (@@ (gnu home-services shells) serialize-posix-env-vars))
#+end_src
*** Pipewire
#+begin_src scheme
(define (update-pipewire-shepherd-daemons services)
  (update-services*
   services
   (lambda (svc)
     (eq? (-> svc service-kind service-type-name) 'pipewire-add-shepherd-daemons))
   (lambda (shepherd-services)
     (as-> shepherd-services $
       (map (lambda (svc)
              (shepherd-service
               (inherit svc)
               (auto-start? #f)))
            $)
       (update-list
        $
        (lambda (svc)
          (equal? (shepherd-service-provision svc) '(pipewire)))
        (lambda (svc)
          (shepherd-service
           (inherit svc)
           (requirement '()))))))))

(define pipewire-services
  (update-pipewire-shepherd-daemons
   ((feature-home-services-getter (feature-pipewire)) (rde-config))))
#+end_src
*** Sway
#+begin_src scheme
(define (sway-env-vars env-vars)
  (simple-service 'set-sway-env-vars
                  home-bash-service-type
                  (home-bash-extension
                   (bash-profile
                    (list "if [[ \"$DESKTOP_SESSION\" = \"\" || \"$DESKTOP_SESSION\" = \"sway\" ]] ; then"
                          (serialize-posix-env-vars #f env-vars)
                          "fi")))))

(define (conditionalize-sway-env-vars services)
  (define env-vars)
  (as-> services $
    (update-services*
     $
     (lambda (svc)
       (eq? (-> svc service-kind service-type-name) 'set-wayland-specific-env-vars))
     (lambda (vars)
       (set! env-vars vars)
       '()))
    (cons* (sway-env-vars env-vars) $)))

(define sway-services
  (conditionalize-sway-env-vars
   ((feature-home-services-getter
     (feature-sway #:xwayland? #t
                   #:sway-mod 'Mod1
                   #:extra-config
                   ;; `((include ,(file-append (@ (gnu packages wm) sway) "/etc/sway/config")))
                   ;; `((include ,(local-file "./config/sway/config")))
                   `((include "/home/pharcosyle/projects/dotfiles/config"))))
    (rde-config))))
#+end_src
*** "Apps" or "User daemons" or something
**** Gammastep
#+begin_src scheme
(define (gammastep-shepherd-service _)
  (list
   (shepherd-service
    (provision '(gammastep))
    (start #~(make-forkexec-constructor
              (list #$(file-append gammastep "/bin/gammastep-indicator"))))
    (stop #~(make-kill-destructor))
    (auto-start? #f))))

(define gammastep-service-type
  (service-type (name 'home-gammastep)
                (extensions
                 (list (service-extension
                        home-shepherd-service-type
                        gammastep-shepherd-service)))
                (default-value #f)))
#+end_src
**** Udiskie
#+begin_src scheme
(define (udiskie-shepherd-service _)
  (list
   (shepherd-service
    (provision '(udiskie))
    (start #~(make-forkexec-constructor
              (list #$(file-append udiskie "/bin/udiskie --tray"))))
    (stop #~(make-kill-destructor))
    (auto-start? #f))))

(define udiskie-service-type
  (service-type (name 'home-udiskie)
                (extensions
                 (list (service-extension
                        home-shepherd-service-type
                        udiskie-shepherd-service)))
                (default-value #f)))
#+end_src
** Solitude
#+begin_src scheme :tangle (in-tangle-dir "solitude.scm") :noweb yes
(define-module (ebullient home solitude)
  #:use-module (guix gexp)
  #:use-module (gnu home)
  #:use-module (gnu home services)
  #:use-module (gnu home services mcron)
  #:use-module (gnu home services xdg)
  #:use-module (gnu home-services shells)
  #:use-module (gnu home-services shellutils)
  ;; #:use-module (gnu home-services gnupg)
  #:use-module (gnu home-services ssh)
  #:use-module (gnu home-services version-control)
  #:use-module (gnu home-services-utils)
  #:use-module (gnu packages)
  ;; #:use-module (gnu packages admin)
  ;; #:use-module (gnu packages gnupg)
  ;; #:use-module (gnu packages linux)
  #:use-module (gnu services)
  ;; #:use-module (gnu system keyboard)


  #:use-module ((rde features shells) #:select (feature-zsh))


  #:use-module ((guix packages) #:select (package-input-rewriting))
  #:use-module ((gnu packages emacs) #:select (emacs emacs-minimal emacs-no-x))
  #:use-module ((flat packages emacs) #:select (emacs-native-comp))


  #:use-module (ebullient home doom-emacs-temp)


  #:use-module (ebullient home components)


  #:use-module (rde features)


  #:export (solitude))

;; (define emacs-variant emacs-native-comp)
(define emacs-variant emacs)

;; TODO Guix Home has an emacs service with a parameter `rebuild-elisp-packages?` that accomplishes I think the same thing as this but it's based on `substitute-keyword-arguments` instead of `package-input-rewriting`. How doe these approaches compare? Update: actually my approach won't do transitive dependencies (and maybe emacs argument like e.g. exwm has?) so it's pretty flawed. Doesn't matter though, I'm not going to be using the guix emacs packages, right?
(define with-emacs-variant
  (package-input-rewriting `((,emacs . ,emacs-variant)
                             (,emacs-minimal . ,emacs-variant)
                             (,emacs-no-x . ,emacs-variant))))

(define solitude
  (home-environment
   (packages (list (specification->package "font-adobe-source-code-pro") ; TODO (propagated) dependency of Doom config, move it somewhere when I figure out how I'm doing Emacs/Doom guix configuration.
                   (specification->package "font-awesome") ; TODO for waybar, move this somewhere later
                   (specification->package "font-google-noto") ; TODO for sway (or any non-DE probably)
                   ;; emacs-variant ; TODO add this back when I can do so without eating up all my inodes (update: or do I want it in a manifest instead? Or better yet, since [if I recall] the only thing I needed the "direct" access to the emacs program for was running `doom upgrade` just make it a non-propagated input to my eventual Doom guix package. That is, if I even end up running `doom upgrade` after packaging Doom). Also delete bastille manifest
                   (with-emacs-variant doom-emacs-temp)))
   (services
    (append
     (list
      (service home-bash-service-type
               (home-bash-configuration
                (environment-variables
                 `(("VISUAL" . ,(file-append emacs-variant "/bin/emacsclient"))
                   ("EDITOR" . "$VISUAL")))
                (bash-profile
                 `(,(slurp-file-gexp (local-file "bash_profile")))))))
     (filter service?
             ((feature-home-services-getter (feature-zsh)) (rde-config)))
     (list
      (simple-service 'zsh-config
                      home-zsh-service-type
                      (home-zsh-extension
                       (zshrc
                        (list (slurp-file-gexp (local-file "zshrc"))))))
      (service home-zsh-direnv-service-type)

      (service home-xdg-user-directories-service-type
               (let* ((xdg-user-subdir "/files")
                      (xdg-dir (lambda (path)
                                 (string-append "$HOME" xdg-user-subdir path))))
                 (home-xdg-user-directories-configuration
                  (desktop "$HOME/desktop")
                  (documents (xdg-dir "/docs"))
                  (download "$HOME/dl")
                  (music (xdg-dir "/music"))
                  (pictures (xdg-dir "/pics"))
                  (publicshare (xdg-dir "/public"))
                  (templates (xdg-dir "/templates"))
                  (videos (xdg-dir "/vids")))))

      (service home-mcron-service-type
               (home-mcron-configuration
                (jobs
                 (list
                  #~(job '(next-hour)
                         (lambda ()
                           (call-with-output-file "/tmp/test-mcron-file"
                             (lambda (port)
                               (display "Output!" port))))
                         "Test mcron output")))))
      (service home-git-service-type
               (home-git-configuration
                (config
                 `((user
                    ((name . "<<user-full-name>>")
                     (email . "<<user-email>>")))
                   ;; (http "https://weak.example.com"
                   ;;   ((ssl-verify . #f)))
                   ;; (gpg
                   ;;  ((program . ,(file-append gnupg "/bin/gpg"))))
                   ;; (sendmail
                   ;;  ((annotate . #t)))
                   ))))
      (service home-ssh-service-type
               ;; (home-ssh-configuration
               ;;  (extra-config
               ;;   (list
               ;;    (ssh-host "savannah"
               ;;              '((compression . #f))))))
               )
      (simple-service 'nix-channels
                      home-files-service-type
                      (list `("nix-channels"
                              ,(local-file "nix-channels"))))
      (simple-service 'nixpkgs-config
                      home-files-service-type
                      (list `("config/nixpkgs/config.nix"
                              ,(local-file "nixpkgs-config.nix"))))
      (simple-service 'doomdir
                      home-files-service-type
                      (list `("config/doom"
                              ,(local-file "doom" #:recursive? #t))))
      ;; TODO I think this was my abortive attempt to customize the fonts service
      ;; (simple-service 'my-fontconfig-config-file
      ;;                 home-files-service-type
      ;;                 (list `("config/fontconfig/fonts.conf"
      ;;                         ,(plain-file "fonts.conf" %my-fontconfig-config-file))))
      ;; TODO Examples from RDE I may want to make use of.
      ;; (service home-keyboard-service-type
      ;;          (keyboard-layout "us,ru" "dvorak,"
      ;;                           #:options '("grp:win_space_toggle" "ctrl:nocaps")))
      ;; (service home-gnupg-service-type
      ;;          (home-gnupg-configuration
      ;;           (gpg-agent-config
      ;;            (home-gpg-agent-configuration
      ;;             (ssh-agent? #t)))))
      ;; (service home-state-service-type
      ;;          (append
      ;;           (list
      ;;            (state-rsync "/home/bob/tmp/example-rsync-state/"
      ;;                         "abcdw@olorin.lan:/var/services/homes/abcdw/tmp-state/")
      ;;            (state-git "/home/bob/tmp/talkes/"
      ;;                       "git@git.sr.ht:~abcdw/rde"))))
      )
     pipewire-services
     sway-services

     (list
      (service gammastep-service-type)
      (service udiskie-service-type))))))
#+end_src
#+begin_src sh :results output silent :dir base-tangle-dir :async
guix home --load-path=. --expression='(@ (ebullient home solitude) solitude)' reconfigure
#+end_src
** Shells
*** Bash profile
:PROPERTIES:
:header-args+: :tangle (in-tangle-dir "bash_profile")
:END:
**** Use Guix extra profiles
#+begin_src sh :noweb yes
gepp="<<guix-extra-profiles-path>>"
GUIX_EXTRA_PROFILES="${gepp/#\~/$HOME}"

for i in $GUIX_EXTRA_PROFILES/*; do
  profile=$i/$(basename "$i")
  if [ -f "$profile"/etc/profile ]; then
    GUIX_PROFILE="$profile"
    . "$GUIX_PROFILE"/etc/profile
  fi

  # Emulate guix-home setup-environment file (and thus `/etc/profile` as well). Regarding MANPATH and INFOPATH in particular, see https://guix.gnu.org/en/cookbook/en/guix-cookbook.html#Required-packages
  case $XDG_DATA_DIRS in
    ,*"$profile"/share*) ;;
    ,*) export XDG_DATA_DIRS="$profile"/share:$XDG_DATA_DIRS ;;
  esac
  case $MANPATH in
    ,*"$profile"/share/man*) ;;
    ,*) export MANPATH="$profile"/share/man:$MANPATH
  esac
  case $INFOPATH in
    ,*"$profile"/share/info*) ;;
    ,*) export INFOPATH="$profile"/share/info:$INFOPATH ;;
  esac
  case $XDG_CONFIG_DIRS in
    ,*"$profile"/etc/xdg*) ;;
    ,*) export XDG_CONFIG_DIRS="$profile"/etc/xdg:$XDG_CONFIG_DIRS ;;
  esac
  case $XCURSOR_PATH in
    ,*"$profile"/share/icons*) ;;
    ,*) export XCURSOR_PATH="$profile"/share/icons:$XCURSOR_PATH ;;
  esac

  unset profile
done
#+end_src
**** Load Nix environment
#+begin_src sh
if [ -f /run/current-system/profile/etc/profile.d/nix.sh ]; then
  . /run/current-system/profile/etc/profile.d/nix.sh
fi
#+end_src
**** Make Flatpak apps visible
#+begin_src sh
export XDG_DATA_DIRS=$HOME/.local/share/flatpak/exports/share:$XDG_DATA_DIRS
#+end_src
*** Zshrc
:PROPERTIES:
:header-args+: :tangle (in-tangle-dir "zshrc")
:END:
**** History
#+begin_src sh
HISTSIZE=1000000
SAVEHIST=$HISTSIZE
#+end_src
** Guix extra profiles
:PROPERTIES:
:tangle-dir+: /manifests
:END:
#+name: install-profiles
#+begin_src sh :results output silent :dir (get-tangle-dir) :noweb yes :async
gepp="<<guix-extra-profiles-path>>"
GUIX_EXTRA_PROFILES="${gepp/#\~/$HOME}"

profiles=$*
if [[ $# -eq 0 ]]; then
    profiles="*";
fi

for profile in $profiles; do
  profileName=$(basename $profile .scm)
  profilePath="$GUIX_EXTRA_PROFILES/$profileName"
  mkdir -p $profilePath
  guix package --profile="$profilePath/$profileName" --manifest="$profileName.scm"
done
#+end_src
#+call: install-profiles[:cmdline ...]()

#+name: upgrade-profiles
#+begin_src sh :results output silent :noweb yes :async
gepp="<<guix-extra-profiles-path>>"
GUIX_EXTRA_PROFILES="${gepp/#\~/$HOME}"

profiles=$*
if [[ $# -eq 0 ]]; then
    profiles="$GUIX_EXTRA_PROFILES/*";
fi

for profile in $profiles; do
  profileName=$(basename $profile)
  profilePath="$GUIX_EXTRA_PROFILES/$profileName"
  guix package --profile="$profilePath/$profileName" --manifest="$profileName.scm"
done
#+end_src
#+call: upgrade-profiles[:cmdline ...]()
*** Manifests
#+name: guix-extra-profile-path
#+begin_src sh :var profileName="" :noweb yes
echo "<<guix-extra-profiles-path>>/$profileName/$profileName"
#+end_src
**** multiverse
#+begin_src scheme :tangle (in-tangle-dir "multiverse.scm")
(specifications->manifest
 '("btrfs-progs" ; TODO "depends on"/"exists because of" the stateless module. Maybe it should be in some "system administration" section of Home config

   ;; "protonvpn-cli" ; REVIEW Appears to be broken after the big Guix frozen-updates upgrade.

   ;; Chromium
   "ungoogled-chromium-wayland"
   "ublock-origin-chromium"

   ;; Flatpak
   "flatpak"
   "xdg-desktop-portal"
   "xdg-desktop-portal-wlr"

   ;; General
   "xdg-utils"
   "gtk+:bin"
   "curl"
   "zip"
   "unzip"

   ;; Nice-to-have ; TODO might get rid of these and just `guix shell' or install as-needed
   "tree"
   "woof"

   ;; Apps
   ;; "gimp" ; TODO maybe. Or just install as-needed with `guix shell`
   ))
#+end_src
#+begin_src elisp :noweb-ref guix-extra-profiles :noweb-sep " " :noweb yes
"<<guix-extra-profile-path("multiverse")>>"
#+end_src
**** bastille
#+begin_src scheme :tangle (in-tangle-dir "bastille.scm")
;; TODO Getting rid of this (either putting it in "multiverse" manifest or in solitude). Make it a reference to emacs-variant.
(specifications->manifest
 '("emacs-29-pgtk-native-comp"))
#+end_src
#+begin_src elisp :noweb-ref guix-extra-profiles :noweb-sep " " :noweb yes
"<<guix-extra-profile-path("bastille")>>"
#+end_src
**** clojure manifest WIP
#+begin_src scheme
(specifications->manifest
 '("clojure-tools" ; TODO comes from nonguix channel, I might be making that explicit later
   "icedtea" ; For clojure-tools ; TODO can I make this a non-propagated input to "clojure-tools" (`substitute*' or `wrap-program'? Automatic in some way?) or is that a bad idea / a pain?
   "clj-kondo")) ; TODO comes from nonguix channel, I might be making that explicit later
#+end_src
** Nix
*** Nix channels
#+begin_src conf :tangle (in-tangle-dir "nix-channels")
https://nixos.org/channels/nixpkgs-unstable nixpkgs
#+end_src
*** Nixpkgs config
#+begin_src nix :tangle (in-tangle-dir "nixpkgs-config.nix")
{ allowUnfree = true; }
#+end_src
*** WIP Nix
Ran this manually but it ought to be done either programmatically by Guix Home (either imperatively or add a home-files-service to a symlink, if that's possible)
#+begin_src sh
ln -s "/nix/var/nix/profiles/per-user/$USER/profile" ~/.nix-profile
#+end_src
** WIP Flatpak
Ran these manually
#+begin_src sh
flatpak remote-add --user --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo

flatpak install --user flathub com.spotify.Client
flatpak install --user flathub us.zoom.Zoom
#+end_src
** Doom
:PROPERTIES:
:tangle-dir+: /doom
:END:
*** Init
#+begin_src elisp :tangle (in-tangle-dir "init.el")
;;; -*- lexical-binding: t; -*-
(doom! :completion
       company
       (ivy +icons)

       :ui
       doom
       doom-dashboard
       (emoji +unicode)
       hl-todo
       hydra
       indent-guides
       (ligatures +extra)
       modeline
       nav-flash
       ophints
       (popup +defaults +all)
       treemacs
       vc-gutter
       vi-tilde-fringe
       window-select
       workspaces

       :editor
       (evil +everywhere)
       file-templates
       fold
       format
       lispy
       multiple-cursors
       rotate-text
       snippets
       word-wrap

       :emacs
       (dired +icons)
       electric
       (ibuffer +icons)
       undo
       vc

       :term
       eshell
       vterm

       :checkers
       syntax

       :tools
       direnv
       (eval +overlay)
       lookup
       (magit +forge)
       (pass +auth)
       pdf
       prodigy
       rgb
       taskrunner

       :lang
       clojure
       data
       emacs-lisp
       json
       javascript
       markdown
       (org +journal)
       rest
       (scheme +guile)
       sh
       web
       yaml ; TODO this should probably be specific to the krush/hyperdrive/afterburner(?) project

       :app
       calendar

       :config
       (default +bindings +smartparens))
#+end_src
*** Config
:PROPERTIES:
:header-args+: :tangle (in-tangle-dir "config.el")
:END:
**** Header
#+begin_src elisp
;;; -*- lexical-binding: t; -*-
#+end_src
**** Requires
#+begin_src elisp
(use-package! dash)
#+end_src
**** Personal Info :user:
#+begin_src elisp :noweb yes
(setq user-full-name "<<user-full-name>>"
      user-mail-address "<<user-email>>")
#+end_src
**** Locals :path:
#+begin_src elisp
(defconst biome--org-dir (concat org-directory "~/org"))
(defconst biome--org-gcal-dir (concat biome--org-dir "/gcal"))

(defconst biome--very-big 1000000)
#+end_src
**** General :UI:path:
#+begin_src elisp
;; hlissner says this must be set before org loads. I'm not sure if this is a requirement of org-mode but the Doom org config certainly does a lot of gymnastics with this variable so I'll just set this exactly like the example config does.
(setq org-directory biome--org-dir)

(setq scroll-margin 10
      save-interprogram-paste-before-kill t)

;; I like having line numbers on but hlissner says they're slow so I might want to disable them at some point. Keep in mind I use them to determine what lines are continuation lines so I might have to make the right fringe bigger if I do this and set visual-line-fringe-indicators.
;; (setq display-line-numbers-type nil)
#+end_src
***** Doom resets
#+begin_src elisp
(setq-default indent-tabs-mode t)

;; I'd like to have this on but in the Doom code it says it's more efficient not to.
;; (setq-default cursor-in-non-selected-windows t)
#+end_src
**** Doom
***** UI :UI:theming:
#+begin_src elisp
(setq doom-theme 'doom-nuclear
      doom-font (font-spec :family "Source Code Pro" :size 12))
#+end_src
***** Leader/Localleader :bindings:
#+begin_src elisp
(setq doom-leader-alt-key "s-SPC"
      doom-localleader-key "s-m"
      doom-localleader-alt-key "s-m")
#+end_src
**** Keybindings :bindings:
#+begin_src elisp
(setq help-char (string-to-char "\C-_"))
#+end_src
***** Translations
#+begin_src elisp
(defun biome--trans (&rest rest)
  (-each (-partition 2 rest)
    (-lambda ((to from))
      (define-key key-translation-map (kbd to) (kbd from)))))

(biome--trans "C-h" "DEL"
              "C-?" "C-h"

              "s-i" "<tab>"
              "s-I" "<backtab>"

              "s-h" "<left>"
              "s-j" "<down>"
              "s-k" "<up>"
              "s-l" "<right>")
#+end_src
***** General
#+begin_src elisp
(defalias 'original-yank-pop #'yank-pop)

;; REVIEW Some of these should be in `:after' (or their respective package) sections but I'm not totally certain where I want to put bindings yet and I'm lazy.
(map! "s-V" #'original-yank-pop

      "s-SPC" doom-leader-map

      ;; Copied from Doom macOS bindings: ~/.config/emacs/modules/config/default/config.el:263
      "s-`" #'other-frame
      "s-n" #'+default/new-buffer
      "s-z" #'undo
      "s-Z" #'redo
      "s-c" (if (featurep 'evil) #'evil-yank #'copy-region-as-kill)
      "s-v" #'yank
      "s-s" #'save-buffer
      "s-x" #'execute-extended-command
      ;; REVIEW I don't think I need this, any time I'm in visual mode I can use `evil-delete` ("d")
      ;; :v "s-x" #'kill-region
      "s-/" (cmd! (save-excursion (comment-line 1)))
      :n "s-/" #'evilnc-comment-or-uncomment-lines
      :v "s-/" #'evilnc-comment-operator

      "s-t" (lookup-key doom-leader-map (kbd "`"))
      "s-f" (cl-flet ((f (lookup-key doom-leader-map (kbd "s b"))))
              ;; `swiper' hangs initially when `visual-line-mode' is active. Plus Doom defaults to having `visual-line-mode' enabled in text-mode (and derived) buffers where it makes more sense to not search linewise.
              (cmd! (if visual-line-mode
                        (letf! ((#'swiper #'swiper-isearch))
                          (f))
                      (f))))
      "s-r" (lookup-key doom-leader-map (kbd "f r"))
      "s-w" (lookup-key doom-leader-map (kbd "b k"))
      "s-d w" (lookup-key doom-leader-map (kbd "w d"))
      "s-d s-w" (cmd! (kill-current-buffer)
                      (+workspace/close-window-or-workspace))
      "s-g" (lookup-key doom-leader-map (kbd "g g"))
      "s-," (lookup-key doom-leader-map (kbd "w w"))
      "s-<" (lookup-key doom-leader-map (kbd "w W"))
      "s-y" (lookup-key doom-leader-map (kbd "i y"))
      "s-{" (lookup-key doom-leader-map (kbd "b p"))
      "s-}" (lookup-key doom-leader-map (kbd "b n"))
      "s-p" (lookup-key global-map (kbd "C-~")) ; TODO if I'm keeping this, improve it to first switch focus to a/the popup window if one isn't focused already

      "s-u" (lookup-key doom-leader-map (kbd "u"))
      "s-U" #'negative-argument         ; Trying this out.
      (:map universal-argument-map
       "s-u" #'universal-argument-more)

      (:after evil-easymotion
       "s-a" (lookup-key evilem-map (kbd "SPC")))

      "s-." #'repeat

      "s-J" #'evil-scroll-down
      "s-K" #'evil-scroll-up

      (:prefix "s-d"
       "." #'repeat-complex-command

       "h" #'git-gutter:popup-hunk
       ;; "o" #'+macos/open-in-default-program ;; TODO consider a Guix alternative? Meh.
       "r" #'projectile-replace
       "t" #'tldr
       "s" #'org-save-all-org-buffers
       "a" #'link-hint-open-multiple-links
       ;; "b" (cmd! (evil-local-mode 'toggle)
       ;;           (when evil-local-mode (evil-normal-state)))
       (:prefix "c"
        "f" #'org-gcal-fetch
        "s" #'org-gcal-sync
        "p" #'org-gcal-post-at-point)))
#+end_src
**** Packages
***** all-the-icons-dired
#+begin_src elisp
(after! all-the-icons-dired
  (setq all-the-icons-dired-monochrome nil))
#+end_src
***** avy
#+begin_src elisp
;; REVIEW Trying out not having this so I can use avy dispatch commands.
;; (after! avy
;;   (setq avy-single-candidate-jump t))
#+end_src
***** clojure :lang:clojure:bindings:
#+begin_src elisp
(use-package! clojure-mode
  :defer t
  :init
  (setq clojure-refactor-map-prefix (kbd "s-M r")) ; Has to be set before clojure-mode loads. ; TODO temporary binding
  :config
  (set-ligatures! 'clojure-mode :lambda "fn"))
#+end_src
***** cider :lang:clojure:persistence:
#+begin_src elisp
(after! cider
  (setq cider-repl-history-size biome--very-big
        cider-print-options '(("length" 100))))

;; TODO make sure this is still working after nesting in `after!'
(after! cider-repl
  (add-hook! 'cider-repl-mode-hook
             #'goto-address-prog-mode
             #'highlight-numbers-mode
             #'rainbow-delimiters-mode
             #'yas-minor-mode-on
             #'biome-sp-strict-h))
#+end_src
***** clj-refactor :lang:clojure:bindings:
#+begin_src elisp
(after! clj-refactor
  (cljr-add-keybindings-with-prefix "s-M R")) ; TODO temporary binding
#+end_src
***** counsel :completion:UI:
#+begin_src elisp
(after! counsel
  (setq counsel-yank-pop-separator "\n--------------------------------\n"))
#+end_src
***** doom-modeline :UI:
#+begin_src elisp
(after! doom-modeline
  ;; (setq doom-modeline-checker-simple-format nil)
  (setq doom-modeline-major-mode-icon t)
  (setq doom-modeline-persp-name t))
#+end_src
***** doom-themes :UI:
#+begin_src elisp
;; TODO get rid of this if I'm not going to try it out again
;; (after! doom-themes
;;   (doom-themes-visual-bell-config))
#+end_src
***** emacs-lisp :lang:
#+begin_src elisp
(after! elisp-mode
  (setq-hook! 'emacs-lisp-mode-hook indent-tabs-mode nil))
#+end_src
***** emojify :UI:
#+begin_src elisp
(after! emojify
  (setq emojify-display-style 'unicode))
#+end_src
***** eshell :persistence:
#+begin_src elisp
(after! eshell
  (setq eshell-history-size biome--very-big)) ; Setting this to `nil' to inherit envvar HISTSIZE is another option.
#+end_src
***** evil :UI:theming:
#+begin_src elisp
(after! evil
  (setq evil-default-cursor (lambda () (evil-set-cursor-color "#fdd94a"))
        evil-emacs-state-cursor (lambda () (evil-set-cursor-color "#ff9999"))))
#+end_src
***** evil-org :org:bindings:
#+begin_src elisp
(after! evil-org
  (map! :map evil-org-mode-map
        :nv "C-j" #'outline-forward-same-level
        :nv "C-k" #'outline-backward-same-level))
#+end_src
***** evil-multiedit
#+begin_src elisp
(after! evil-multiedit
  (setq evil-multiedit-follow-matches t))
#+end_src
***** expand-region :bindings:
#+begin_src elisp
(use-package! expand-region
  :defer t
  :init
  (map! :nv "s-e" #'er/expand-region
        :nv "s-E" #'er/contract-region)
  :config
  (setq expand-region-fast-keys-enabled nil) ; My mapping is conventient enough and I don't want the repeat key to conflict with anything.
  ;; Copied from Doom config: ~/.config/emacs/modules/config/default/+emacs.el:12
  (defadvice! biome--quit-expand-region-a (&rest _)
    "Properly abort an expand-region region."
    :before '(evil-escape doom/escape)
    (when (memq last-command '(er/expand-region er/contract-region))
      (er/contract-region 0))))
#+end_src
***** geiser :persistence:path:guix:
#+begin_src elisp
(use-package! geiser
  :defer t
  :init
  ;; It seems like it would be okay to not set variables in `:init' but hlissner does it this way for the Geiser package so I will too.
  (setq geiser-repl-current-project-function #'ignore) ; Reset this back to its default (don't have separate REPLs for projects) because it doesn't play nice with the Guix store.
  (setq geiser-repl-history-filename (concat doom-cache-dir "geiser-history")))
#+end_src
***** highlight-indent-guides :lang:prog_mode:UI:
#+begin_src elisp
(use-package! highlight-indent-guides
  :defer t
  :init
  ;; I don't want indent guides on by default, remove all the Doom module's hooks.
  (remove-hook! '(prog-mode-hook
                  text-mode-hook
                  conf-mode-hook)
    #'highlight-indent-guides-mode))
#+end_src
***** ivy :completion:bindings:UI:
#+begin_src elisp
(after! ivy
  (setq +ivy-buffer-preview t
        ivy-extra-directories nil
        ivy-count-format "(%d/%d) ")
  (dolist (i '(counsel-yank-pop
               counsel-evil-registers))
    (add-to-list 'ivy-height-alist `(,i . 10)))

  (map! :map ivy-minibuffer-map
        "s-J" #'ivy-scroll-up-command
        "s-K" #'ivy-scroll-down-command
        "C-r" #'ivy-reverse-i-search ; Doom overrides this, restore it.
        :map ivy-reverse-i-search-map
        "C-k" #'previous-line
        "s-D" #'ivy-reverse-i-search-kill)) ; TODO temporary binding
#+end_src
***** ivy-hydra :completion:bindings:
#+begin_src elisp
(after! ivy-hydra
  (defhydra+ hydra-ivy ()
    ;; Doom overrides these imporant ivy hydra heads: ~/.config/emacs/modules/completion/ivy/autoload/hydras.el
    ("m" ivy-mark)
    ("u" ivy-unmark)
    ("t" ivy-toggle-marks)))
#+end_src
***** lispy :lisp:
#+begin_src elisp
(use-package! lispy
  :defer t
  :init
  ;; Not using lispy, remove all the Doom module's hooks.
  (remove-hook! '(lisp-mode-hook
                  emacs-lisp-mode-hook
                  ielm-mode-hook
                  scheme-mode-hook
                  racket-mode-hook
                  hy-mode-hook
                  lfe-mode-hook
                  dune-mode-hook
                  clojure-mode-hook
                  fennel-mode-hook)
    #'lispy-mode)
  (remove-hook! 'eval-expression-minibuffer-setup-hook #'doom-init-lispy-in-eval-expression-h))
#+end_src
***** lispyville :lisp:lang:prog_mode:bindings:
#+begin_src elisp
(use-package! lispyville
  :hook (prog-mode . lispyville-mode)
  :init
  (setq lispyville-key-theme nil) ; Prevent Doom module's invocation of `lispyville-set-key-theme' from doing anything.
  :config
  (lispyville-set-key-theme
   '(operators
     c-w
     c-u
     commentary))
  (map! :map lispyville-mode-map
        "s-C-j" #'lispyville-beginning-of-next-defun
        "s-C-k" #'lispyville-beginning-of-defun
        "s-C-," #'lispyville-end-of-defun
        "s-C-a" #'lispyville-drag-backward
        "s-C-g" #'lispyville-drag-forward
        "s-C-p" #'lispyville-prettify
        (:prefix "s-C-;"
         "R" #'lispyville-raise-list)))
#+end_src
***** magit :UI:
#+begin_src elisp
(after! magit
  (setq git-commit-style-convention-checks '(non-empty-second-line))
  (setq magit-revision-show-gravatars '("^Author:     " . "^Commit:     ")))
#+end_src
***** man :guix:
#+begin_src elisp :noweb yes
(after! man
  (prependq! Man-header-file-path
             (-concat (-map (lambda (p)
                              (concat p "/include"))
                            '(<<guix-extra-profiles>>))
                      '("<<guix-home-profile>>/include"))))
#+end_src
***** org :org:UI:path:
#+begin_src elisp
(after! org
  (setq org-agenda-files `(,biome--org-dir
                           ,biome--org-gcal-dir
                           ,(concat biome--org-dir "/projects"))
        org-log-done 'time
        org-priority-lowest ?E
        org-priority-default ?C
        org-priority-faces `((?A . ,(doom-color 'red))
                             (?B . ,(doom-color 'orange))
                             (?C . ,(doom-color 'blue))
                             (?D . ,(doom-color 'yellow))
                             (?E . ,(doom-color 'green)))))
#+end_src
***** org-gcal :user:secret:persistence:path:
#+begin_src elisp
(after! org-gcal
  (setq org-gcal-client-id "446729771716-pp79934q99aro2h8v3iki1fejcodbdoo.apps.googleusercontent.com"
        org-gcal-client-secret (-> (auth-source-search :host org-gcal-client-id) car (plist-get :secret) funcall)
        org-gcal-fetch-file-alist `((user-mail-address . ,(concat biome--org-gcal-dir "/" user-mail-address ".org"))
                                    ("addressbook%23contacts@group.v.calendar.google.com" . ,(concat biome--org-gcal-dir "/contacts.org"))
                                    ("en.usa%23holiday@group.v.calendar.google.com" . ,(concat biome--org-gcal-dir "/holidays.org")))
        org-gcal-recurring-events-mode 'nested))
#+end_src
***** org-persist :persistence:path:
#+begin_src elisp
(use-package! org-persist
  :defer t
  :init
  (setq org-persist-directory (concat doom-cache-dir "org-persist/")))
#+end_src
***** paren :UI:
#+begin_src elisp
(after! paren
  (setq! show-paren-delay 0))
#+end_src
***** prog-mode :lang:prog_mode:
#+begin_src elisp
(add-hook! 'prog-mode-hook #'biome-sp-strict-h)
#+end_src
***** rainbow-delimiters :UI:theming:
#+begin_src elisp
(after! rainbow-delimiters
  (setq rainbow-delimiters-max-face-count 8)) ; TODO make sure this is working and I didn't need to put it in an `:init'`or anything
#+end_src
***** recentf :persistence:
#+begin_src elisp
(after! recentf
  (setq recentf-max-saved-items 500))
#+end_src
***** smartparens :bindings:
#+begin_src elisp
(after! smartparens
  (map! :map smartparens-mode-map
        "s-C-h" #'sp-backward-sexp
        "s-C-l" #'sp-forward-sexp
        "s-C-u" #'sp-backward-up-sexp
        "s-C-o" #'sp-up-sexp
        :gn "s-C-m" #'sp-backward-down-sexp ; Bind in normal mode explicitly to override the Doom mapping in ~/.config/emacs/modules/config/default/config.el:447
        "s-C-." #'sp-down-sexp
        "s-C-c" #'sp-splice-sexp
        "s-C-s" #'sp-splice-sexp-killing-backward
        "s-C-f" #'sp-splice-sexp-killing-forward
        "s-C-x" #'sp-backward-slurp-sexp
        "s-C-v" #'sp-forward-slurp-sexp
        "s-C-w" #'sp-backward-barf-sexp
        "s-C-r" #'sp-forward-barf-sexp
        (:prefix "s-C-;"
         "(" #'sp-wrap-round
         "[" #'sp-wrap-square
         "{" #'sp-wrap-curly
         "s" #'sp-split-sexp
         "j" #'sp-join-sexp
         "r" #'sp-raise-sexp
         "c" #'sp-convolute-sexp
         "w" #'sp-rewrap-sexp)))
#+end_src
****** Hook :bindings:
#+begin_src elisp
(defun biome-sp-strict-h ()
  (add-hook! 'smartparens-enabled-hook :local
             #'turn-on-smartparens-strict-mode
             (defun biome-modify-sp-strict-mode-map-h ()
               (map! :map smartparens-strict-mode-map
                     :i "DEL" #'sp-backward-delete-char))))
#+end_src
***** tldr :persistence:path:
#+begin_src elisp
(use-package! tldr
  :defer t
  :config
  (setq tldr-directory-path (concat doom-etc-dir "tldr/")))
#+end_src
***** tramp :path:guix:
Make tramp work on Guix. Tramp is used locally to do sudo from inside Emacs so include my user-specific paths too.
#+begin_src elisp :noweb yes
(after! tramp
  (prependq! tramp-remote-path
             (-concat (-map (lambda (p)
                              (concat p "/bin"))
                            '(<<guix-extra-profiles>>))
                      '("<<guix-home-profile>>/bin"
                        "~/.config/guix/current/bin"
                        "~/.guix-profile/bin"
                        "~/.guix-profile/sbin"
                        "/run/current-system/profile/bin"
                        "/run/current-system/profile/sbin"))))
#+end_src
***** transient :persistence:
#+begin_src elisp
(after! transient
  (setq transient-history-limit biome--very-big))
#+end_src
***** undo-fu
#+begin_src elisp
(after! undo-fu
  (setq undo-fu-ignore-keyboard-quit t))
#+end_src
***** undo-tree :UI:
- TODO am I commenting code, doing notangle, or using the org ~COMMENT~ keyword (https://orgmode.org/manual/Comment-Lines.html)?
#+begin_src elisp
;; (after! undo-tree
;;   (setq undo-tree-visualizer-timestamps t))
#+end_src
**** Guix System :guix:
- TODO The Guix repo offers some [[https://github.com/guix-mirror/guix/tree/master/etc/snippets][snippets]] and less importantly a copyright inserter I'd like to use ([[https://guix.gnu.org/manual/en/guix.html#The-Perfect-Setup][described here]]) but I don't know where if anywhere the repo code lives on my machine.
#+begin_src elisp
;; (let ((guix-source-path "???/guix"))

;;   (after! yasnippet
;;     (add-to-list 'yas-snippet-dirs (concat guix-source-path "/etc/snippets")))

;;   (after! skeleton
;;     (load-file (concat guix-source-path "/etc/copyright.el")))

;;   (after! copyright
;;     (setq copyright-names-regexp (format "%s <%s>" user-full-name user-mail-address))))
#+end_src
**** Projects
***** Hyperdrive :path:
#+begin_src elisp
(pushnew! safe-local-variable-values
          '(cider-preferred-build-tool . shadow-cljs)
          '(cider-default-cljs-repl . shadow)
          '(cider-shadow-default-options . ":app")
          '(cider-offer-to-open-cljs-app-in-browser . nil)
          '(cider-clojure-cli-global-options . "-A:dev")
          '(eval . (setenv "DATOMIC_APP_INFO_MAP" "{:app-name \"neutrino\"}"))
          '(eval . (setenv "DATOMIC_ENV_MAP" "{:env :dev}"))
          '(cider-clojure-cli-global-options . nil))

(prodigy-define-service
  :name "Amplify Mock"
  :command "amplify"
  :args '("mock")
  :cwd "~/projects/Krush/hyperdrive/apps/singularity"
  :kill-process-buffer-on-stop t)

(prodigy-define-service
  :name "Datomic Access (exogenesis)"
  :command "bash"
  :args '("datomic" "client" "access" "exogenesis")
  :cwd "~/projects/Krush/hyperdrive/ion/team"
  :kill-process-buffer-on-stop t)
#+end_src
***** Massrealty :path:
#+begin_src elisp
;; (pushnew! safe-local-variable-values
;;           '(ssh-deploy-root-remote . "/ssh:massrealty@35.196.144.73:/home/massrealty/deploy/homes/public_html/")
;;           '(ssh-deploy-automatically-detect-remote-changes . t))

;; (after! org-gcal
;;   (add-to-list 'org-gcal-fetch-file-alist `("krzysztof@massrealty.com" . ,(concat biome--org-gcal-dir "/krzysztof@massrealty.com.org")) 'append))
#+end_src
**** WIP
#+begin_src elisp
(after! org
  (add-to-list 'org-agenda-files (concat biome--org-dir "/spring_cleaning") 'append))

;; (map! "s-b" (cmd!
;;              ;; (message "chainging margin")
;;              ;; (message "%s" (selected-window))
;;              (set-window-margins (selected-window) nil (if (cdr (window-margins))
;;                                                            nil 12))))

;; I don't think I'll ever need this with Sway
;; (add-to-list 'initial-frame-alist '(fullscreen . fullboth))

(map! "s-A" #'counsel-linux-app)

(map! :leader
      "s-," (lookup-key doom-leader-map (kbd "<")))

(after! company
  (map! (:map company-active-map
         "s-[" #'company-show-doc-buffer ; Currently opens Help, it would be better if I made it use Helpful.
         "s-]" #'company-show-location)))

(after! evil-org
  (map! :map evil-org-mode-map
        (:prefix "g"
         :nv "{" #'evil-backward-paragraph
         :nv "}" #'evil-forward-paragraph)))

;; TODO Maybe do this if popping to the side is too annoying
;; (after! geiser-repl
;;   (setq geiser-repl-use-other-window nil))

(after! ob
  (setq org-babel-noweb-error-all-langs t))
#+end_src
***** Dotfiles auto-tangle :path:
- TODO Might be easier to do this with file-local variables.
#+begin_src elisp
;; (setq biome--dotfiles-dir "~/projects/dotfiles")

;; (add-hook! 'org-mode-hook
;;   (defun biome-add-org-autotangle-after-save-hook-h ()
;;     (add-hook! 'after-save-hook :local
;;       (defun biome-autotangle-h ()
;;         (when (file-in-directory-p buffer-file-name biome--dotfiles-dir)
;;           ;; TODO ensure there aren't files in the output directory that no longer correspond to the org file. Just wipe it?
;;           (let ((org-confirm-babel-evaluate nil))
;;             (org-babel-tangle)))))))
#+end_src
***** scheme :lang:
#+begin_src elisp
(after! scheme
  (setq-hook! 'scheme-mode-hook indent-tabs-mode nil))
#+end_src
***** guix :guix:
****** guix :UI:
#+begin_src elisp
(after! guix
  (set-popup-rules!
    '(("^\\*Guix" :height 0.5))))
#+end_src
****** guix-devel :lang:
#+begin_src elisp
(use-package! guix-devel
  :hook (scheme-mode . guix-devel-mode))
#+end_src
****** guix-popup :bindings:
#+begin_src elisp
(use-package! guix-popup
  :defer t
  :init
  (map! :leader
        "a" #'guix))  ; TODO temporary binding?
#+end_src
****** guix-prettify :UI:
#+begin_src elisp
(use-package! guix-prettify
  :hook (doom-first-buffer . global-guix-prettify-mode))
#+end_src
***** dired-x :UI:hidden:
#+begin_src elisp
(use-package! dired-x
  :defer t
  :init
  ;; Don't hide things by default. I can't just remove the Doom module's hook or its whole dired-x `use-package!' won't get run, so instead add another hook for `dired-omit-mode' at the end of the hooks list to toggle it off.
  (add-hook! 'dired-mode-hook :append
    (defun biome-disable-dired-omit-mode-h ()
      (when dired-omit-mode
        (dired-omit-mode -1)))))
#+end_src
***** counsel :UI:completion:hidden:
#+begin_src elisp
(after! counsel
  (setq counsel-find-file-ignore-regexp nil)) ; I may want to instead just toggle off `ivy-use-ignore' on invoking `counsel-find-file' so I have the option of switching ignoring back as-needed. ; TODO I just noticed this affects `counsel-file-jump' which I don't want, e.g. listing every git object (but might not matter enough to fix).
#+end_src
***** Projects
****** Dotfiles
#+begin_src elisp
(pushnew! safe-local-variable-values
          '(eval . (with-eval-after-load 'geiser-guile
                     (let ((root-dir
                            (file-name-directory
                             (locate-dominating-file default-directory ".dir-locals.el"))))
                       (make-local-variable 'geiser-guile-load-path)
                       (add-to-list 'geiser-guile-load-path root-dir)))))
#+end_src
***** COMMENT org-tanglesync
#+begin_src elisp
(use-package! org-tanglesync
  :hook ((org-mode . org-tanglesync-mode)
         ((prog-mode text-mode) . org-tanglesync-watch-mode))
  :config
  (setq org-tanglesync-watch-files '("/home/pharcosyle/projects/dotfiles/dotfiles.org")))
#+end_src
*** Packages
#+begin_src elisp :tangle (in-tangle-dir "packages.el")
;; -*- no-byte-compile: t; -*-

(package! bluetooth :pin "147d4690087049c6647b5222ee40baa5002b7586") ; TODO just maybe make this dependent on my "bluetooth feature"
(package! dash :pin "da167c51e9fd167a48d06c7c0ee8e3ac7abd9718") ; TODO make this be introduced by my doom config (where I need it)?
(package! expand-region :pin "95a773bd8f557cbd43d3b2dab2fa4417ec5927ab")
(package! tldr :pin "d3fd2a809a266c005915026799121c78e8b358f0")
(package! trashed :pin "23e782f78d9adf6b5479a01bfac90b2cfbf729fe")
(package! symon :pin "8dd8b6df49b03cd7d31b85aedbe9dd08fb922335")

(package! guix :pin "c9aef52121b458297e70bb50f49f7276b4a8d759")
(package! build-farm :pin "5c268a3c235ace0d79ef1ec82c440120317e06f5") ; REVIEW trying out
(package! guix-packaging ; REVIEW trying out
  :recipe (:host github
           :repo "ryanprior/emacs-guix-packaging"
           :files (:defaults "snippets"))
  :pin "d843088252467db3c8a09de40ae9a62050196a0e")

;; TODO this should probably be specific to the krush/hyperdrive/afterburner(?) project
;; (package! graphql-mode :pin "2371316a750b807de941184d49ca19d277ecadcd")

(package! org-tanglesync :pin "af83a73ae542d5cb3c9d433cbf2ce1d4f4259117")

(package! i3wm-config-mode :pin "c70bdc1367e461299e13a4797bc9d9d950184edd")

(package! code-review :disable t) ; REVIEW Breaks stuff after I updated to emacs 29 latest
#+end_src
*** Theme :UI:theming:
- TODO make the elisp sections subheadings? Pros: more org-mode-y. Cons: Further distances the code from doom-one, there will be a trailing closing paren in a source block all by itself at the end since some of the sections are in an outer sexp.
#+begin_src elisp :tangle (in-tangle-dir "themes/doom-nuclear-theme.el")
;;; doom-nuclear-theme.el --- inspired by Atom One Dark -*- lexical-binding: t; no-byte-compile: t; -*-
;;
;; Copyright (C) 2016-2021 Henrik Lissner
;;
;; Author: Henrik Lissner <https://github.com/hlissner>
;; Created: December 6, 2020
;; Version: 2.0.0
;; Keywords: custom themes, faces
;; Homepage: https://github.com/hlissner/emacs-doom-themes
;; Package-Requires: ((emacs "25.1") (cl-lib "0.5") (doom-themes "2.2.1"))
;;
;;; Commentary:
;;
;; Inspired by Atom's One Dark color scheme.
;;
;;; Code:

(require 'doom-themes)


;;
;;; Variables

(defgroup nuclear-theme nil
  "Options for the `doom-nuclear' theme."
  :group 'doom-themes)

(defcustom nuclear-brighter-modeline nil
  "If non-nil, more vivid colors will be used to style the mode-line."
  :group 'nuclear-theme
  :type 'boolean)

(defcustom nuclear-brighter-comments nil
  "If non-nil, comments will be highlighted in more vivid colors."
  :group 'nuclear-theme
  :type 'boolean)

(defcustom nuclear-padded-modeline doom-themes-padded-modeline
  "If non-nil, adds a 4px padding to the mode-line.
Can be an integer to determine the exact padding."
  :group 'nuclear-theme
  :type '(choice integer boolean))


;;
;;; Theme definition

(def-doom-theme doom-nuclear
  "A dark theme inspired by Atom One Dark."

  ;; name        default   256           16
  ((bg         '("#282c34" "black"       "black" ))
   (fg         '("#DEE2F8" "#bfbfbf"     "brightwhite"  ))

   ;; These are off-color variants of bg/fg, used primarily for `solaire-mode',
   ;; but can also be useful as a basis for subtle highlights (e.g. for hl-line
   ;; or region), especially when paired with the `doom-darken', `doom-lighten',
   ;; and `doom-blend' helper functions.
   (bg-alt     '("#21242b" "black"       "black"        ))
   (fg-alt     '("#5B6268" "#2d2d2d"     "white"        ))

   ;; These should represent a spectrum from bg to fg, where base0 is a starker
   ;; bg and base8 is a starker fg. For example, if bg is light grey and fg is
   ;; dark grey, base0 should be white and base8 should be black.
   (base0      '("#1B2229" "black"       "black"        ))
   (base1      '("#1c1f24" "#1e1e1e"     "brightblack"  ))
   (base2      '("#202328" "#2e2e2e"     "brightblack"  ))
   (base3      '("#23272e" "#262626"     "brightblack"  ))
   (base4      '("#3f444a" "#3f3f3f"     "brightblack"  ))
   (base5      '("#5B6268" "#525252"     "brightblack"  ))
   (base6      '("#73797e" "#6b6b6b"     "brightblack"  ))
   (base7      '("#9ca0a4" "#979797"     "brightblack"  ))
   (base8      '("#DFDFDF" "#dfdfdf"     "white"        ))

   (grey       base4)
   (red        '("#FB8578" "#ff6655" "red"          ))
   (orange     '("#FDCE5F" "#dd8844" "brightred"    ))
   (green      '("#9FED9C" "#99bb66" "green"        ))
   (teal       '("#4db5bd" "#44b9b1" "brightgreen"  ))
   (yellow     '("#EDDC91" "#ECBE7B" "yellow"       ))
   (blue       '("#7DB9FE" "#51afef" "brightblue"   ))
   (dark-blue  '("#5F68DE" "#2257A0" "blue"         ))
   (magenta    '("#E29BF7" "#c678dd" "brightmagenta"))
   (violet     '("#AEB9F3" "#a9a1e1" "magenta"      ))
   (cyan       '("#75E0F9" "#46D9FF" "brightcyan"   ))
   (dark-cyan  '("#5699AF" "#5699AF" "cyan"         ))

   ;; These are the "universal syntax classes" that doom-themes establishes.
   ;; These *must* be included in every doom themes, or your theme will throw an
   ;; error, as they are used in the base theme defined in doom-themes-base.
   (highlight      "#8496FF")
   (vertical-bar   (doom-darken base1 0.1))
   (selection      dark-blue)
   (builtin        blue)
   (comments       (if nuclear-brighter-comments dark-cyan "#63677F"))
   (doc-comments   (doom-lighten (if nuclear-brighter-comments dark-cyan base5) 0.25))
   (constants      yellow)
   (functions      blue)
   (keywords       magenta)
   (methods        violet)
   (operators      cyan)
   (type           orange)
   (strings        green)
   (variables      red)
   (numbers        violet)
   (region         `(,(doom-lighten (car bg-alt) 0.15) ,@(doom-lighten (cdr base1) 0.35)))
   (error          red)
   (warning        yellow)
   (success        green)
   (vc-modified    orange)
   (vc-added       green)
   (vc-deleted     red)

   ;; These are extra color variables used only in this theme; i.e. they aren't
   ;; mandatory for derived themes.
   (modeline-fg              fg)
   (modeline-fg-alt          base5)
   (modeline-bg              (if nuclear-brighter-modeline
                                 (doom-darken blue 0.45)
                               (doom-darken bg-alt 0.1)))
   (modeline-bg-alt          (if nuclear-brighter-modeline
                                 (doom-darken blue 0.475)
                               `(,(doom-darken (car bg-alt) 0.15) ,@(cdr bg))))
   (modeline-bg-inactive     `(,(car bg-alt) ,@(cdr base1)))
   (modeline-bg-inactive-alt `(,(doom-darken (car bg-alt) 0.1) ,@(cdr bg)))

   (-modeline-pad
    (when nuclear-padded-modeline
      (if (integerp nuclear-padded-modeline) nuclear-padded-modeline 4))))


  ;;;; Base theme face overrides
  (((line-number &override) :foreground base4)
   ((line-number-current-line &override) :foreground violet)
   ((font-lock-comment-face &override)
    :background (if nuclear-brighter-comments (doom-lighten bg 0.05)))
   (font-lock-comment-delimiter-face :foreground "#939abd")
   (font-lock-doc-face
    :inherit 'font-lock-comment-face
    :foreground cyan)
   (mode-line
    :background modeline-bg :foreground modeline-fg
    :box (if -modeline-pad `(:line-width ,-modeline-pad :color ,modeline-bg)))
   (mode-line-inactive
    :background modeline-bg-inactive :foreground modeline-fg-alt
    :box (if -modeline-pad `(:line-width ,-modeline-pad :color ,modeline-bg-inactive)))
   (mode-line-emphasis :foreground (if nuclear-brighter-modeline base8 highlight))

   ;;;; clojure-mode
   (clojure-interop-method-face :foreground cyan)
   (clojure-character-face :foreground violet :weight 'bold)
   ;;;; css-mode <built-in> / scss-mode
   (css-proprietary-property :foreground orange)
   (css-property             :foreground green)
   (css-selector             :foreground blue)
   ;;;; doom-modeline
   (doom-modeline-bar :background (if nuclear-brighter-modeline modeline-bg highlight))
   (doom-modeline-buffer-file :inherit 'mode-line-buffer-id :weight 'bold)
   (doom-modeline-buffer-path :inherit 'mode-line-emphasis :weight 'bold)
   (doom-modeline-buffer-project-root :foreground green :weight 'bold)
   ;;;; elscreen
   (elscreen-tab-other-screen-face :background "#353a42" :foreground "#1e2022")
   ;;;; ivy
   (ivy-current-match :background dark-blue :distant-foreground base0 :weight 'normal)
   ;;;; LaTeX-mode
   (font-latex-math-face :foreground green)
   ;;;; markdown-mode
   (markdown-markup-face :foreground base5)
   (markdown-header-face :inherit 'bold :foreground red)
   ((markdown-code-face &override) :background (doom-lighten base3 0.05))
   ;;;; rainbow-delimiters
   (rainbow-delimiters-depth-1-face :foreground fg)
   (rainbow-delimiters-depth-2-face :foreground magenta)
   (rainbow-delimiters-depth-3-face :foreground blue)
   (rainbow-delimiters-depth-4-face :foreground cyan)
   (rainbow-delimiters-depth-5-face :foreground green)
   (rainbow-delimiters-depth-6-face :foreground yellow)
   (rainbow-delimiters-depth-7-face :foreground orange)
   (rainbow-delimiters-depth-8-face :foreground red)
   ;;;; rjsx-mode
   (rjsx-tag :foreground red)
   (rjsx-attr :foreground orange)
   ;;;; solaire-mode
   (solaire-mode-line-face
    :inherit 'mode-line
    :background modeline-bg-alt
    :box (if -modeline-pad `(:line-width ,-modeline-pad :color ,modeline-bg-alt)))
   (solaire-mode-line-inactive-face
    :inherit 'mode-line-inactive
    :background modeline-bg-inactive-alt
    :box (if -modeline-pad `(:line-width ,-modeline-pad :color ,modeline-bg-inactive-alt))))

  ;;;; Base theme variable overrides-
  ())

;;; doom-nuclear-theme.el ends here
#+end_src
** WIP emacs
*** doom-emacs-temp
- TODO probably "export" the ~doom~ program to user profile
#+begin_src scheme :tangle (in-tangle-dir "doom-emacs-temp.scm")
(define-module (ebullient home doom-emacs-temp)
  #:use-module (guix gexp)
  #:use-module (guix packages)
  #:use-module (guix build-system trivial)
  #:use-module ((guix licenses) #:prefix license:)
  #:use-module ((gnu packages base) #:select (coreutils))
  ;; #:use-module ((gnu packages emacs) #:select (emacs))
  #:use-module ((gnu packages llvm) #:select (clang))
  #:use-module ((gnu packages rust-apps) #:select (fd ripgrep))
  #:use-module ((gnu packages version-control) #:select (git)))

(define-public doom-emacs-temp
  (package
    (name "doom-emacs-temp")
    (version "0")
    (source #f)
    ;; TODO Ideally these wouldn't be propagated inputs. Instead of tracking down usages of these and doing `substitute' everywhere maybe `wrap-prgram' is an option? However maybe there are other things in these inputs than just binaries Doom depends on or it has parts outside of emacs that recquire them?
    (propagated-inputs
     (list
      ;; Required
      ;; emacs ; TODO uncomment and wrap usage(s) with `package-input-rewriting`
      git
      ripgrep
      ;; Optional
      coreutils ; TODO might not be necessary because emacs Guix package already adds "coreutils/bin" to PATH with `wrap-program'
      fd
      clang ; TODO I still don't know what this is for. Notably hlissner doesn't install clang, nor gcc, in his emacs "module" in his dotfiles.
      ))
    (build-system trivial-build-system)
    (arguments
     `(#:modules ((guix build utils))
       #:builder
       ,#~(begin
            (use-modules (guix build utils))
            (mkdir-p (string-append #$output "/asdf"))
            (with-output-to-file (string-append #$output "/asdf/asdf.txt")
              (lambda _
                (display "asdffffffffffff")))
            #t)))
    (synopsis "An Emacs framework for the stubborn martian hacker")
    (description synopsis)
    (home-page "https://github.com/hlissner/doom-emacs")
    (license license:expat)))
#+end_src
*** COMMENT Emacs Application Framework
#+begin_src scheme :tangle (in-tangle-dir "emacs-application-framework.scm")
(use-modules (guix build-system emacs)
             (guix git-download)
             (guix packages)
             ((guix licenses) #:prefix license:))

(let ((commit "5c99dc6962fbe2f95033678d82b6dc1414460c0a")
      (revision "0"))
  (package
    (name "emacs-application-framework")
    (version (git-version "0.5" revision commit))
    (source (origin
              (method git-fetch)
              (uri (git-reference
                    (url "https://github.com/manateelazycat/emacs-application-framework")
                    (commit commit)))
              (file-name (git-file-name name version))
              (sha256
               (base32
                ""))))
    (build-system emacs-build-system)
    (native-inputs
     (list emacs-ert-runner))
    (arguments
     `(#:tests? #t
       #:test-command '("ert-runner")
       #:modules ((guix build emacs-build-system)
                  (guix build utils)
                  (guix build emacs-utils)
                  (srfi srfi-1))
       #:phases
       (modify-phases %standard-phases
         (add-after 'unpack 'move-themes
           (lambda _
             ;; Move the source files to the top level, which is in the
             ;; EMACSLOADPATH.
             (for-each (lambda (f)
                         (rename-file f (basename f)))
                       (find-files "./themes" ".*\\.el$"))
             #t)))))
    (synopsis "Emacs Application Framework (EAF)")
    (description "GUI application framework for Emacs that revolutionizes its multimedia and graphical capabilities to ultimately Live in Emacs.")
    (home-page "https://github.com/manateelazycat/emacs-application-framework")
    (license license:gpl3+)))
#+end_src
* Channels
:PROPERTIES:
:tangle-dir+: /ebullient
:END:
#+begin_src scheme :tangle (in-tangle-dir "channels.scm")
(define-module (ebullient channels)
  #:use-module (guix channels)
  #:use-module ((srfi srfi-1) #:select (remove))
  #:export (get-channels
            guix
            nonguix
            rde
            flat))

(define* (get-channels #:rest cs)
  (append
   cs
   (remove (let ((names (map (lambda (c) (channel-name c)) cs)))
             (lambda (c)
               (member (channel-name c) names)))
           %default-channels)))

(define guix %default-guix-channel)

(define nonguix
  (channel
   (name 'nonguix)
   (url "https://gitlab.com/nonguix/nonguix")
   (introduction
    (make-channel-introduction
     "897c1a470da759236cc11798f4e0a5f7d4d59fbc"
     (openpgp-fingerprint
      "2A39 3FFF 68F4 EF7A 3D29  12AF 6F51 20A0 22FB B2D5")))))

(define rde
  (channel
   (name 'rde)
   (url "https://git.sr.ht/~abcdw/rde")
   (introduction
    (make-channel-introduction
     "257cebd587b66e4d865b3537a9a88cccd7107c95"
     (openpgp-fingerprint
      "2841 9AC6 5038 7440 C7E9  2FFA 2208 D209 58C1 DEB0")))))

(define flat
  (channel
   (name 'flat)
   (url "https://github.com/flatwhatson/guix-channel.git")
   (introduction
    (make-channel-introduction
     "33f86a4b48205c0dc19d7c036c85393f0766f806"
     (openpgp-fingerprint
      "736A C00E 1254 378B A982  7AF6 9DBE 8265 81B6 4490")))))
#+end_src
* WIP channels
#+begin_src scheme :tangle (in-tangle-dir "frostfire-channels.scm")
(use-modules (ebullient channels))
(get-channels nonguix)
#+end_src
#+begin_src scheme :tangle (in-tangle-dir "solitude-channels.scm")
(use-modules (ebullient channels))
(get-channels nonguix rde flat)
#+end_src
#+begin_src sh :results output silent :dir base-tangle-dir :async
guix pull --load-path=. --channels=solitude-channels.scm
guix describe --format=channels > solitude-channels-lock.scm
#+end_src
#+begin_src sh :results output silent :dir base-tangle-dir :async
GUIX_EXTRA=$HOME/.guix-extra
mkdir -p $GUIX_EXTRA
profileName=frostfire
profilePath="$GUIX_EXTRA/$profileName"
mkdir -p $profilePath
guix pull --load-path=. --channels=frostfire-channels.scm --profile="$profilePath/$profileName"

guix="$GUIX_EXTRA/$profileName/$profileName"/bin/guix
$guix describe --format=channels > frostfire-channels-lock.scm
#+end_src
#+begin_src sh :results output silent :dir base-tangle-dir :async
$guix="$GUIX_EXTRA/$profileName/$profileName"/bin/guix
sudo $guix system --load-path=. --expression='(@ (ebullient system hosts frostfire) frostfire)' reconfigure
#+end_src
* Packages
:PROPERTIES:
:tangle-dir+: /ebullient/packages
:END:
** Dracula Theme
#+begin_src scheme :tangle (in-tangle-dir "dracula-theme.scm")
(define-module (ebullient packages dracula-theme)
  #:use-module (guix git-download)
  #:use-module (guix packages)
  #:use-module ((gnu packages gnome-xyz) #:select (nordic-theme)))

(define-public dracula-theme
  (let ((commit "ceec1c102c5e16810a58d04f08dba0c4116f61dd")
        (revision "0"))
    (package (inherit nordic-theme)
      (name "dracula-theme")
      (version (git-version "2.0" revision commit))
      (source
       (origin
         (method git-fetch)
         (uri (git-reference
               (url "https://github.com/dracula/gtk")
               (commit commit)))
         (sha256
          (base32
           "1rbwyhipv086b58gc8fw4r0y5zg79rv2i9lx02b5pg0khgf61mf2"))))
      ;; TODO ideally don't copypasta the `#:exclude' part from nordic-theme. Then again maybe don't bother inheriting at all (just add the `build-system' and `license' fields)
      (arguments
       `(#:install-plan
         `(("." "share/themes/Dracula"
            #:exclude ("README.md" "LICENSE" "Art/" "package.json"
                       "package-lock.json" "Gulpfile.js")))))
      (home-page "https://github.com/dracula/gtk")
      (synopsis "A flat and light theme with a modern look")
      (description synopsis))))
#+end_src
** Emacs 29 with pgtk/nativecomp
#+begin_src scheme :tangle (in-tangle-dir "emacs.scm")
(define-module (ebullient packages emacs)
  #:use-module ((gnu packages emacs) #:select (emacs-next-pgtk))
  #:use-module ((gnu packages gcc) #:select (gcc-11)))

(define emacs-from-git (@@ (flat packages emacs) emacs-from-git))
(define emacs-with-native-comp (@@ (flat packages emacs) emacs-with-native-comp))

(define-public emacs-29-pgtk-native-comp
  (emacs-from-git
   (emacs-with-native-comp emacs-next-pgtk gcc-11 'full-aot)
   #:pkg-name "emacs-29-pgtk-native-comp"
   #:pkg-version "29.0.50"
   #:pkg-revision "0"
   #:git-repo "https://git.savannah.gnu.org/git/emacs.git"
   #:git-commit "b88024ad1aa0c2e75b407634038050a653fdb64b"
   #:checksum "0scndcivdmxb7ndasqx3icmz75kxgq1gmyvy0bidcl145ry4dp0q"))
#+end_src
* Utils
:PROPERTIES:
:tangle-dir+: /ebullient
:END:
#+begin_src scheme :tangle (in-tangle-dir "utils.scm")
(define-module (ebullient utils)
  #:use-module (guix packages)
  #:use-module (gnu services)
  #:export (update-list
            ->
            as->
            update-services*))

(define (update-list l pred f)
  (map (lambda (x)
         (if (pred x) (f x) x))
       l))

(define-syntax ->
  (syntax-rules ()
    ((_ value) value)
    ((_ value (f1 . body) next ...) (-> (f1 value . body) next ...))
    ((_ value f1 next ...) (-> (f1 value) next ...))))

(define-syntax as->
  (syntax-rules ()
    ((_ expr name) expr)
    ((_ expr name form form* ...)
     (let ((name expr))
       (as-> form name form* ...)))))

(define (update-services* services pred update-fn)
  (update-list
   services
   pred
   (lambda (svc)
     (service (service-kind svc)
              (update-fn (service-value svc))))))
#+end_src
* Dev
** Git ignore
#+begin_src gitignore :tangle (in-tangle-dir ".gitignore")
/.gitignore
/ebullient/
/.dir-locals.el

# WIP
/frostfire-channels.scm
/solitude-channels.scm
#+end_src
** Github
*** Git config
#+begin_src gitconfig :tangle (in-tangle-dir ".git/config")
[remote "origin"]
	url = https://github.com/pharcosyle/dotfiles.git
	fetch = +refs/heads/*:refs/remotes/origin/*

[branch "master"]
	remote = origin
	merge = refs/heads/master
#+end_src
* Dev local
** Git config
#+begin_src gitconfig :tangle (in-tangle-dir ".git/config")
[core]
	repositoryformatversion = 0
	filemode = true
	bare = false
	logallrefupdates = true
#+end_src
** Emacs directory-local variables
#+begin_src elisp :tangle (in-tangle-dir ".dir-locals.el")
((nil
  (eval . (with-eval-after-load 'geiser-guile
            (let ((root-dir
                   (file-name-directory
                    (locate-dominating-file default-directory ".dir-locals.el"))))
              (make-local-variable 'geiser-guile-load-path)
              (add-to-list 'geiser-guile-load-path root-dir))))))
#+end_src
